    1|       |/**
    2|       | * @file
    3|       | * @brief Implementation of the Unbounded 0/1 Knapsack Problem
    4|       | *
    5|       | * @details
    6|       | * The Unbounded 0/1 Knapsack problem allows taking unlimited quantities of each
    7|       | * item. The goal is to maximize the total value without exceeding the given
    8|       | * knapsack capacity. Unlike the 0/1 knapsack, where each item can be taken only
    9|       | * once, in this variation, any item can be picked any number of times as long
   10|       | * as the total weight stays within the knapsack's capacity.
   11|       | *
   12|       | * Given a set of N items, each with a weight and a value, represented by the
   13|       | * arrays `wt` and `val` respectively, and a knapsack with a weight limit W, the
   14|       | * task is to fill the knapsack to maximize the total value.
   15|       | *
   16|       | * @note weight and value of items is greater than zero
   17|       | *
   18|       | * ### Algorithm
   19|       | * The approach uses dynamic programming to build a solution iteratively.
   20|       | * A 2D array is used for memoization to store intermediate results, allowing
   21|       | * the function to avoid redundant calculations.
   22|       | *
   23|       | * @author [Sanskruti Yeole](https://github.com/yeolesanskruti)
   24|       | * @see dynamic_programming/0_1_knapsack.cpp
   25|       | */
   26|       |
   27|       |#include <cassert>   // For using assert function to validate test cases
   28|       |#include <cstdint>   // For fixed-width integer types like std::uint16_t
   29|       |#include <iostream>  // Standard input-output stream
   30|       |#include <vector>    // Standard library for using dynamic arrays (vectors)
   31|       |
   32|       |/**
   33|       | * @namespace dynamic_programming
   34|       | * @brief Namespace for dynamic programming algorithms
   35|       | */
   36|       |namespace dynamic_programming {
   37|       |
   38|       |/**
   39|       | * @namespace Knapsack
   40|       | * @brief Implementation of unbounded 0-1 knapsack problem
   41|       | */
   42|       |namespace unbounded_knapsack {
   43|       |
   44|       |/**
   45|       | * @brief Recursive function to calculate the maximum value obtainable using
   46|       | *        an unbounded knapsack approach.
   47|       | *
   48|       | * @param i Current index in the value and weight vectors.
   49|       | * @param W Remaining capacity of the knapsack.
   50|       | * @param val Vector of values corresponding to the items.
   51|       | * @note "val" data type can be changed according to the size of the input.
   52|       | * @param wt Vector of weights corresponding to the items.
   53|       | * @note "wt" data type can be changed according to the size of the input.
   54|       | * @param dp 2D vector for memoization to avoid redundant calculations.
   55|       | * @return The maximum value that can be obtained for the given index and
   56|       | * capacity.
   57|       | */
   58|       |std::uint16_t KnapSackFilling(std::uint16_t i, std::uint16_t W,
   59|       |                              const std::vector<std::uint16_t>& val,
   60|       |                              const std::vector<std::uint16_t>& wt,
   61|      0|                              std::vector<std::vector<int>>& dp) {
   62|      0|    if (i == 0) {
   63|      0|        if (wt[0] <= W) {
   64|      0|            return (W / wt[0]) *
   65|      0|                   val[0];  // Take as many of the first item as possible
   66|      0|        } else {
   67|      0|            return 0;  // Can't take the first item
   68|      0|        }
   69|      0|    }
   70|      0|    if (dp[i][W] != -1)
   71|      0|        return dp[i][W];  // Return result if available
   72|       |
   73|      0|    int nottake =
   74|      0|        KnapSackFilling(i - 1, W, val, wt, dp);  // Value without taking item i
   75|      0|    int take = 0;
   76|      0|    if (W >= wt[i]) {
   77|      0|        take = val[i] + KnapSackFilling(i, W - wt[i], val, wt,
   78|      0|                                        dp);  // Value taking item i
   79|      0|    }
   80|      0|    return dp[i][W] =
   81|      0|               std::max(take, nottake);  // Store and return the maximum value
   82|      0|}
   83|       |
   84|       |/**
   85|       | * @brief Wrapper function to initiate the unbounded knapsack calculation.
   86|       | *
   87|       | * @param N Number of items.
   88|       | * @param W Maximum weight capacity of the knapsack.
   89|       | * @param val Vector of values corresponding to the items.
   90|       | * @param wt Vector of weights corresponding to the items.
   91|       | * @return The maximum value that can be obtained for the given capacity.
   92|       | */
   93|       |std::uint16_t unboundedKnapsack(std::uint16_t N, std::uint16_t W,
   94|       |                                const std::vector<std::uint16_t>& val,
   95|      0|                                const std::vector<std::uint16_t>& wt) {
   96|      0|    if (N == 0)
   97|      0|        return 0;  // Expect 0 since no items
   98|      0|    std::vector<std::vector<int>> dp(
   99|      0|        N, std::vector<int>(W + 1, -1));  // Initialize memoization table
  100|      0|    return KnapSackFilling(N - 1, W, val, wt, dp);  // Start the calculation
  101|      0|}
  102|       |
  103|       |}  // namespace unbounded_knapsack
  104|       |
  105|       |}  // namespace dynamic_programming
  106|       |
  107|       |/**
  108|       | * @brief self test implementation
  109|       | * @return void
  110|       | */
  111|      0|static void tests() {
  112|       |    // Test Case 1
  113|      0|    std::uint16_t N1 = 4;                            // Number of items
  114|      0|    std::vector<std::uint16_t> wt1 = {1, 3, 4, 5};   // Weights of the items
  115|      0|    std::vector<std::uint16_t> val1 = {6, 1, 7, 7};  // Values of the items
  116|      0|    std::uint16_t W1 = 8;  // Maximum capacity of the knapsack
  117|       |    // Test the function and assert the expected output
  118|      0|    assert(dynamic_programming::unbounded_knapsack::unboundedKnapsack(
  119|      0|               N1, W1, val1, wt1) == 48);
  120|      0|    std::cout << "Maximum Knapsack value "
  121|      0|              << dynamic_programming::unbounded_knapsack::unboundedKnapsack(
  122|      0|                     N1, W1, val1, wt1)
  123|      0|              << std::endl;
  124|       |
  125|       |    // Test Case 2
  126|      0|    std::uint16_t N2 = 3;                              // Number of items
  127|      0|    std::vector<std::uint16_t> wt2 = {10, 20, 30};     // Weights of the items
  128|      0|    std::vector<std::uint16_t> val2 = {60, 100, 120};  // Values of the items
  129|      0|    std::uint16_t W2 = 5;  // Maximum capacity of the knapsack
  130|       |    // Test the function and assert the expected output
  131|      0|    assert(dynamic_programming::unbounded_knapsack::unboundedKnapsack(
  132|      0|               N2, W2, val2, wt2) == 0);
  133|      0|    std::cout << "Maximum Knapsack value "
  134|      0|              << dynamic_programming::unbounded_knapsack::unboundedKnapsack(
  135|      0|                     N2, W2, val2, wt2)
  136|      0|              << std::endl;
  137|       |
  138|       |    // Test Case 3
  139|      0|    std::uint16_t N3 = 3;                           // Number of items
  140|      0|    std::vector<std::uint16_t> wt3 = {2, 4, 6};     // Weights of the items
  141|      0|    std::vector<std::uint16_t> val3 = {5, 11, 13};  // Values of the items
  142|      0|    std::uint16_t W3 = 27;  // Maximum capacity of the knapsack
  143|       |    // Test the function and assert the expected output
  144|      0|    assert(dynamic_programming::unbounded_knapsack::unboundedKnapsack(
  145|      0|               N3, W3, val3, wt3) == 27);
  146|      0|    std::cout << "Maximum Knapsack value "
  147|      0|              << dynamic_programming::unbounded_knapsack::unboundedKnapsack(
  148|      0|                     N3, W3, val3, wt3)
  149|      0|              << std::endl;
  150|       |
  151|       |    // Test Case 4
  152|      0|    std::uint16_t N4 = 0;                  // Number of items
  153|      0|    std::vector<std::uint16_t> wt4 = {};   // Weights of the items
  154|      0|    std::vector<std::uint16_t> val4 = {};  // Values of the items
  155|      0|    std::uint16_t W4 = 10;                 // Maximum capacity of the knapsack
  156|      0|    assert(dynamic_programming::unbounded_knapsack::unboundedKnapsack(
  157|      0|               N4, W4, val4, wt4) == 0);
  158|      0|    std::cout << "Maximum Knapsack value for empty arrays: "
  159|      0|              << dynamic_programming::unbounded_knapsack::unboundedKnapsack(
  160|      0|                     N4, W4, val4, wt4)
  161|      0|              << std::endl;
  162|       |
  163|      0|    std::cout << "All test cases passed!" << std::endl;
  164|      0|}
  165|       |
  166|       |/**
  167|       | * @brief main function
  168|       | * @return 0 on successful exit
  169|       | */
  170|      0|int main() {
  171|      0|    tests();  // Run self test implementation
  172|      0|    return 0;
  173|      0|}

