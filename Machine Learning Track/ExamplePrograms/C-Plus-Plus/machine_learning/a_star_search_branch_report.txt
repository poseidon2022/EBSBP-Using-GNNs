    1|       |/**
    2|       | * @brief
    3|       | * [A* search algorithm](https://en.wikipedia.org/wiki/A*_search_algorithm)
    4|       | * @details
    5|       | * A* is an informed search algorithm, or a best-first search, meaning that it
    6|       | * is formulated in terms of weighted graphs: starting from a specific starting
    7|       | * node of a graph (initial state), it aims to find a path to the given goal
    8|       | * node having the smallest cost (least distance travelled, shortest time,
    9|       | * etc.). It evaluates by maintaining a tree of paths originating at the start
   10|       | * node and extending those paths one edge at a time until it reaches the final
   11|       | * state.
   12|       | * The weighted edges (or cost) is evaluated on two factors, G score
   13|       | * (cost required from starting node or initial state to current state) and H
   14|       | * score (cost required from current state to final state). The F(state), then
   15|       | * is evaluated as:
   16|       | * F(state) = G(state) + H(state).
   17|       | *
   18|       | * To solve the given search with shortest cost or path possible  is to inspect
   19|       | * values having minimum F(state).
   20|       | * @author [Ashish Daulatabad](https://github.com/AshishYUO)
   21|       | */
   22|       |#include <algorithm>   /// for `std::reverse` function
   23|       |#include <array>       /// for `std::array`, representing `EightPuzzle` board
   24|       |#include <cassert>     /// for `assert`
   25|       |#include <functional>  /// for `std::function` STL
   26|       |#include <iostream>    /// for IO operations
   27|       |#include <map>         /// for `std::map` STL
   28|       |#include <memory>      /// for `std::shared_ptr`
   29|       |#include <set>         /// for `std::set` STL
   30|       |#include <vector>      /// for `std::vector` STL
   31|       |/**
   32|       | * @namespace machine_learning
   33|       | * @brief Machine learning algorithms
   34|       | */
   35|       |namespace machine_learning {
   36|       |/**
   37|       | * @namespace aystar_search
   38|       | * @brief Functions for [A*
   39|       | * Search](https://en.wikipedia.org/wiki/A*_search_algorithm) implementation.
   40|       | */
   41|       |namespace aystar_search {
   42|       |/**
   43|       | * @class EightPuzzle
   44|       | * @brief A class defining [EightPuzzle/15-Puzzle
   45|       | * game](https://en.wikipedia.org/wiki/15_puzzle).
   46|       | * @details
   47|       | * A well known 3 x 3 puzzle of the form
   48|       | * `
   49|       | * 1   2   3
   50|       | * 4   5   6
   51|       | * 7   8   0
   52|       | * `
   53|       | * where `0` represents an empty space in the puzzle
   54|       | * Given any random state, the goal is to achieve the above configuration
   55|       | * (or any other configuration if possible)
   56|       | * @tparam N size of the square Puzzle, default is set to 3 (since it is
   57|       | * EightPuzzle)
   58|       | */
   59|       |template <size_t N = 3>
   60|       |class EightPuzzle {
   61|       |    std::array<std::array<uint32_t, N>, N>
   62|       |        board;  /// N x N array to store the current state of the Puzzle.
   63|       |
   64|       |    std::vector<std::pair<int8_t, int8_t>> moves = {
   65|       |        {0, 1},
   66|       |        {1, 0},
   67|       |        {0, -1},
   68|       |        {-1,
   69|       |         0}};  /// A helper array to evaluate the next state from current state;
   70|       |    /**
   71|       |     * @brief Finds an empty space in puzzle (in this case; a zero)
   72|       |     * @returns a pair indicating integer distances from top and right
   73|       |     * respectively, else returns -1, -1
   74|       |     */
   75|    171|    std::pair<uint32_t, uint32_t> find_zero() {
   76|    489|        for (size_t i = 0; i < N; ++i) {
   77|  2.04k|            for (size_t j = 0; j < N; ++j) {
   78|  1.72k|                if (!board[i][j]) {
   79|    171|                    return {i, j};
   80|    171|                }
   81|  1.72k|            }
   82|    489|        }
   83|      0|        return {-1, -1};
   84|    171|    }
  ------------------
  | _ZN16machine_learning13aystar_search11EightPuzzleILm3EE9find_zeroEv:
  |   75|     34|    std::pair<uint32_t, uint32_t> find_zero() {
  |   76|     76|        for (size_t i = 0; i < N; ++i) {
  |   77|    236|            for (size_t j = 0; j < N; ++j) {
  |   78|    194|                if (!board[i][j]) {
  |   79|     34|                    return {i, j};
  |   80|     34|                }
  |   81|    194|            }
  |   82|     76|        }
  |   83|      0|        return {-1, -1};
  |   84|     34|    }
  ------------------
  | _ZN16machine_learning13aystar_search11EightPuzzleILm4EE9find_zeroEv:
  |   75|    137|    std::pair<uint32_t, uint32_t> find_zero() {
  |   76|    413|        for (size_t i = 0; i < N; ++i) {
  |   77|  1.80k|            for (size_t j = 0; j < N; ++j) {
  |   78|  1.53k|                if (!board[i][j]) {
  |   79|    137|                    return {i, j};
  |   80|    137|                }
  |   81|  1.53k|            }
  |   82|    413|        }
  |   83|      0|        return {-1, -1};
  |   84|    137|    }
  ------------------
   85|       |    /**
   86|       |     * @brief check whether the index value is bounded within the puzzle area
   87|       |     * @param value index for the current board
   88|       |     * @returns `true` if index is within the board, else `false`
   89|       |     */
   90|   136k|    inline bool in_range(const uint32_t value) const { return value < N; }
  ------------------
  | _ZNK16machine_learning13aystar_search11EightPuzzleILm3EE8in_rangeEj:
  |   90|  10.4k|    inline bool in_range(const uint32_t value) const { return value < N; }
  ------------------
  | _ZNK16machine_learning13aystar_search11EightPuzzleILm4EE8in_rangeEj:
  |   90|   126k|    inline bool in_range(const uint32_t value) const { return value < N; }
  ------------------
   91|       |
   92|       | public:
   93|       |    /**
   94|       |     * @brief get the value from i units from right and j units from left side
   95|       |     * of the board
   96|       |     * @param i integer denoting ith row
   97|       |     * @param j integer denoting column
   98|       |     * @returns non-negative integer denoting the value at ith row and jth
   99|       |     * column
  100|       |     * @returns -1 if invalid i or j position
  101|       |     */
  102|  67.8k|    uint32_t get(size_t i, size_t j) const {
  103|  67.8k|        if (in_range(i) && in_range(j)) {
  104|  67.8k|            return board[i][j];
  105|  67.8k|        }
  106|      0|        return -1;
  107|  67.8k|    }
  ------------------
  | _ZNK16machine_learning13aystar_search11EightPuzzleILm3EE3getEmm:
  |  102|  5.07k|    uint32_t get(size_t i, size_t j) const {
  |  103|  5.07k|        if (in_range(i) && in_range(j)) {
  |  104|  5.07k|            return board[i][j];
  |  105|  5.07k|        }
  |  106|      0|        return -1;
  |  107|  5.07k|    }
  ------------------
  | _ZNK16machine_learning13aystar_search11EightPuzzleILm4EE3getEmm:
  |  102|  62.7k|    uint32_t get(size_t i, size_t j) const {
  |  103|  62.7k|        if (in_range(i) && in_range(j)) {
  |  104|  62.7k|            return board[i][j];
  |  105|  62.7k|        }
  |  106|      0|        return -1;
  |  107|  62.7k|    }
  ------------------
  108|       |    /**
  109|       |     * @brief Returns the current state of the board
  110|       |     */
  111|      7|    std::array<std::array<uint32_t, N>, N> get_state() { return board; }
  ------------------
  | _ZN16machine_learning13aystar_search11EightPuzzleILm3EE9get_stateEv:
  |  111|      6|    std::array<std::array<uint32_t, N>, N> get_state() { return board; }
  ------------------
  | _ZN16machine_learning13aystar_search11EightPuzzleILm4EE9get_stateEv:
  |  111|      1|    std::array<std::array<uint32_t, N>, N> get_state() { return board; }
  ------------------
  112|       |
  113|       |    /**
  114|       |     * @brief returns the size of the EightPuzzle (number of row / column)
  115|       |     * @return N, the size of the puzzle.
  116|       |     */
  117|   141k|    inline size_t get_size() const { return N; }
  ------------------
  | _ZNK16machine_learning13aystar_search11EightPuzzleILm3EE8get_sizeEv:
  |  117|  12.5k|    inline size_t get_size() const { return N; }
  ------------------
  | _ZNK16machine_learning13aystar_search11EightPuzzleILm4EE8get_sizeEv:
  |  117|   129k|    inline size_t get_size() const { return N; }
  ------------------
  118|       |    /**
  119|       |     * @brief Default constructor for EightPuzzle
  120|       |     */
  121|      0|    EightPuzzle() {
  122|      0|        for (size_t i = 0; i < N; ++i) {
  123|      0|            for (size_t j = 0; j < N; ++j) {
  124|      0|                board[i][j] = ((i * 3 + j + 1) % (N * N));
  125|      0|            }
  126|      0|        }
  127|      0|    }
  ------------------
  | Unexecuted instantiation: _ZN16machine_learning13aystar_search11EightPuzzleILm3EEC2Ev
  ------------------
  | Unexecuted instantiation: _ZN16machine_learning13aystar_search11EightPuzzleILm4EEC2Ev
  ------------------
  128|       |    /**
  129|       |     * @brief Parameterized Constructor for EightPuzzle
  130|       |     * @param init a 2-dimensional array denoting a puzzle configuration
  131|       |     */
  132|       |    explicit EightPuzzle(const std::array<std::array<uint32_t, N>, N> &init)
  133|    513|        : board(init) {}
  ------------------
  | _ZN16machine_learning13aystar_search11EightPuzzleILm3EEC2ERKSt5arrayIS3_IjLm3EELm3EE:
  |  133|     98|        : board(init) {}
  ------------------
  | _ZN16machine_learning13aystar_search11EightPuzzleILm4EEC2ERKSt5arrayIS3_IjLm4EELm4EE:
  |  133|    415|        : board(init) {}
  ------------------
  134|       |
  135|       |    /**
  136|       |     * @brief Copy constructor
  137|       |     * @param A a reference of an EightPuzzle
  138|       |     */
  139|  1.06k|    EightPuzzle(const EightPuzzle<N> &A) : board(A.board) {}
  ------------------
  | _ZN16machine_learning13aystar_search11EightPuzzleILm3EEC2ERKS2_:
  |  139|    210|    EightPuzzle(const EightPuzzle<N> &A) : board(A.board) {}
  ------------------
  | _ZN16machine_learning13aystar_search11EightPuzzleILm4EEC2ERKS2_:
  |  139|    852|    EightPuzzle(const EightPuzzle<N> &A) : board(A.board) {}
  ------------------
  140|       |
  141|       |    /**
  142|       |     * @brief Move constructor
  143|       |     * @param A a reference of an EightPuzzle
  144|       |     */
  145|       |    EightPuzzle(const EightPuzzle<N> &&A) noexcept
  146|    480|        : board(std::move(A.board)) {}
  ------------------
  | _ZN16machine_learning13aystar_search11EightPuzzleILm3EEC2EOKS2_:
  |  146|    102|        : board(std::move(A.board)) {}
  ------------------
  | _ZN16machine_learning13aystar_search11EightPuzzleILm4EEC2EOKS2_:
  |  146|    378|        : board(std::move(A.board)) {}
  ------------------
  147|       |    /**
  148|       |     * @brief Destructor of EightPuzzle
  149|       |     */
  150|  2.05k|    ~EightPuzzle() = default;
  ------------------
  | _ZN16machine_learning13aystar_search11EightPuzzleILm3EED2Ev:
  |  150|    410|    ~EightPuzzle() = default;
  ------------------
  | _ZN16machine_learning13aystar_search11EightPuzzleILm4EED2Ev:
  |  150|  1.64k|    ~EightPuzzle() = default;
  ------------------
  151|       |
  152|       |    /**
  153|       |     * @brief Copy assignment operator
  154|       |     * @param A a reference of an EightPuzzle
  155|       |     */
  156|       |    EightPuzzle &operator=(const EightPuzzle &A) {
  157|       |        board = A.board;
  158|       |        return *this;
  159|       |    }
  160|       |
  161|       |    /**
  162|       |     * @brief Move assignment operator
  163|       |     * @param A a reference of an EightPuzzle
  164|       |     */
  165|      2|    EightPuzzle &operator=(EightPuzzle &&A) noexcept {
  166|      2|        board = std::move(A.board);
  167|      2|        return *this;
  168|      2|    }
  169|       |
  170|       |    /**
  171|       |     * @brief Find all possible states after processing all possible
  172|       |     * moves, given the current state of the puzzle
  173|       |     * @returns list of vector containing all possible next moves
  174|       |     * @note the implementation is compulsory to create A* search
  175|       |     */
  176|    171|    std::vector<EightPuzzle<N>> generate_possible_moves() {
  177|    171|        auto zero_pos = find_zero();
  178|       |        // vector which will contain all possible state from current state
  179|    171|        std::vector<EightPuzzle<N>> NewStates;
  180|    684|        for (auto &move : moves) {
  181|    684|            if (in_range(zero_pos.first + move.first) &&
  182|    684|                in_range(zero_pos.second + move.second)) {
  183|       |                // swap with the possible moves
  184|    507|                std::array<std::array<uint32_t, N>, N> new_config = board;
  185|    507|                std::swap(new_config[zero_pos.first][zero_pos.second],
  186|    507|                          new_config[zero_pos.first + move.first]
  187|    507|                                    [zero_pos.second + move.second]);
  188|    507|                EightPuzzle<N> new_state(new_config);
  189|       |                // Store new state and calculate heuristic value, and depth
  190|    507|                NewStates.emplace_back(new_state);
  191|    507|            }
  192|    684|        }
  193|    171|        return NewStates;
  194|    171|    }
  ------------------
  | _ZN16machine_learning13aystar_search11EightPuzzleILm3EE23generate_possible_movesEv:
  |  176|     34|    std::vector<EightPuzzle<N>> generate_possible_moves() {
  |  177|     34|        auto zero_pos = find_zero();
  |  178|       |        // vector which will contain all possible state from current state
  |  179|     34|        std::vector<EightPuzzle<N>> NewStates;
  |  180|    136|        for (auto &move : moves) {
  |  181|    136|            if (in_range(zero_pos.first + move.first) &&
  |  182|    136|                in_range(zero_pos.second + move.second)) {
  |  183|       |                // swap with the possible moves
  |  184|     94|                std::array<std::array<uint32_t, N>, N> new_config = board;
  |  185|     94|                std::swap(new_config[zero_pos.first][zero_pos.second],
  |  186|     94|                          new_config[zero_pos.first + move.first]
  |  187|     94|                                    [zero_pos.second + move.second]);
  |  188|     94|                EightPuzzle<N> new_state(new_config);
  |  189|       |                // Store new state and calculate heuristic value, and depth
  |  190|     94|                NewStates.emplace_back(new_state);
  |  191|     94|            }
  |  192|    136|        }
  |  193|     34|        return NewStates;
  |  194|     34|    }
  ------------------
  | _ZN16machine_learning13aystar_search11EightPuzzleILm4EE23generate_possible_movesEv:
  |  176|    137|    std::vector<EightPuzzle<N>> generate_possible_moves() {
  |  177|    137|        auto zero_pos = find_zero();
  |  178|       |        // vector which will contain all possible state from current state
  |  179|    137|        std::vector<EightPuzzle<N>> NewStates;
  |  180|    548|        for (auto &move : moves) {
  |  181|    548|            if (in_range(zero_pos.first + move.first) &&
  |  182|    548|                in_range(zero_pos.second + move.second)) {
  |  183|       |                // swap with the possible moves
  |  184|    413|                std::array<std::array<uint32_t, N>, N> new_config = board;
  |  185|    413|                std::swap(new_config[zero_pos.first][zero_pos.second],
  |  186|    413|                          new_config[zero_pos.first + move.first]
  |  187|    413|                                    [zero_pos.second + move.second]);
  |  188|    413|                EightPuzzle<N> new_state(new_config);
  |  189|       |                // Store new state and calculate heuristic value, and depth
  |  190|    413|                NewStates.emplace_back(new_state);
  |  191|    413|            }
  |  192|    548|        }
  |  193|    137|        return NewStates;
  |  194|    137|    }
  ------------------
  195|       |    /**
  196|       |     * @brief check whether two boards are equal
  197|       |     * @returns `true` if check.state is equal to `this->state`, else
  198|       |     * `false`
  199|       |     */
  200|    174|    bool operator==(const EightPuzzle<N> &check) const {
  201|    174|        if (check.get_size() != N) {
  202|      0|            return false;
  203|      0|        }
  204|    213|        for (size_t i = 0; i < N; ++i) {
  205|    421|            for (size_t j = 0; j < N; ++j) {
  206|    382|                if (board[i][j] != check.board[i][j]) {
  207|    171|                    return false;
  208|    171|                }
  209|    382|            }
  210|    210|        }
  211|      3|        return true;
  212|    174|    }
  ------------------
  | _ZNK16machine_learning13aystar_search11EightPuzzleILm3EEeqERKS2_:
  |  200|     36|    bool operator==(const EightPuzzle<N> &check) const {
  |  201|     36|        if (check.get_size() != N) {
  |  202|      0|            return false;
  |  203|      0|        }
  |  204|     52|        for (size_t i = 0; i < N; ++i) {
  |  205|    100|            for (size_t j = 0; j < N; ++j) {
  |  206|     84|                if (board[i][j] != check.board[i][j]) {
  |  207|     34|                    return false;
  |  208|     34|                }
  |  209|     84|            }
  |  210|     50|        }
  |  211|      2|        return true;
  |  212|     36|    }
  ------------------
  | _ZNK16machine_learning13aystar_search11EightPuzzleILm4EEeqERKS2_:
  |  200|    138|    bool operator==(const EightPuzzle<N> &check) const {
  |  201|    138|        if (check.get_size() != N) {
  |  202|      0|            return false;
  |  203|      0|        }
  |  204|    161|        for (size_t i = 0; i < N; ++i) {
  |  205|    321|            for (size_t j = 0; j < N; ++j) {
  |  206|    298|                if (board[i][j] != check.board[i][j]) {
  |  207|    137|                    return false;
  |  208|    137|                }
  |  209|    298|            }
  |  210|    160|        }
  |  211|      1|        return true;
  |  212|    138|    }
  ------------------
  213|       |    /**
  214|       |     * @brief check whether one board is lexicographically smaller
  215|       |     * @returns `true` if this->state is lexicographically smaller than
  216|       |     * `check.state`, else `false`
  217|       |     */
  218|  20.3k|    bool operator<(const EightPuzzle<N> &check) const {
  219|  39.9k|        for (size_t i = 0; i < N; ++i) {
  220|   138k|            for (size_t j = 0; j < N; ++j) {
  221|   119k|                if (board[i][j] != check.board[i][j]) {
  222|  19.8k|                    return board[i][j] < check.board[i][j];
  223|  19.8k|                }
  224|   119k|            }
  225|  39.5k|        }
  226|    432|        return false;
  227|  20.3k|    }
  ------------------
  | _ZNK16machine_learning13aystar_search11EightPuzzleILm3EEltERKS2_:
  |  218|  2.76k|    bool operator<(const EightPuzzle<N> &check) const {
  |  219|  4.48k|        for (size_t i = 0; i < N; ++i) {
  |  220|  10.8k|            for (size_t j = 0; j < N; ++j) {
  |  221|  9.15k|                if (board[i][j] != check.board[i][j]) {
  |  222|  2.66k|                    return board[i][j] < check.board[i][j];
  |  223|  2.66k|                }
  |  224|  9.15k|            }
  |  225|  4.38k|        }
  |  226|    100|        return false;
  |  227|  2.76k|    }
  ------------------
  | _ZNK16machine_learning13aystar_search11EightPuzzleILm4EEltERKS2_:
  |  218|  17.5k|    bool operator<(const EightPuzzle<N> &check) const {
  |  219|  35.5k|        for (size_t i = 0; i < N; ++i) {
  |  220|   127k|            for (size_t j = 0; j < N; ++j) {
  |  221|   110k|                if (board[i][j] != check.board[i][j]) {
  |  222|  17.2k|                    return board[i][j] < check.board[i][j];
  |  223|  17.2k|                }
  |  224|   110k|            }
  |  225|  35.1k|        }
  |  226|    332|        return false;
  |  227|  17.5k|    }
  ------------------
  228|       |    /**
  229|       |     * @brief check whether one board is lexicographically smaller or equal
  230|       |     * @returns `true` if this->state is lexicographically smaller than
  231|       |     * `check.state` or same, else `false`
  232|       |     */
  233|       |    bool operator<=(const EightPuzzle<N> &check) const {
  234|       |        for (size_t i = 0; i < N; ++i) {
  235|       |            for (size_t j = 0; j < N; ++j) {
  236|       |                if (board[i][j] != check.board[i][j]) {
  237|       |                    return board[i][j] < check.board[i][j];
  238|       |                }
  239|       |            }
  240|       |        }
  241|       |        return true;
  242|       |    }
  243|       |
  244|       |    /**
  245|       |     * @brief friend operator to display EightPuzzle<>
  246|       |     * @param op ostream object
  247|       |     * @param SomeState a certain state.
  248|       |     * @returns ostream operator op
  249|       |     */
  250|       |    friend std::ostream &operator<<(std::ostream &op,
  251|     37|                                    const EightPuzzle<N> &SomeState) {
  252|    172|        for (size_t i = 0; i < N; ++i) {
  253|    636|            for (size_t j = 0; j < N; ++j) {
  254|    501|                op << SomeState.board[i][j] << " ";
  255|    501|            }
  256|    135|            op << "\n";
  257|    135|        }
  258|     37|        return op;
  259|     37|    }
  ------------------
  | _ZN16machine_learning13aystar_searchlsERSoRKNS0_11EightPuzzleILm3EEE:
  |  251|     13|                                    const EightPuzzle<N> &SomeState) {
  |  252|     52|        for (size_t i = 0; i < N; ++i) {
  |  253|    156|            for (size_t j = 0; j < N; ++j) {
  |  254|    117|                op << SomeState.board[i][j] << " ";
  |  255|    117|            }
  |  256|     39|            op << "\n";
  |  257|     39|        }
  |  258|     13|        return op;
  |  259|     13|    }
  ------------------
  | _ZN16machine_learning13aystar_searchlsERSoRKNS0_11EightPuzzleILm4EEE:
  |  251|     24|                                    const EightPuzzle<N> &SomeState) {
  |  252|    120|        for (size_t i = 0; i < N; ++i) {
  |  253|    480|            for (size_t j = 0; j < N; ++j) {
  |  254|    384|                op << SomeState.board[i][j] << " ";
  |  255|    384|            }
  |  256|     96|            op << "\n";
  |  257|     96|        }
  |  258|     24|        return op;
  |  259|     24|    }
  ------------------
  260|       |};
  261|       |/**
  262|       | * @class AyStarSearch
  263|       | * @brief A class defining [A* search
  264|       | * algorithm](https://en.wikipedia.org/wiki/A*_search_algorithm). for some
  265|       | * initial state and final state
  266|       | * @details AyStarSearch class is defined as the informed search algorithm
  267|       | * that is formulated in terms of weighted graphs: starting from a specific
  268|       | * starting node of a graph (initial state), it aims to find a path to the given
  269|       | * goal node having the smallest cost (least distance travelled, shortest time,
  270|       | * etc.)
  271|       | * The weighted edges (or cost) is evaluated on two factors, G score
  272|       | * (cost required from starting node or initial state to current state) and H
  273|       | * score (cost required from current state to final state). The `F(state)`, then
  274|       | * is evaluated as:
  275|       | * `F(state) = G(state) + H(state)`.
  276|       | * The best search would be the final state having minimum `F(state)` value
  277|       | * @tparam Puzzle denotes the puzzle or problem involving initial state and
  278|       | * final state to be solved by A* search.
  279|       | * @note 1. The algorithm is referred from pesudocode from
  280|       | * [Wikipedia page](https://en.wikipedia.org/wiki/A*_search_algorithm)
  281|       | * as is.
  282|       | * 2. For `AyStarSearch` to work, the definitions for template Puzzle is
  283|       | * compulsory.
  284|       | * a. Comparison operator for template Puzzle (`<`, `==`, and `<=`)
  285|       | * b. `generate_possible_moves()`
  286|       | */
  287|       |template <typename Puzzle>
  288|       |class AyStarSearch {
  289|       |    /**
  290|       |     * @brief Struct that handles all the information related to the current
  291|       |     * state.
  292|       |     */
  293|       |    typedef struct Info {
  294|       |        std::shared_ptr<Puzzle> state;  /// Holds the current state.
  295|       |        size_t heuristic_value = 0;     /// stores h score
  296|       |        size_t depth = 0;               /// stores g score
  297|       |
  298|       |        /**
  299|       |         * @brief Default constructor
  300|       |         */
  301|       |        Info() = default;
  302|       |
  303|       |        /**
  304|       |         * @brief constructor having Puzzle as parameter
  305|       |         * @param A a puzzle object
  306|       |         */
  307|      6|        explicit Info(const Puzzle &A) : state(std::make_shared<Puzzle>(A)) {}
  ------------------
  | _ZN16machine_learning13aystar_search12AyStarSearchINS0_11EightPuzzleILm3EEEE4InfoC2ERKS3_:
  |  307|      4|        explicit Info(const Puzzle &A) : state(std::make_shared<Puzzle>(A)) {}
  ------------------
  | _ZN16machine_learning13aystar_search12AyStarSearchINS0_11EightPuzzleILm4EEEE4InfoC2ERKS3_:
  |  307|      2|        explicit Info(const Puzzle &A) : state(std::make_shared<Puzzle>(A)) {}
  ------------------
  308|       |
  309|       |        /**
  310|       |         * @brief constructor having three parameters
  311|       |         * @param A a puzzle object
  312|       |         * @param h_value heuristic value of this puzzle object
  313|       |         * @param depth the depth at which this node was found during traversal
  314|       |         */
  315|       |        Info(const Puzzle &A, size_t h_value, size_t d)
  316|       |            : state(std::make_shared<Puzzle>(A)),
  317|       |              heuristic_value(h_value),
  318|    507|              depth(d) {}
  ------------------
  | _ZN16machine_learning13aystar_search12AyStarSearchINS0_11EightPuzzleILm3EEEE4InfoC2ERKS3_mm:
  |  318|     94|              depth(d) {}
  ------------------
  | _ZN16machine_learning13aystar_search12AyStarSearchINS0_11EightPuzzleILm4EEEE4InfoC2ERKS3_mm:
  |  318|    413|              depth(d) {}
  ------------------
  319|       |
  320|       |        /**
  321|       |         * @brief Copy constructor
  322|       |         * @param A Info object reference
  323|       |         */
  324|       |        Info(const Info &A)
  325|       |            : state(std::make_shared<Puzzle>(A.state)),
  326|       |              heuristic_value(A.heuristic_value),
  327|       |              depth(A.depth) {}
  328|       |
  329|       |        /**
  330|       |         * @brief Move constructor
  331|       |         * @param A Info object reference
  332|       |         */
  333|       |        Info(const Info &&A) noexcept
  334|       |            : state(std::make_shared<Puzzle>(std::move(A.state))),
  335|       |              heuristic_value(std::move(A.heuristic_value)),
  336|       |              depth(std::move(A.depth)) {}
  337|       |
  338|       |        /**
  339|       |         * @brief copy assignment operator
  340|       |         * @param A Info object reference
  341|       |         */
  342|       |        Info &operator=(const Info &A) {
  343|       |            state = A.state;
  344|       |            heuristic_value = A.heuristic_value;
  345|       |            depth = A.depth;
  346|       |            return *this;
  347|       |        }
  348|       |
  349|       |        /**
  350|       |         * @brief move assignment operator
  351|       |         * @param A Info object reference
  352|       |         */
  353|       |        Info &operator=(Info &&A) noexcept {
  354|       |            state = std::move(A.state);
  355|       |            heuristic_value = std::move(A.heuristic_value);
  356|       |            depth = std::move(A.depth);
  357|       |            return *this;
  358|       |        }
  359|       |        /**
  360|       |         * @brief Destructor for Info
  361|       |         */
  362|    513|        ~Info() = default;
  ------------------
  | _ZN16machine_learning13aystar_search12AyStarSearchINS0_11EightPuzzleILm3EEEE4InfoD2Ev:
  |  362|     98|        ~Info() = default;
  ------------------
  | _ZN16machine_learning13aystar_search12AyStarSearchINS0_11EightPuzzleILm4EEEE4InfoD2Ev:
  |  362|    415|        ~Info() = default;
  ------------------
  363|       |    } Info;
  364|       |
  365|       |    std::shared_ptr<Info> Initial;  // Initial state of the AyStarSearch
  366|       |    std::shared_ptr<Info> Final;    // Final state of the AyStarSearch
  367|       |    /**
  368|       |     * @brief Custom comparator for open_list
  369|       |     */
  370|       |    struct comparison_operator {
  371|       |        bool operator()(const std::shared_ptr<Info> &a,
  372|  20.3k|                        const std::shared_ptr<Info> &b) const {
  373|  20.3k|            return *(a->state) < *(b->state);
  374|  20.3k|        }
  ------------------
  | _ZNK16machine_learning13aystar_search12AyStarSearchINS0_11EightPuzzleILm3EEEE19comparison_operatorclERKSt10shared_ptrINS4_4InfoEESA_:
  |  372|  2.76k|                        const std::shared_ptr<Info> &b) const {
  |  373|  2.76k|            return *(a->state) < *(b->state);
  |  374|  2.76k|        }
  ------------------
  | _ZNK16machine_learning13aystar_search12AyStarSearchINS0_11EightPuzzleILm4EEEE19comparison_operatorclERKSt10shared_ptrINS4_4InfoEESA_:
  |  372|  17.5k|                        const std::shared_ptr<Info> &b) const {
  |  373|  17.5k|            return *(a->state) < *(b->state);
  |  374|  17.5k|        }
  ------------------
  375|       |    };
  376|       |
  377|       | public:
  378|       |    using MapOfPuzzleInfoWithPuzzleInfo =
  379|       |        std::map<std::shared_ptr<Info>, std::shared_ptr<Info>,
  380|       |                 comparison_operator>;
  381|       |
  382|       |    using MapOfPuzzleInfoWithInteger =
  383|       |        std::map<std::shared_ptr<Info>, uint32_t, comparison_operator>;
  384|       |
  385|       |    using SetOfPuzzleInfo =
  386|       |        std::set<std::shared_ptr<Info>, comparison_operator>;
  387|       |    /**
  388|       |     * @brief Parameterized constructor for AyStarSearch
  389|       |     * @param initial denoting initial state of the puzzle
  390|       |     * @param final denoting final state of the puzzle
  391|       |     */
  392|      3|    AyStarSearch(const Puzzle &initial, const Puzzle &final) {
  393|      3|        Initial = std::make_shared<Info>(initial);
  394|      3|        Final = std::make_shared<Info>(final);
  395|      3|    }
  ------------------
  | _ZN16machine_learning13aystar_search12AyStarSearchINS0_11EightPuzzleILm3EEEEC2ERKS3_S6_:
  |  392|      2|    AyStarSearch(const Puzzle &initial, const Puzzle &final) {
  |  393|      2|        Initial = std::make_shared<Info>(initial);
  |  394|      2|        Final = std::make_shared<Info>(final);
  |  395|      2|    }
  ------------------
  | _ZN16machine_learning13aystar_search12AyStarSearchINS0_11EightPuzzleILm4EEEEC2ERKS3_S6_:
  |  392|      1|    AyStarSearch(const Puzzle &initial, const Puzzle &final) {
  |  393|      1|        Initial = std::make_shared<Info>(initial);
  |  394|      1|        Final = std::make_shared<Info>(final);
  |  395|      1|    }
  ------------------
  396|       |    /**
  397|       |     * @brief A helper solution: launches when a solution for AyStarSearch
  398|       |     * is found
  399|       |     * @param FinalState the pointer to the obtained final state
  400|       |     * @param parent_of the list of all parents of nodes stored during A*
  401|       |     * search
  402|       |     * @returns the list of moves denoting moves from final state to initial
  403|       |     * state (in reverse)
  404|       |     */
  405|       |    std::vector<Puzzle> Solution(
  406|       |        std::shared_ptr<Info> FinalState,
  407|      3|        const MapOfPuzzleInfoWithPuzzleInfo &parent_of) {
  408|       |        //  Useful for traversing from final state to current state.
  409|      3|        auto current_state = FinalState;
  410|       |        /*
  411|       |         * For storing the solution tree starting from initial state to
  412|       |         * final state
  413|       |         */
  414|      3|        std::vector<Puzzle> answer;
  415|     45|        while (current_state != nullptr) {
  416|     42|            answer.emplace_back(*current_state->state);
  417|     42|            current_state = parent_of.find(current_state)->second;
  418|     42|        }
  419|      3|        return answer;
  420|      3|    }
  ------------------
  | _ZN16machine_learning13aystar_search12AyStarSearchINS0_11EightPuzzleILm3EEEE8SolutionESt10shared_ptrINS4_4InfoEERKSt3mapIS7_S7_NS4_19comparison_operatorESaISt4pairIKS7_S7_EEE:
  |  407|      2|        const MapOfPuzzleInfoWithPuzzleInfo &parent_of) {
  |  408|       |        //  Useful for traversing from final state to current state.
  |  409|      2|        auto current_state = FinalState;
  |  410|       |        /*
  |  411|       |         * For storing the solution tree starting from initial state to
  |  412|       |         * final state
  |  413|       |         */
  |  414|      2|        std::vector<Puzzle> answer;
  |  415|     20|        while (current_state != nullptr) {
  |  416|     18|            answer.emplace_back(*current_state->state);
  |  417|     18|            current_state = parent_of.find(current_state)->second;
  |  418|     18|        }
  |  419|      2|        return answer;
  |  420|      2|    }
  ------------------
  | _ZN16machine_learning13aystar_search12AyStarSearchINS0_11EightPuzzleILm4EEEE8SolutionESt10shared_ptrINS4_4InfoEERKSt3mapIS7_S7_NS4_19comparison_operatorESaISt4pairIKS7_S7_EEE:
  |  407|      1|        const MapOfPuzzleInfoWithPuzzleInfo &parent_of) {
  |  408|       |        //  Useful for traversing from final state to current state.
  |  409|      1|        auto current_state = FinalState;
  |  410|       |        /*
  |  411|       |         * For storing the solution tree starting from initial state to
  |  412|       |         * final state
  |  413|       |         */
  |  414|      1|        std::vector<Puzzle> answer;
  |  415|     25|        while (current_state != nullptr) {
  |  416|     24|            answer.emplace_back(*current_state->state);
  |  417|     24|            current_state = parent_of.find(current_state)->second;
  |  418|     24|        }
  |  419|      1|        return answer;
  |  420|      1|    }
  ------------------
  421|       |    /**
  422|       |     * Main algorithm for finding `FinalState`, given the `InitialState`
  423|       |     * @param dist the heuristic finction, defined by the user
  424|       |     * @param permissible_depth the depth at which the A* search discards
  425|       |     * searching for solution
  426|       |     * @returns List of moves from Final state to initial state, if
  427|       |     * evaluated, else returns an empty array
  428|       |     */
  429|       |    std::vector<Puzzle> a_star_search(
  430|       |        const std::function<uint32_t(const Puzzle &, const Puzzle &)> &dist,
  431|      3|        const uint32_t permissible_depth = 30) {
  432|      3|        MapOfPuzzleInfoWithPuzzleInfo
  433|      3|            parent_of;                       /// Stores the parent of the states
  434|      3|        MapOfPuzzleInfoWithInteger g_score;  /// Stores the g_score
  435|      3|        SetOfPuzzleInfo open_list;           /// Stores the list to explore
  436|      3|        SetOfPuzzleInfo closed_list;  /// Stores the list that are explored
  437|       |
  438|       |        // Before starting the AyStartSearch, initialize the set and maps
  439|      3|        open_list.emplace(Initial);
  440|      3|        parent_of[Initial] = nullptr;
  441|      3|        g_score[Initial] = 0;
  442|       |
  443|    174|        while (!open_list.empty()) {
  444|       |            // Iterator for state having having lowest f_score.
  445|    174|            typename SetOfPuzzleInfo::iterator it_low_f_score;
  446|    174|            uint32_t min_f_score = 1e9;
  447|  10.2k|            for (auto iter = open_list.begin(); iter != open_list.end();
  448|  10.0k|                 ++iter) {
  449|       |                // f score here is evaluated by g score (depth) and h score
  450|       |                // (distance between current state and final state)
  451|  10.0k|                uint32_t f_score = (*iter)->heuristic_value + (*iter)->depth;
  452|  10.0k|                if (f_score < min_f_score) {
  453|    442|                    min_f_score = f_score;
  454|    442|                    it_low_f_score = iter;
  455|    442|                }
  456|  10.0k|            }
  457|       |
  458|       |            // current_state, stores lowest f score so far for this state.
  459|    174|            std::shared_ptr<Info> current_state = *it_low_f_score;
  460|       |
  461|       |            // if this current state is equal to final, return
  462|    174|            if (*(current_state->state) == *(Final->state)) {
  463|      3|                return Solution(current_state, parent_of);
  464|      3|            }
  465|       |            // else remove from open list as visited.
  466|    171|            open_list.erase(it_low_f_score);
  467|       |            // if current_state has exceeded the allowed depth, skip
  468|       |            // neighbor checking
  469|    171|            if (current_state->depth >= permissible_depth) {
  470|      0|                continue;
  471|      0|            }
  472|       |            // Generate all possible moves (neighbors) given the current
  473|       |            // state
  474|    171|            std::vector<Puzzle> total_possible_moves =
  475|    171|                current_state->state->generate_possible_moves();
  476|       |
  477|    507|            for (Puzzle &neighbor : total_possible_moves) {
  478|       |                // calculate score of neighbors with respect to
  479|       |                // current_state
  480|    507|                std::shared_ptr<Info> Neighbor = std::make_shared<Info>(
  481|    507|                    neighbor, dist(neighbor, *(Final->state)),
  482|    507|                    current_state->depth + 1U);
  483|    507|                uint32_t temp_g_score = Neighbor->depth;
  484|       |
  485|       |                // Check whether this state is explored.
  486|       |                // If this state is discovered at greater depth, then discard,
  487|       |                // else remove from closed list and explore the node
  488|    507|                auto closed_list_iter = closed_list.find(Neighbor);
  489|    507|                if (closed_list_iter != closed_list.end()) {
  490|       |                    // 1. If state in closed list has higher depth, then remove
  491|       |                    // from list since we have found better option,
  492|       |                    // 2. Else don't explore this state.
  493|    168|                    if (Neighbor->depth < (*closed_list_iter)->depth) {
  494|      0|                        closed_list.erase(closed_list_iter);
  495|    168|                    } else {
  496|    168|                        continue;
  497|    168|                    }
  498|    168|                }
  499|    339|                auto neighbor_g_score_iter = g_score.find(Neighbor);
  500|       |                // if the neighbor is already created and has minimum
  501|       |                // g_score, then update g_score and f_score else insert new
  502|    339|                if (neighbor_g_score_iter != g_score.end()) {
  503|      2|                    if (neighbor_g_score_iter->second > temp_g_score) {
  504|      2|                        neighbor_g_score_iter->second = temp_g_score;
  505|      2|                        parent_of[Neighbor] = current_state;
  506|      2|                    }
  507|    337|                } else {
  508|    337|                    g_score[Neighbor] = temp_g_score;
  509|    337|                    parent_of[Neighbor] = current_state;
  510|    337|                }
  511|       |                // If this is a new state, insert into open_list
  512|       |                // else update if the this state has better g score than
  513|       |                // existing one.
  514|    339|                auto iter = open_list.find(Neighbor);
  515|    339|                if (iter == open_list.end()) {
  516|    337|                    open_list.emplace(Neighbor);
  517|    337|                } else if ((*iter)->depth > Neighbor->depth) {
  518|      2|                    (*iter)->depth = Neighbor->depth;
  519|      2|                }
  520|    339|            }
  521|    171|            closed_list.emplace(current_state);
  522|    171|        }
  523|       |        // Cannot find the solution, return empty vector
  524|      0|        return std::vector<Puzzle>(0);
  525|      3|    }
  ------------------
  | _ZN16machine_learning13aystar_search12AyStarSearchINS0_11EightPuzzleILm3EEEE13a_star_searchERKSt8functionIFjRKS3_S7_EEj:
  |  431|      2|        const uint32_t permissible_depth = 30) {
  |  432|      2|        MapOfPuzzleInfoWithPuzzleInfo
  |  433|      2|            parent_of;                       /// Stores the parent of the states
  |  434|      2|        MapOfPuzzleInfoWithInteger g_score;  /// Stores the g_score
  |  435|      2|        SetOfPuzzleInfo open_list;           /// Stores the list to explore
  |  436|      2|        SetOfPuzzleInfo closed_list;  /// Stores the list that are explored
  |  437|       |
  |  438|       |        // Before starting the AyStartSearch, initialize the set and maps
  |  439|      2|        open_list.emplace(Initial);
  |  440|      2|        parent_of[Initial] = nullptr;
  |  441|      2|        g_score[Initial] = 0;
  |  442|       |
  |  443|     36|        while (!open_list.empty()) {
  |  444|       |            // Iterator for state having having lowest f_score.
  |  445|     36|            typename SetOfPuzzleInfo::iterator it_low_f_score;
  |  446|     36|            uint32_t min_f_score = 1e9;
  |  447|    488|            for (auto iter = open_list.begin(); iter != open_list.end();
  |  448|    452|                 ++iter) {
  |  449|       |                // f score here is evaluated by g score (depth) and h score
  |  450|       |                // (distance between current state and final state)
  |  451|    452|                uint32_t f_score = (*iter)->heuristic_value + (*iter)->depth;
  |  452|    452|                if (f_score < min_f_score) {
  |  453|     68|                    min_f_score = f_score;
  |  454|     68|                    it_low_f_score = iter;
  |  455|     68|                }
  |  456|    452|            }
  |  457|       |
  |  458|       |            // current_state, stores lowest f score so far for this state.
  |  459|     36|            std::shared_ptr<Info> current_state = *it_low_f_score;
  |  460|       |
  |  461|       |            // if this current state is equal to final, return
  |  462|     36|            if (*(current_state->state) == *(Final->state)) {
  |  463|      2|                return Solution(current_state, parent_of);
  |  464|      2|            }
  |  465|       |            // else remove from open list as visited.
  |  466|     34|            open_list.erase(it_low_f_score);
  |  467|       |            // if current_state has exceeded the allowed depth, skip
  |  468|       |            // neighbor checking
  |  469|     34|            if (current_state->depth >= permissible_depth) {
  |  470|      0|                continue;
  |  471|      0|            }
  |  472|       |            // Generate all possible moves (neighbors) given the current
  |  473|       |            // state
  |  474|     34|            std::vector<Puzzle> total_possible_moves =
  |  475|     34|                current_state->state->generate_possible_moves();
  |  476|       |
  |  477|     94|            for (Puzzle &neighbor : total_possible_moves) {
  |  478|       |                // calculate score of neighbors with respect to
  |  479|       |                // current_state
  |  480|     94|                std::shared_ptr<Info> Neighbor = std::make_shared<Info>(
  |  481|     94|                    neighbor, dist(neighbor, *(Final->state)),
  |  482|     94|                    current_state->depth + 1U);
  |  483|     94|                uint32_t temp_g_score = Neighbor->depth;
  |  484|       |
  |  485|       |                // Check whether this state is explored.
  |  486|       |                // If this state is discovered at greater depth, then discard,
  |  487|       |                // else remove from closed list and explore the node
  |  488|     94|                auto closed_list_iter = closed_list.find(Neighbor);
  |  489|     94|                if (closed_list_iter != closed_list.end()) {
  |  490|       |                    // 1. If state in closed list has higher depth, then remove
  |  491|       |                    // from list since we have found better option,
  |  492|       |                    // 2. Else don't explore this state.
  |  493|     32|                    if (Neighbor->depth < (*closed_list_iter)->depth) {
  |  494|      0|                        closed_list.erase(closed_list_iter);
  |  495|     32|                    } else {
  |  496|     32|                        continue;
  |  497|     32|                    }
  |  498|     32|                }
  |  499|     62|                auto neighbor_g_score_iter = g_score.find(Neighbor);
  |  500|       |                // if the neighbor is already created and has minimum
  |  501|       |                // g_score, then update g_score and f_score else insert new
  |  502|     62|                if (neighbor_g_score_iter != g_score.end()) {
  |  503|      0|                    if (neighbor_g_score_iter->second > temp_g_score) {
  |  504|      0|                        neighbor_g_score_iter->second = temp_g_score;
  |  505|      0|                        parent_of[Neighbor] = current_state;
  |  506|      0|                    }
  |  507|     62|                } else {
  |  508|     62|                    g_score[Neighbor] = temp_g_score;
  |  509|     62|                    parent_of[Neighbor] = current_state;
  |  510|     62|                }
  |  511|       |                // If this is a new state, insert into open_list
  |  512|       |                // else update if the this state has better g score than
  |  513|       |                // existing one.
  |  514|     62|                auto iter = open_list.find(Neighbor);
  |  515|     62|                if (iter == open_list.end()) {
  |  516|     62|                    open_list.emplace(Neighbor);
  |  517|     62|                } else if ((*iter)->depth > Neighbor->depth) {
  |  518|      0|                    (*iter)->depth = Neighbor->depth;
  |  519|      0|                }
  |  520|     62|            }
  |  521|     34|            closed_list.emplace(current_state);
  |  522|     34|        }
  |  523|       |        // Cannot find the solution, return empty vector
  |  524|      0|        return std::vector<Puzzle>(0);
  |  525|      2|    }
  ------------------
  | _ZN16machine_learning13aystar_search12AyStarSearchINS0_11EightPuzzleILm4EEEE13a_star_searchERKSt8functionIFjRKS3_S7_EEj:
  |  431|      1|        const uint32_t permissible_depth = 30) {
  |  432|      1|        MapOfPuzzleInfoWithPuzzleInfo
  |  433|      1|            parent_of;                       /// Stores the parent of the states
  |  434|      1|        MapOfPuzzleInfoWithInteger g_score;  /// Stores the g_score
  |  435|      1|        SetOfPuzzleInfo open_list;           /// Stores the list to explore
  |  436|      1|        SetOfPuzzleInfo closed_list;  /// Stores the list that are explored
  |  437|       |
  |  438|       |        // Before starting the AyStartSearch, initialize the set and maps
  |  439|      1|        open_list.emplace(Initial);
  |  440|      1|        parent_of[Initial] = nullptr;
  |  441|      1|        g_score[Initial] = 0;
  |  442|       |
  |  443|    138|        while (!open_list.empty()) {
  |  444|       |            // Iterator for state having having lowest f_score.
  |  445|    138|            typename SetOfPuzzleInfo::iterator it_low_f_score;
  |  446|    138|            uint32_t min_f_score = 1e9;
  |  447|  9.75k|            for (auto iter = open_list.begin(); iter != open_list.end();
  |  448|  9.61k|                 ++iter) {
  |  449|       |                // f score here is evaluated by g score (depth) and h score
  |  450|       |                // (distance between current state and final state)
  |  451|  9.61k|                uint32_t f_score = (*iter)->heuristic_value + (*iter)->depth;
  |  452|  9.61k|                if (f_score < min_f_score) {
  |  453|    374|                    min_f_score = f_score;
  |  454|    374|                    it_low_f_score = iter;
  |  455|    374|                }
  |  456|  9.61k|            }
  |  457|       |
  |  458|       |            // current_state, stores lowest f score so far for this state.
  |  459|    138|            std::shared_ptr<Info> current_state = *it_low_f_score;
  |  460|       |
  |  461|       |            // if this current state is equal to final, return
  |  462|    138|            if (*(current_state->state) == *(Final->state)) {
  |  463|      1|                return Solution(current_state, parent_of);
  |  464|      1|            }
  |  465|       |            // else remove from open list as visited.
  |  466|    137|            open_list.erase(it_low_f_score);
  |  467|       |            // if current_state has exceeded the allowed depth, skip
  |  468|       |            // neighbor checking
  |  469|    137|            if (current_state->depth >= permissible_depth) {
  |  470|      0|                continue;
  |  471|      0|            }
  |  472|       |            // Generate all possible moves (neighbors) given the current
  |  473|       |            // state
  |  474|    137|            std::vector<Puzzle> total_possible_moves =
  |  475|    137|                current_state->state->generate_possible_moves();
  |  476|       |
  |  477|    413|            for (Puzzle &neighbor : total_possible_moves) {
  |  478|       |                // calculate score of neighbors with respect to
  |  479|       |                // current_state
  |  480|    413|                std::shared_ptr<Info> Neighbor = std::make_shared<Info>(
  |  481|    413|                    neighbor, dist(neighbor, *(Final->state)),
  |  482|    413|                    current_state->depth + 1U);
  |  483|    413|                uint32_t temp_g_score = Neighbor->depth;
  |  484|       |
  |  485|       |                // Check whether this state is explored.
  |  486|       |                // If this state is discovered at greater depth, then discard,
  |  487|       |                // else remove from closed list and explore the node
  |  488|    413|                auto closed_list_iter = closed_list.find(Neighbor);
  |  489|    413|                if (closed_list_iter != closed_list.end()) {
  |  490|       |                    // 1. If state in closed list has higher depth, then remove
  |  491|       |                    // from list since we have found better option,
  |  492|       |                    // 2. Else don't explore this state.
  |  493|    136|                    if (Neighbor->depth < (*closed_list_iter)->depth) {
  |  494|      0|                        closed_list.erase(closed_list_iter);
  |  495|    136|                    } else {
  |  496|    136|                        continue;
  |  497|    136|                    }
  |  498|    136|                }
  |  499|    277|                auto neighbor_g_score_iter = g_score.find(Neighbor);
  |  500|       |                // if the neighbor is already created and has minimum
  |  501|       |                // g_score, then update g_score and f_score else insert new
  |  502|    277|                if (neighbor_g_score_iter != g_score.end()) {
  |  503|      2|                    if (neighbor_g_score_iter->second > temp_g_score) {
  |  504|      2|                        neighbor_g_score_iter->second = temp_g_score;
  |  505|      2|                        parent_of[Neighbor] = current_state;
  |  506|      2|                    }
  |  507|    275|                } else {
  |  508|    275|                    g_score[Neighbor] = temp_g_score;
  |  509|    275|                    parent_of[Neighbor] = current_state;
  |  510|    275|                }
  |  511|       |                // If this is a new state, insert into open_list
  |  512|       |                // else update if the this state has better g score than
  |  513|       |                // existing one.
  |  514|    277|                auto iter = open_list.find(Neighbor);
  |  515|    277|                if (iter == open_list.end()) {
  |  516|    275|                    open_list.emplace(Neighbor);
  |  517|    275|                } else if ((*iter)->depth > Neighbor->depth) {
  |  518|      2|                    (*iter)->depth = Neighbor->depth;
  |  519|      2|                }
  |  520|    277|            }
  |  521|    137|            closed_list.emplace(current_state);
  |  522|    137|        }
  |  523|       |        // Cannot find the solution, return empty vector
  |  524|      0|        return std::vector<Puzzle>(0);
  |  525|      1|    }
  ------------------
  526|       |};
  527|       |}  // namespace aystar_search
  528|       |}  // namespace machine_learning
  529|       |
  530|       |/**
  531|       | * @brief Self test-implementations
  532|       | * @returns void
  533|       | */
  534|      1|static void test() {
  535|       |    // Renaming for simplicity
  536|      1|    using matrix3 = std::array<std::array<uint32_t, 3>, 3>;
  537|      1|    using row3 = std::array<uint32_t, 3>;
  538|      1|    using matrix4 = std::array<std::array<uint32_t, 4>, 4>;
  539|      1|    using row4 = std::array<uint32_t, 4>;
  540|       |    // 1st test: A* search for simple EightPuzzle problem
  541|      1|    matrix3 puzzle;
  542|      1|    puzzle[0] = row3({0, 2, 3});
  543|      1|    puzzle[1] = row3({1, 5, 6});
  544|      1|    puzzle[2] = row3({4, 7, 8});
  545|       |
  546|      1|    matrix3 ideal;
  547|      1|    ideal[0] = row3({1, 2, 3});
  548|      1|    ideal[1] = row3({4, 5, 6});
  549|      1|    ideal[2] = row3({7, 8, 0});
  550|       |
  551|       |    /*
  552|       |     * Heuristic function: Manhattan distance
  553|       |     */
  554|      1|    auto manhattan_distance =
  555|      1|        [](const machine_learning::aystar_search::EightPuzzle<> &first,
  556|     94|           const machine_learning::aystar_search::EightPuzzle<> &second) {
  557|     94|            uint32_t ret = 0;
  558|    376|            for (size_t i = 0; i < first.get_size(); ++i) {
  559|  1.12k|                for (size_t j = 0; j < first.get_size(); ++j) {
  560|    846|                    uint32_t find = first.get(i, j);
  561|    846|                    size_t m = first.get_size(), n = first.get_size();
  562|  1.69k|                    for (size_t k = 0; k < second.get_size(); ++k) {
  563|  5.07k|                        for (size_t l = 0; l < second.get_size(); ++l) {
  564|  4.23k|                            if (find == second.get(k, l)) {
  565|    846|                                std::tie(m, n) = std::make_pair(k, l);
  566|    846|                                break;
  567|    846|                            }
  568|  4.23k|                        }
  569|  1.69k|                        if (m != first.get_size()) {
  570|    846|                            break;
  571|    846|                        }
  572|  1.69k|                    }
  573|    846|                    if (m != first.get_size()) {
  574|    846|                        ret += (std::max(m, i) - std::min(m, i)) +
  575|    846|                               (std::max(n, j) - std::min(n, j));
  576|    846|                    }
  577|    846|                }
  578|    282|            }
  579|     94|            return ret;
  580|     94|        };
  581|       |
  582|      1|    machine_learning::aystar_search::EightPuzzle<> Puzzle(puzzle);
  583|      1|    machine_learning::aystar_search::EightPuzzle<> Ideal(ideal);
  584|      1|    machine_learning::aystar_search::AyStarSearch<
  585|      1|        machine_learning::aystar_search::EightPuzzle<3>>
  586|      1|        search(Puzzle, Ideal);  /// Search object
  587|       |
  588|      1|    std::vector<matrix3> answer;  /// Array that validates the answer
  589|       |
  590|      1|    answer.push_back(
  591|      1|        matrix3({row3({0, 2, 3}), row3({1, 5, 6}), row3({4, 7, 8})}));
  592|      1|    answer.push_back(
  593|      1|        matrix3({row3({1, 2, 3}), row3({0, 5, 6}), row3({4, 7, 8})}));
  594|      1|    answer.push_back(
  595|      1|        matrix3({row3({1, 2, 3}), row3({4, 5, 6}), row3({0, 7, 8})}));
  596|      1|    answer.push_back(
  597|      1|        matrix3({row3({1, 2, 3}), row3({4, 5, 6}), row3({7, 0, 8})}));
  598|      1|    answer.push_back(
  599|      1|        matrix3({row3({1, 2, 3}), row3({4, 5, 6}), row3({7, 8, 0})}));
  600|       |
  601|      1|    auto Solution = search.a_star_search(manhattan_distance);
  602|      1|    std::cout << Solution.size() << std::endl;
  603|       |
  604|      1|    assert(Solution.size() == answer.size());
  605|       |
  606|      0|    uint32_t i = 0;
  607|      6|    for (auto it = Solution.rbegin(); it != Solution.rend(); ++it) {
  608|      5|        assert(it->get_state() == answer[i]);
  609|      0|        ++i;
  610|      5|    }
  611|       |
  612|       |    // 2nd test: A* search for complicated EightPuzzle problem
  613|       |    // Initial state
  614|      1|    puzzle[0] = row3({5, 7, 3});
  615|      1|    puzzle[1] = row3({2, 0, 6});
  616|      1|    puzzle[2] = row3({1, 4, 8});
  617|       |    // Final state
  618|      1|    ideal[0] = row3({1, 2, 3});
  619|      1|    ideal[1] = row3({4, 5, 6});
  620|      1|    ideal[2] = row3({7, 8, 0});
  621|       |
  622|      1|    Puzzle = machine_learning::aystar_search::EightPuzzle<>(puzzle);
  623|      1|    Ideal = machine_learning::aystar_search::EightPuzzle<>(ideal);
  624|       |
  625|       |    // Initialize the search object
  626|      1|    search = machine_learning::aystar_search::AyStarSearch<
  627|      1|        machine_learning::aystar_search::EightPuzzle<3>>(Puzzle, Ideal);
  628|       |
  629|      1|    Solution = search.a_star_search(manhattan_distance);
  630|      1|    std::cout << Solution.size() << std::endl;
  631|       |    // Static assertion due to large solution
  632|      1|    assert(13 == Solution.size());
  633|       |    // Check whether the final state is equal to expected one
  634|      0|    assert(Solution[0].get_state() == ideal);
  635|     14|    for (auto it = Solution.rbegin(); it != Solution.rend(); ++it) {
  636|     13|        std::cout << *it << std::endl;
  637|     13|    }
  638|       |
  639|       |    // 3rd test: A* search for 15-Puzzle
  640|       |    // Initial State of the puzzle
  641|      1|    matrix4 puzzle2;
  642|      1|    puzzle2[0] = row4({10, 1, 6, 2});
  643|      1|    puzzle2[1] = row4({5, 8, 4, 3});
  644|      1|    puzzle2[2] = row4({13, 0, 7, 11});
  645|      1|    puzzle2[3] = row4({14, 9, 15, 12});
  646|       |    // Final state of the puzzle
  647|      1|    matrix4 ideal2;
  648|      1|    ideal2[0] = row4({1, 2, 3, 4});
  649|      1|    ideal2[1] = row4({5, 6, 7, 8});
  650|      1|    ideal2[2] = row4({9, 10, 11, 12});
  651|      1|    ideal2[3] = row4({13, 14, 15, 0});
  652|       |
  653|       |    // Instantiate states for a*, initial state and final states
  654|      1|    machine_learning::aystar_search::EightPuzzle<4> Puzzle2(puzzle2),
  655|      1|        Ideal2(ideal2);
  656|       |    // Initialize the search object
  657|      1|    machine_learning::aystar_search::AyStarSearch<
  658|      1|        machine_learning::aystar_search::EightPuzzle<4>>
  659|      1|        search2(Puzzle2, Ideal2);
  660|       |    /**
  661|       |     * Heuristic function: Manhattan distance
  662|       |     */
  663|      1|    auto manhattan_distance2 =
  664|      1|        [](const machine_learning::aystar_search::EightPuzzle<4> &first,
  665|    413|           const machine_learning::aystar_search::EightPuzzle<4> &second) {
  666|    413|            uint32_t ret = 0;
  667|  2.06k|            for (size_t i = 0; i < first.get_size(); ++i) {
  668|  8.26k|                for (size_t j = 0; j < first.get_size(); ++j) {
  669|  6.60k|                    uint32_t find = first.get(i, j);
  670|  6.60k|                    size_t m = first.get_size(), n = first.get_size();
  671|  16.5k|                    for (size_t k = 0; k < second.get_size(); ++k) {
  672|  66.0k|                        for (size_t l = 0; l < second.get_size(); ++l) {
  673|  56.1k|                            if (find == second.get(k, l)) {
  674|  6.60k|                                std::tie(m, n) = std::make_pair(k, l);
  675|  6.60k|                                break;
  676|  6.60k|                            }
  677|  56.1k|                        }
  678|  16.5k|                        if (m != first.get_size()) {
  679|  6.60k|                            break;
  680|  6.60k|                        }
  681|  16.5k|                    }
  682|  6.60k|                    if (m != first.get_size()) {
  683|  6.60k|                        ret += (std::max(m, i) - std::min(m, i)) +
  684|  6.60k|                               (std::max(n, j) - std::min(n, j));
  685|  6.60k|                    }
  686|  6.60k|                }
  687|  1.65k|            }
  688|    413|            return ret;
  689|    413|        };
  690|       |
  691|      1|    auto sol2 = search2.a_star_search(manhattan_distance2);
  692|      1|    std::cout << sol2.size() << std::endl;
  693|       |
  694|       |    // Static assertion due to large solution
  695|      1|    assert(24 == sol2.size());
  696|       |    // Check whether the final state is equal to expected one
  697|      0|    assert(sol2[0].get_state() == ideal2);
  698|       |
  699|     25|    for (auto it = sol2.rbegin(); it != sol2.rend(); ++it) {
  700|     24|        std::cout << *it << std::endl;
  701|     24|    }
  702|      1|}
  703|       |/**
  704|       | * @brief Main function
  705|       | * @returns 0 on exit
  706|       | */
  707|      1|int main() {
  708|      1|    test();  // run self-test implementations
  709|      1|    return 0;
  710|      1|}

