    1|       |/**
    2|       | * @file
    3|       | * @brief Implementation for a [Circular Linked
    4|       | * List](https://www.geeksforgeeks.org/circular-linked-list/).
    5|       | * @details A Circular Linked List is a variation on the regular linked list, in
    6|       | * which the last node has a pointer to the first node, which creates a full
    7|       | * circle. Consequently, this allows any node to be used as the starting point
    8|       | * for the list.
    9|       | * @author [Alvin](https://github.com/polarvoid)
   10|       | */
   11|       |
   12|       |#include <cassert>   /// for assert
   13|       |#include <iostream>  /// for IO operations
   14|       |#include <vector>    /// for std::vector
   15|       |
   16|       |/**
   17|       | * @namespace operations_on_datastructures
   18|       | * @brief Operations on Data Structures
   19|       | */
   20|       |namespace operations_on_datastructures {
   21|       |
   22|       |/**
   23|       | * @namespace circular_linked_list
   24|       | * @brief Functions for the [Circular Linked
   25|       | * List](https://www.geeksforgeeks.org/circular-linked-list/) implementation
   26|       | */
   27|       |namespace circular_linked_list {
   28|       |
   29|       |/**
   30|       | * @brief A Node struct that represents a single Node in a Binary Tree
   31|       | */
   32|       |struct Node {
   33|       |    int64_t data;  ///< The value of the Node
   34|       |    Node* next;    ///< The Node's successor
   35|       |    /**
   36|       |     * @brief Creates a new Node with some initial data
   37|       |     * @param _data Value of Node
   38|       |     */
   39|      1|    explicit Node(int64_t _data) {
   40|      1|        data = _data;    ///< Set value of Node data
   41|      1|        next = nullptr;  ///< Initialize successor
   42|      1|    }
   43|       |    /**
   44|       |     * @brief Creates a new Node with initial data and a successor
   45|       |     * @param _data Value of Node
   46|       |     * @param _next Pointer to the next Node
   47|       |     */
   48|     11|    explicit Node(int64_t _data, Node* _next) {
   49|     11|        data = _data;  ///< Set value of Node data
   50|     11|        next = _next;  ///< Initialize successor
   51|     11|    }
   52|       |};
   53|       |
   54|       |/**
   55|       | * @brief A class that implements a Circular Linked List.
   56|       | */
   57|       |class CircularLinkedList {
   58|       | private:
   59|       |    Node* root;   ///< Pointer to the root Node
   60|       |    Node* end{};  ///< Pointer to the last Node
   61|       |
   62|       | public:
   63|       |    /**
   64|       |     * @brief Creates an empty CircularLinkedList.
   65|       |     */
   66|      5|    CircularLinkedList() {
   67|      5|        root = nullptr;
   68|      5|        end = nullptr;
   69|      5|    }
   70|       |    /**
   71|       |     * @brief Copy constructor for CircularLinkedList.
   72|       |     */
   73|      0|    CircularLinkedList(const CircularLinkedList& copy) {
   74|      0|        erase();
   75|      0|        root = nullptr;
   76|      0|        Node* node = copy.root;
   77|      0|        while (node != nullptr) {
   78|      0|            insert(node->data);
   79|      0|            node = node->next;
   80|      0|        }
   81|      0|    }
   82|       |    /**
   83|       |     * @brief Move constructor for CircularLinkedList
   84|       |     * @param source rvalue reference to a Circular Linked List
   85|       |     */
   86|      0|    CircularLinkedList(CircularLinkedList&& source) noexcept {
   87|      0|        root = source.root;
   88|      0|        end = source.end;
   89|      0|        source.root = nullptr;
   90|      0|        source.end = nullptr;
   91|      0|    }
   92|       |    /**
   93|       |     * @brief Copy assignment operator
   94|       |     * @param other Reference to a Circular Linked List
   95|       |     * @returns Reference to CircularLinkedList
   96|       |     */
   97|      0|    CircularLinkedList& operator=(const CircularLinkedList& other) {
   98|      0|        erase();
   99|      0|        root = nullptr;
  100|      0|        Node* node = other.root;
  101|      0|        while (node != nullptr) {
  102|      0|            insert(node->data);
  103|      0|            node = node->next;
  104|      0|        }
  105|      0|        return *this;
  106|      0|    }
  107|       |    /**
  108|       |     * @brief Move assignment operator
  109|       |     * @param other rvalue reference to a Circular Linked List
  110|       |     * @returns Reference to CircularLinkedList
  111|       |     */
  112|      0|    CircularLinkedList& operator=(CircularLinkedList&& other) noexcept {
  113|      0|        root = other.root;
  114|      0|        end = other.end;
  115|      0|        other.root = nullptr;
  116|      0|        other.end = nullptr;
  117|      0|        return *this;
  118|      0|    }
  119|       |    /**
  120|       |     * @brief Cleans up memory when destroyed
  121|       |     */
  122|      5|    ~CircularLinkedList() { erase(); }
  123|       |    /**
  124|       |     * Iteratively frees each node in the Circular Linked List from the heap
  125|       |     */
  126|      5|    void erase() {
  127|      5|        if (root == nullptr) {
  128|      1|            return;
  129|      1|        }
  130|      4|        Node* node = root;
  131|     12|        do {
  132|     12|            Node* temp = node;
  133|     12|            node = node->next;
  134|     12|            delete (temp);
  135|     12|        } while (node != root);
  136|      4|        root = nullptr;
  137|      4|        end = nullptr;
  138|      4|    }
  139|       |    /**
  140|       |     * @brief Inserts all the values from a vector into the Circular Linked List
  141|       |     * @details Goes through each element in the vector sequentially, inserting
  142|       |     * it into the list
  143|       |     * @param values The vector of integer values that is to be inserted
  144|       |     * @returns void
  145|       |     */
  146|      1|    void insert(const std::vector<int64_t>& values) {
  147|      6|        for (int64_t value : values) {
  148|      6|            insert(value);
  149|      6|        }
  150|      1|    }
  151|       |    /**
  152|       |     * @brief Inserts a single value into the Circular Linked List
  153|       |     * @details Creates a Node with the given value, pointing to the root Node
  154|       |     * and inserts it into the list
  155|       |     * @param data The integer valus to be inserted
  156|       |     * @returns void
  157|       |     */
  158|     11|    void insert(int64_t data) {
  159|     11|        Node* node = new Node(data, root);
  160|     11|        insert(node);
  161|     11|    }
  162|       |    /**
  163|       |     * @brief Inserts a given Node into the Circular Linked List
  164|       |     * @details Checks wheter the list is empty, and inserts the Node, modifying
  165|       |     * the end pointer
  166|       |     * @param node The Node that is to be inserted
  167|       |     * @returns void
  168|       |     */
  169|     12|    void insert(Node* node) {
  170|     12|        if (root == nullptr) {
  171|      4|            root = node;        ///< Set node as the root
  172|      4|            node->next = root;  ///< Point node to itself
  173|      4|            end = root;         ///< Set the end to the root
  174|      8|        } else {
  175|      8|            end->next = node;   ///< Append node to the end
  176|      8|            node->next = root;  ///< Set the next value to the root
  177|      8|            end = node;         ///< Make end point to node
  178|      8|        }
  179|     12|    }
  180|       |    /**
  181|       |     * @brief Prints the values of the Circular Linked List, beginning from the
  182|       |     * root Node
  183|       |     * @details Goes through each Node from the root and prints them out in
  184|       |     * order
  185|       |     * @returns void
  186|       |     */
  187|      4|    void print() { print(root); }
  188|       |    /**
  189|       |     * @brief Prints the values of the Circular Linked List, beginning from a
  190|       |     * given Node to be used as the root
  191|       |     * @details Goes through each Node from the given Node and prints them out
  192|       |     * in order. If the list is empty, it prints the message 'Empty List!'
  193|       |     * @param root The Node to start at
  194|       |     * @returns void
  195|       |     */
  196|      5|    void print(Node* root) {
  197|      5|        Node* temp = root;
  198|      5|        if (root == nullptr) {
  199|      1|            std::cout << "Empty List!\n";
  200|      1|            return;
  201|      1|        }
  202|     12|        do {
  203|     12|            std::cout << temp->data << " ";
  204|     12|            temp = temp->next;
  205|     12|        } while (temp != root);
  206|      4|        std::cout << "\n";
  207|      4|    }
  208|       |    /**
  209|       |     * @brief Returns a std::vector of the values of the Circular Linked List
  210|       |     * @details Starting from the root Node, appends each value of the list to a
  211|       |     * std::vector and returns it
  212|       |     * @returns A std::vector of the list's values
  213|       |     */
  214|      4|    std::vector<int64_t> values() { return values(root); }
  215|       |    /**
  216|       |     * @brief Returns a std::vector of the values of the Circular Linked List,
  217|       |     * beginning from a given Node
  218|       |     * @details Starting from a given Node, appends each value of the list to a
  219|       |     * std::vector and returns it
  220|       |     * @param root The Node to start at
  221|       |     * @returns A std::vector of the list's values
  222|       |     */
  223|      5|    std::vector<int64_t> values(Node* root) {
  224|      5|        std::vector<int64_t> res;
  225|      5|        if (root == nullptr) {
  226|      1|            return res;  ///< Return empty vector
  227|      1|        }
  228|      4|        Node* temp = root;
  229|     12|        do {
  230|     12|            res.push_back(temp->data);
  231|     12|            temp = temp->next;
  232|     12|        } while (temp != root);
  233|      4|        return res;
  234|      5|    }
  235|       |};
  236|       |
  237|       |}  // namespace circular_linked_list
  238|       |
  239|       |}  // namespace operations_on_datastructures
  240|       |
  241|       |/**
  242|       | * @namespace tests
  243|       | * @brief Testcases to check Circular Linked List.
  244|       | */
  245|       |namespace tests {
  246|       |using operations_on_datastructures::circular_linked_list::CircularLinkedList;
  247|       |using operations_on_datastructures::circular_linked_list::Node;
  248|       |/**
  249|       | * @brief A Test to check a single value
  250|       | * @returns void
  251|       | */
  252|      1|void test1() {
  253|      1|    std::cout << "TEST CASE 1\n";
  254|      1|    std::cout << "Intialized a = {2}\n";
  255|      1|    std::cout << "Expected result: {2}\n";
  256|      1|    CircularLinkedList a;
  257|      1|    std::vector<int64_t> res = {2};
  258|      1|    a.insert(2);
  259|      1|    assert(a.values() == res);
  260|      0|    a.print();
  261|      1|    std::cout << "TEST PASSED!\n\n";
  262|      1|}
  263|       |/**
  264|       | * @brief A Test to check a few values
  265|       | * @returns void
  266|       | */
  267|      1|void test2() {
  268|      1|    std::cout << "TEST CASE 2\n";
  269|      1|    std::cout << "Intialized a = {2, 5, 6}\n";
  270|      1|    std::cout << "Expected result: {2, 5, 6}\n";
  271|      1|    CircularLinkedList a;
  272|      1|    std::vector<int64_t> res = {2, 5, 6};
  273|      1|    a.insert(2);
  274|      1|    a.insert(5);
  275|      1|    a.insert(6);
  276|      1|    assert(a.values() == res);
  277|      0|    a.print();
  278|      1|    std::cout << "TEST PASSED!\n\n";
  279|      1|}
  280|       |/**
  281|       | * @brief A Test to check an input array
  282|       | * @returns void
  283|       | */
  284|      1|void test3() {
  285|      1|    std::cout << "TEST CASE 3\n";
  286|      1|    std::cout << "Intialized a = {2, 7, 8, 3, 2, 6}\n";
  287|      1|    std::cout << "Expected result: {2, 7, 8, 3, 2, 6}\n";
  288|      1|    CircularLinkedList a;
  289|      1|    std::vector<int64_t> res = {2, 7, 8, 3, 2, 6};
  290|      1|    a.insert({2, 7, 8, 3, 2, 6});
  291|      1|    a.print();
  292|      1|    assert(a.values() == res);
  293|      0|    std::cout << "TEST PASSED!\n\n";
  294|      1|}
  295|       |/**
  296|       | * @brief A Test to check using a specific Node as the starting point
  297|       | * @returns void
  298|       | */
  299|      1|void test4() {
  300|      1|    std::cout << "TEST CASE 4\n";
  301|      1|    std::cout << "Intialized a = {2, 5}\n";
  302|      1|    std::cout << "Expected result: {5, 2}\n";
  303|      1|    CircularLinkedList a;
  304|      1|    std::vector<int64_t> res = {5, 2};
  305|      1|    a.insert(2);
  306|      1|    Node* start = new Node(5);  ///< Node we will start printing from
  307|      1|    a.insert(start);
  308|      1|    assert(a.values(start) == res);
  309|      0|    a.print(start);
  310|      1|    std::cout << "TEST PASSED!\n\n";
  311|      1|}
  312|       |
  313|       |/**
  314|       | * @brief A Test to check an empty list
  315|       | * @returns void
  316|       | */
  317|      1|void test5() {
  318|      1|    std::cout << "TEST CASE 5\n";
  319|      1|    std::cout << "Intialized a = {}\n";
  320|      1|    std::cout << "Expected result: Empty List!\n";
  321|      1|    CircularLinkedList a;
  322|      1|    std::vector<int64_t> res = {};
  323|      1|    assert(a.values() == res);
  324|      0|    a.print();
  325|      1|    std::cout << "TEST PASSED!\n\n";
  326|      1|}
  327|       |}  // namespace tests
  328|       |
  329|       |/**
  330|       | * @brief Function to test the correctness of the Circular Linked List
  331|       | * @returns void
  332|       | */
  333|      1|static void test() {
  334|      1|    tests::test1();
  335|      1|    tests::test2();
  336|      1|    tests::test3();
  337|      1|    tests::test4();
  338|      1|    tests::test5();
  339|      1|}
  340|       |
  341|       |/**
  342|       | * @brief main function
  343|       | * @returns 0 on exit
  344|       | */
  345|      1|int main() {
  346|      1|    test();  // run self-test implementations
  347|      1|    return 0;
  348|      1|}

