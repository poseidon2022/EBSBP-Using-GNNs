    1|       |/**
    2|       | * @file
    3|       | * @brief Implementation for the [Union of two sorted
    4|       | * Arrays](https://en.wikipedia.org/wiki/Union_(set_theory))
    5|       | * algorithm.
    6|       | * @details The Union of two arrays is the collection of all the unique elements
    7|       | * in the first array, combined with all of the unique elements of a second
    8|       | * array. This implementation uses ordered arrays, and an algorithm to correctly
    9|       | * order them and return the result as a new array (vector).
   10|       | * @see intersection_of_two_arrays.cpp
   11|       | * @author [Alvin](https://github.com/polarvoid)
   12|       | */
   13|       |
   14|       |#include <algorithm>  /// for std::sort
   15|       |#include <cassert>    /// for assert
   16|       |#include <iostream>   /// for IO operations
   17|       |#include <vector>     /// for std::vector
   18|       |
   19|       |/**
   20|       | * @namespace operations_on_datastructures
   21|       | * @brief Operations on Data Structures
   22|       | */
   23|       |namespace operations_on_datastructures {
   24|       |
   25|       |/**
   26|       | * @brief Prints the values of a vector sequentially, ending with a newline
   27|       | * character.
   28|       | * @param array Reference to the array to be printed
   29|       | * @returns void
   30|       | */
   31|      6|void print(const std::vector<int32_t> &array) {
   32|     29|    for (int32_t i : array) {
   33|     29|        std::cout << i << " ";  /// Print each value in the array
   34|     29|    }
   35|      6|    std::cout << "\n";  /// Print newline
   36|      6|}
   37|       |
   38|       |/**
   39|       | * @brief Gets the union of two sorted arrays, and returns them in a
   40|       | * vector.
   41|       | * @details An algorithm is used that compares the elements of the two vectors,
   42|       | * appending the one that has a lower value, and incrementing the index for that
   43|       | * array. If one of the arrays reaches its end, all the elements of the other
   44|       | * are appended to the resultant vector.
   45|       | * @param first A std::vector of sorted integer values
   46|       | * @param second A std::vector of sorted integer values
   47|       | * @returns A std::vector of the union of the two arrays, in ascending order
   48|       | */
   49|       |std::vector<int32_t> get_union(const std::vector<int32_t> &first,
   50|      6|                               const std::vector<int32_t> &second) {
   51|      6|    std::vector<int32_t> res;         ///< Vector to hold the union
   52|      6|    size_t f_index = 0;               ///< Index for the first array
   53|      6|    size_t s_index = 0;               ///< Index for the second array
   54|      6|    size_t f_length = first.size();   ///< Length of first array
   55|      6|    size_t s_length = second.size();  ///< Length of second array
   56|      6|    int32_t next = 0;  ///< Integer to store value of the next element
   57|       |
   58|     28|    while (f_index < f_length && s_index < s_length) {
   59|     22|        if (first[f_index] < second[s_index]) {
   60|     10|            next = first[f_index];  ///< Append from first array
   61|     10|            f_index++;              ///< Increment index of second array
   62|     12|        } else if (first[f_index] > second[s_index]) {
   63|     10|            next = second[s_index];  ///< Append from second array
   64|     10|            s_index++;               ///< Increment index of second array
   65|     10|        } else {
   66|      2|            next = first[f_index];  ///< Element is the same in both
   67|      2|            f_index++;              ///< Increment index of first array
   68|      2|            s_index++;              ///< Increment index of second array too
   69|      2|        }
   70|     22|        if ((res.size() == 0) || (next != res.back())) {
   71|     19|            res.push_back(next);  ///< Add the element if it is unique
   72|     19|        }
   73|     22|    }
   74|     14|    while (f_index < f_length) {
   75|      8|        next = first[f_index];  ///< Add remaining elements
   76|      8|        if ((res.size() == 0) || (next != res.back())) {
   77|      7|            res.push_back(next);  ///< Add the element if it is unique
   78|      7|        }
   79|      8|        f_index++;
   80|      8|    }
   81|      9|    while (s_index < s_length) {
   82|      3|        next = second[s_index];  ///< Add remaining elements
   83|      3|        if ((res.size() == 0) || (next != res.back())) {
   84|      3|            res.push_back(next);  ///< Add the element if it is unique
   85|      3|        }
   86|      3|        s_index++;
   87|      3|    }
   88|      6|    return res;
   89|      6|}
   90|       |
   91|       |}  // namespace operations_on_datastructures
   92|       |
   93|       |/**
   94|       | * @namespace tests
   95|       | * @brief Testcases to check Union of Two Arrays.
   96|       | */
   97|       |namespace tests {
   98|       |using operations_on_datastructures::get_union;
   99|       |using operations_on_datastructures::print;
  100|       |/**
  101|       | * @brief A Test to check an edge case (two empty arrays)
  102|       | * @returns void
  103|       | */
  104|      1|void test1() {
  105|      1|    std::cout << "TEST CASE 1\n";
  106|      1|    std::cout << "Intialized a = {} b = {}\n";
  107|      1|    std::cout << "Expected result: {}\n";
  108|      1|    std::vector<int32_t> a = {};
  109|      1|    std::vector<int32_t> b = {};
  110|      1|    std::vector<int32_t> result = get_union(a, b);
  111|      1|    assert(result == a);  ///< Check if result is empty
  112|      0|    print(result);        ///< Should only print newline
  113|      1|    std::cout << "TEST PASSED!\n\n";
  114|      1|}
  115|       |/**
  116|       | * @brief A Test to check an edge case (one empty array)
  117|       | * @returns void
  118|       | */
  119|      1|void test2() {
  120|      1|    std::cout << "TEST CASE 2\n";
  121|      1|    std::cout << "Intialized a = {} b = {2, 3}\n";
  122|      1|    std::cout << "Expected result: {2, 3}\n";
  123|      1|    std::vector<int32_t> a = {};
  124|      1|    std::vector<int32_t> b = {2, 3};
  125|      1|    std::vector<int32_t> result = get_union(a, b);
  126|      1|    assert(result == b);  ///< Check if result is equal to b
  127|      0|    print(result);        ///< Should print 2 3
  128|      1|    std::cout << "TEST PASSED!\n\n";
  129|      1|}
  130|       |/**
  131|       | * @brief A Test to check correct functionality with a simple test case
  132|       | * @returns void
  133|       | */
  134|      1|void test3() {
  135|      1|    std::cout << "TEST CASE 3\n";
  136|      1|    std::cout << "Intialized a = {4, 6} b = {2, 3}\n";
  137|      1|    std::cout << "Expected result: {2, 3, 4, 6}\n";
  138|      1|    std::vector<int32_t> a = {4, 6};
  139|      1|    std::vector<int32_t> b = {2, 3};
  140|      1|    std::vector<int32_t> result = get_union(a, b);
  141|      1|    std::vector<int32_t> expected = {2, 3, 4, 6};
  142|      1|    assert(result == expected);  ///< Check if result is correct
  143|      0|    print(result);               ///< Should print 2 3 4 6
  144|      1|    std::cout << "TEST PASSED!\n\n";
  145|      1|}
  146|       |/**
  147|       | * @brief A Test to check correct functionality with duplicate values
  148|       | * @returns void
  149|       | */
  150|      1|void test4() {
  151|      1|    std::cout << "TEST CASE 4\n";
  152|      1|    std::cout << "Intialized a = {4, 6, 6, 7} b = {2, 3, 4}\n";
  153|      1|    std::cout << "Expected result: {2, 3, 4, 6, 7}\n";
  154|      1|    std::vector<int32_t> a = {4, 6, 6, 7};
  155|      1|    std::vector<int32_t> b = {2, 3, 4};
  156|      1|    std::vector<int32_t> result = get_union(a, b);
  157|      1|    std::vector<int32_t> expected = {2, 3, 4, 6, 7};
  158|      1|    assert(result == expected);  ///< Check if result is correct
  159|      0|    print(result);               ///< Should print 2 3 4 6 7
  160|      1|    std::cout << "TEST PASSED!\n\n";
  161|      1|}
  162|       |/**
  163|       | * @brief A Test to check correct functionality with a harder test case
  164|       | * @returns void
  165|       | */
  166|      1|void test5() {
  167|      1|    std::cout << "TEST CASE 5\n";
  168|      1|    std::cout << "Intialized a = {1, 4, 6, 7, 9} b = {2, 3, 5}\n";
  169|      1|    std::cout << "Expected result: {1, 2, 3, 4, 5, 6, 7, 9}\n";
  170|      1|    std::vector<int32_t> a = {1, 4, 6, 7, 9};
  171|      1|    std::vector<int32_t> b = {2, 3, 5};
  172|      1|    std::vector<int32_t> result = get_union(a, b);
  173|      1|    std::vector<int32_t> expected = {1, 2, 3, 4, 5, 6, 7, 9};
  174|      1|    assert(result == expected);  ///< Check if result is correct
  175|      0|    print(result);               ///< Should print 1 2 3 4 5 6 7 9
  176|      1|    std::cout << "TEST PASSED!\n\n";
  177|      1|}
  178|       |/**
  179|       | * @brief A Test to check correct functionality with an array sorted using
  180|       | * std::sort
  181|       | * @returns void
  182|       | */
  183|      1|void test6() {
  184|      1|    std::cout << "TEST CASE 6\n";
  185|      1|    std::cout << "Intialized a = {1, 3, 3, 2, 5, 9, 4, 3, 2} ";
  186|      1|    std::cout << "b = {11, 3, 7, 8, 6}\n";
  187|      1|    std::cout << "Expected result: {1, 2, 3, 4, 5, 6, 7, 8, 9, 11}\n";
  188|      1|    std::vector<int32_t> a = {1, 3, 3, 2, 5, 9, 4, 3, 2};
  189|      1|    std::vector<int32_t> b = {11, 3, 7, 8, 6};
  190|      1|    std::sort(a.begin(), a.end());  ///< Sort vector a
  191|      1|    std::sort(b.begin(), b.end());  ///< Sort vector b
  192|      1|    std::vector<int32_t> result = get_union(a, b);
  193|      1|    std::vector<int32_t> expected = {1, 2, 3, 4, 5, 6, 7, 8, 9, 11};
  194|      1|    assert(result == expected);  ///< Check if result is correct
  195|      0|    print(result);               ///< Should print 1 2 3 4 5 6 7 8 9 11
  196|      1|    std::cout << "TEST PASSED!\n\n";
  197|      1|}
  198|       |}  // namespace tests
  199|       |
  200|       |/**
  201|       | * @brief Function to test the correctness of get_union() function
  202|       | * @returns void
  203|       | */
  204|      1|static void test() {
  205|      1|    tests::test1();
  206|      1|    tests::test2();
  207|      1|    tests::test3();
  208|      1|    tests::test4();
  209|      1|    tests::test5();
  210|      1|    tests::test6();
  211|      1|}
  212|       |
  213|       |/**
  214|       | * @brief main function
  215|       | * @returns 0 on exit
  216|       | */
  217|      1|int main() {
  218|      1|    test();  // run self-test implementations
  219|      1|    return 0;
  220|      1|}

