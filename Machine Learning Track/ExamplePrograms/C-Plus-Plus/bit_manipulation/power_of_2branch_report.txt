    1|       |/**
    2|       | * @file
    3|       | * @brief [Find whether a given number is power of 2]
    4|       | * (https://www.geeksforgeeks.org/program-to-find-whether-a-given-number-is-power-of-2/)
    5|       | * implementation
    6|       | *
    7|       | * @details
    8|       | * We are given a positive integer number. We need to check whether the number
    9|       | * is power of 2 or not.
   10|       | *
   11|       | * A binary number consists of two digits. They are 0 & 1. Digit 1 is known as
   12|       | * set bit in computer terms.
   13|       | * Worst Case Time Complexity: O(1)
   14|       | * Space complexity: O(1)
   15|       | * @author [Prafful Gupta](https://github.com/EcstaticPG-25811)
   16|       | */
   17|       |
   18|       |#include <cassert>   /// for assert
   19|       |#include <cstdint>
   20|       |#include <iostream>  /// for IO operations
   21|       |
   22|       |/**
   23|       | * @namespace bit_manipulation
   24|       | * @brief Bit manipulation algorithms
   25|       | */
   26|       |namespace bit_manipulation {
   27|       |/**
   28|       | * @brief The main function implements check for power of 2
   29|       | * @param n is the number who will be checked
   30|       | * @returns either true or false
   31|       | */
   32|      8|bool isPowerOfTwo(std ::int64_t n) {  // int64_t is preferred over int so that
   33|       |                                      // no Overflow can be there.
   34|       |
   35|      8|    return n > 0 && !(n & n - 1);  // If we subtract a power of 2 numbers by 1
   36|       |    // then all unset bits after the only set bit become set; and the set bit
   37|       |    // becomes unset.
   38|       |
   39|       |    // If a number n is a power of 2 then bitwise and of n-1 and n will be zero.
   40|       |    // The expression n&(n-1) will not work when n is 0.
   41|       |    // To handle this case also, our expression will become n& (!n&(n-1))
   42|      8|}
   43|       |}  // namespace bit_manipulation
   44|       |
   45|       |/**
   46|       | * @brief Self-test implementations
   47|       | * @returns void
   48|       | */
   49|      1|static void test() {
   50|       |    // n = 4 return true
   51|      1|    assert(bit_manipulation::isPowerOfTwo(4) == true);
   52|       |    // n = 6 return false
   53|      0|    assert(bit_manipulation::isPowerOfTwo(6) == false);
   54|       |    // n = 13 return false
   55|      0|    assert(bit_manipulation::isPowerOfTwo(13) == false);
   56|       |    // n = 64 return true
   57|      0|    assert(bit_manipulation::isPowerOfTwo(64) == true);
   58|       |    // n = 15 return false
   59|      0|    assert(bit_manipulation::isPowerOfTwo(15) == false);
   60|       |    // n = 32 return true
   61|      0|    assert(bit_manipulation::isPowerOfTwo(32) == true);
   62|       |    // n = 97 return false
   63|      0|    assert(bit_manipulation::isPowerOfTwo(97) == false);
   64|       |    // n = 1024 return true
   65|      0|    assert(bit_manipulation::isPowerOfTwo(1024) == true);
   66|      0|    std::cout << "All test cases successfully passed!" << std::endl;
   67|      1|}
   68|       |/**
   69|       | * @brief Main function
   70|       | * @returns 0 on exit
   71|       | */
   72|      1|int main() {
   73|      1|    test();  // run self-test implementations
   74|      1|    return 0;
   75|      1|}

