    1|       |/**
    2|       | * @file
    3|       | * @brief Implementation to find the non repeating integer
    4|       | * in an array of repeating integers. [Single
    5|       | * Number](https://leetcode.com/problems/single-number/)
    6|       | *
    7|       | * @details
    8|       | * Given an array of integers in which all of the numbers occur exactly
    9|       | * twice except one integer which occurs only once. Find the non-repeating
   10|       | * integer.
   11|       | *
   12|       | * Worst Case Time Complexity: O(n)
   13|       | * Space complexity: O(1)
   14|       |
   15|       | * @author [Ravidev Pandey](https://github.com/literalEval)
   16|       | */
   17|       |
   18|       |#include <cassert>   /// for assert
   19|       |#include <iostream>  /// for IO operations
   20|       |#include <vector>    /// storing the numbers
   21|       |
   22|       |/**
   23|       | * @namespace bit_manipulation
   24|       | * @brief Bit manipulation algorithms
   25|       | */
   26|       |namespace bit_manipulation {
   27|       |/**
   28|       | * @namespace find_non_repeating_integer
   29|       | * @brief Functions to find the non repeating integer
   30|       | * in an array of repeating integers. [Single
   31|       | * Number](https://leetcode.com/problems/single-number/)
   32|       | */
   33|       |namespace find_non_repeating_integer {
   34|       |/**
   35|       | * @brief The main function implements find single number
   36|       | * @param nums vector of integers
   37|       | * @returns returns the integer that occurs only once
   38|       | */
   39|      3|int64_t find_non_repeating_integer(const std::vector<int>& nums) {
   40|       |    // The idea is based on the property of XOR.
   41|       |    // We know that 'a' XOR 'a' is '0' and '0' XOR 'b'
   42|       |    // is b.
   43|       |    // Using this, if we XOR all the elements of the array,
   44|       |    // the repeating elements will give '0' and this '0'
   45|       |    // with the single number will give the number itself.
   46|       |
   47|      3|    int _xor = 0;
   48|       |
   49|     17|    for (const int& num: nums) {
   50|     17|        _xor ^= num;
   51|     17|    }
   52|       |
   53|      3|    return _xor;
   54|      3|}
   55|       |}  // namespace find_non_repeating_integer
   56|       |}  // namespace bit_manipulation
   57|       |
   58|       |/**
   59|       | * @brief Self-test implementations
   60|       | * @returns void
   61|       | */
   62|      1|static void test() {
   63|       |    // n = 10,2 return 14
   64|       |
   65|      1|    std::vector<int> nums_one{1, 1, 2, 2, 4, 5, 5};
   66|      1|    std::vector<int> nums_two{203, 3434, 4545, 3434, 4545};
   67|      1|    std::vector<int> nums_three{90, 1, 3, 90, 3};
   68|       |
   69|      1|    assert(bit_manipulation::find_non_repeating_integer::
   70|      1|               find_non_repeating_integer(nums_one) ==
   71|      1|           4);  // 4 is non repeating
   72|      0|    assert(bit_manipulation::find_non_repeating_integer::
   73|      1|               find_non_repeating_integer(nums_two) ==
   74|      1|           203);  // 203 is non repeating
   75|      0|    assert(bit_manipulation::find_non_repeating_integer::
   76|      1|               find_non_repeating_integer(nums_three) ==
   77|      1|           1);  // 1 is non repeating
   78|       |
   79|      0|    std::cout << "All test cases successfully passed!" << std::endl;
   80|      1|}
   81|       |/**
   82|       | * @brief Main function
   83|       | * @returns 0 on exit
   84|       | */
   85|      1|int main() {
   86|      1|    test();  // run self-test implementations
   87|      1|    return 0;
   88|      1|}

