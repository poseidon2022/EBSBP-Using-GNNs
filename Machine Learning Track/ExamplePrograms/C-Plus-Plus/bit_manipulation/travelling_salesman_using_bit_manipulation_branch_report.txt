    1|       |/**
    2|       | * @file
    3|       | * @brief Implementation to
    4|       | * [Travelling Salesman problem using bit-masking]
    5|       | * (https://www.geeksforgeeks.org/travelling-salesman-problem-set-1/)
    6|       | *
    7|       | * @details
    8|       | * Given the distance/cost(as and adjacency matrix) between each city/node to
    9|       | * the other city/node , the problem is to find the shortest possible route that
   10|       | * visits every city exactly once and returns to the starting point or we can
   11|       | * say the minimum cost of whole tour.
   12|       | *
   13|       | * Explanation:
   14|       | *  INPUT -> You are given with a adjacency matrix A = {} which contains the
   15|       | * distance between two cities/node.
   16|       | *
   17|       | *  OUTPUT ->  Minimum cost of whole tour from starting point
   18|       | *
   19|       | * Worst Case Time Complexity: O(n^2 * 2^n)
   20|       | * Space complexity: O(n)
   21|       | * @author [Utkarsh Yadav](https://github.com/Rytnix)
   22|       | */
   23|       |#include <algorithm>  /// for std::min
   24|       |#include <cassert>    /// for assert
   25|       |#include <cstdint>
   26|       |#include <iostream>   /// for IO operations
   27|       |#include <limits>     /// for limits of integral types
   28|       |#include <vector>     /// for std::vector
   29|       |
   30|       |/**
   31|       | * @namespace bit_manipulation
   32|       | * @brief Bit manipulation algorithms
   33|       | */
   34|       |namespace bit_manipulation {
   35|       |/**
   36|       | * @namespace travellingSalesman_bitmanipulation
   37|       | * @brief Functions for the [Travelling Salesman
   38|       | * Bitmask](https://www.geeksforgeeks.org/travelling-salesman-problem-set-1/)
   39|       | * implementation
   40|       | */
   41|       |namespace travelling_salesman_using_bit_manipulation {
   42|       |/**
   43|       | * @brief The function implements travellingSalesman using bitmanipulation
   44|       | * @param dist is the cost to reach between two cities/nodes
   45|       | * @param setOfCitites represents the city in bit form.\
   46|       | * @param city is taken to track the current city movement.
   47|       | * @param n is the no of citys .
   48|       | * @param dp vector is used to keep a record of state to avoid the
   49|       | * recomputation.
   50|       | * @returns minimum cost of traversing whole nodes/cities from starting point
   51|       | * back to starting point
   52|       | */
   53|       |std::uint64_t travelling_salesman_using_bit_manipulation(
   54|       |    std::vector<std::vector<uint32_t>>
   55|       |        dist,  // dist is the adjacency matrix containing the distance.
   56|       |               // setOfCities as a bit represent the cities/nodes. Ex: if
   57|       |               // setOfCities = 2 => 0010(in binary) means representing the
   58|       |               // city/node B if city/nodes are represented as D->C->B->A.
   59|       |    std::uint64_t setOfCities,
   60|       |    std::uint64_t city,  // city is taken to track our current city/node
   61|       |                         // movement,where we are currently.
   62|       |    std::uint64_t n,     // n is the no of cities we have.
   63|       |    std::vector<std::vector<uint32_t>>
   64|       |        &dp)  // dp is taken to memorize the state to avoid recomputition
   65|     48|{
   66|       |    // base case;
   67|     48|    if (setOfCities == (1 << n) - 1) {  // we have covered all the cities
   68|     18|        return dist[city][0];  // return the cost from the current city to the
   69|       |                               // original city.
   70|     18|    }
   71|       |
   72|     30|    if (dp[setOfCities][city] != -1) {
   73|      0|        return dp[setOfCities][city];
   74|      0|    }
   75|       |    // otherwise try all possible options
   76|     30|    uint64_t ans = 2147483647;
   77|    150|    for (int choice = 0; choice < n; choice++) {
   78|       |        // check if the city is visited or not.
   79|    120|        if ((setOfCities & (1 << choice)) ==
   80|    120|            0) {  // this means that this perticular city is not visited.
   81|     45|            std::uint64_t subProb =
   82|     45|                dist[city][choice] +
   83|     45|                travelling_salesman_using_bit_manipulation(
   84|     45|                    dist, setOfCities | (1 << choice), choice, n, dp);
   85|       |            // Here we are doing a recursive call to tsp with the updated set of
   86|       |            // city/node and choice which tells that where we are currently.
   87|     45|            ans = std::min(ans, subProb);
   88|     45|        }
   89|    120|    }
   90|     30|    dp[setOfCities][city] = ans;
   91|     30|    return ans;
   92|     30|}
   93|       |}  // namespace travelling_salesman_using_bit_manipulation
   94|       |}  // namespace bit_manipulation
   95|       |
   96|       |/**
   97|       | * @brief Self-test implementations
   98|       | * @returns void
   99|       | */
  100|      1|static void test() {
  101|       |    // 1st test-case
  102|      1|    std::vector<std::vector<uint32_t>> dist = {
  103|      1|        {0, 20, 42, 35}, {20, 0, 30, 34}, {42, 30, 0, 12}, {35, 34, 12, 0}};
  104|      1|    uint32_t V = dist.size();
  105|      1|    std::vector<std::vector<uint32_t>> dp(1 << V, std::vector<uint32_t>(V, -1));
  106|      1|    assert(bit_manipulation::travelling_salesman_using_bit_manipulation::
  107|      1|               travelling_salesman_using_bit_manipulation(dist, 1, 0, V, dp) ==
  108|      1|           97);
  109|      0|    std::cout << "1st test-case: passed!"
  110|      1|              << "\n";
  111|       |
  112|       |    // 2nd test-case
  113|      1|    dist = {{0, 5, 10, 15}, {5, 0, 20, 30}, {10, 20, 0, 35}, {15, 30, 35, 0}};
  114|      1|    V = dist.size();
  115|      1|    std::vector<std::vector<uint32_t>> dp1(1 << V,
  116|      1|                                           std::vector<uint32_t>(V, -1));
  117|      1|    assert(bit_manipulation::travelling_salesman_using_bit_manipulation::
  118|      1|               travelling_salesman_using_bit_manipulation(dist, 1, 0, V, dp1) ==
  119|      1|           75);
  120|      0|    std::cout << "2nd test-case: passed!"
  121|      1|              << "\n";
  122|       |    // 3rd test-case
  123|      1|    dist = {{0, 10, 15, 20}, {10, 0, 35, 25}, {15, 35, 0, 30}, {20, 25, 30, 0}};
  124|      1|    V = dist.size();
  125|      1|    std::vector<std::vector<uint32_t>> dp2(1 << V,
  126|      1|                                           std::vector<uint32_t>(V, -1));
  127|      1|    assert(bit_manipulation::travelling_salesman_using_bit_manipulation::
  128|      1|               travelling_salesman_using_bit_manipulation(dist, 1, 0, V, dp2) ==
  129|      1|           80);
  130|       |
  131|      0|    std::cout << "3rd test-case: passed!"
  132|      1|              << "\n";
  133|      1|}
  134|       |
  135|       |/**
  136|       | * @brief Main function
  137|       | * @returns 0 on exit
  138|       | */
  139|      1|int main() {
  140|      1|    test();  // run self-test implementations
  141|      1|    return 0;
  142|      1|}

