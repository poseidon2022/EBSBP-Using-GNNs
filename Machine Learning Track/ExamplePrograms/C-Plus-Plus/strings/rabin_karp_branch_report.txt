    1|       |/**
    2|       | * \file
    3|       | * \brief The [Rabin-Karp
    4|       | * Algorithm](https://en.wikipedia.org/wiki/Rabinâ€“Karp_algorithm) for finding a
    5|       | * pattern within a piece of text with complexity O(n + m)
    6|       | */
    7|       |#include <cassert>
    8|       |#include <cmath>
    9|       |#include <iostream>
   10|       |#ifdef _MSC_VER
   11|       |#include <string>  // use this for MS Visucal C++
   12|       |#else
   13|       |#include <cstring>
   14|       |#endif
   15|       |
   16|     72|#define PRIME 5  ///< Prime modulus for hash functions
   17|       |
   18|       |namespace string_search {
   19|       |/**
   20|       | * convert a string to an intger - called as hashing function
   21|       | * \param[in] s source of string to hash
   22|       | * \param[in] n length of substring to hash
   23|       | * \returns hash integer
   24|       | */
   25|      8|int64_t create_hash(const std::string& s, int n) {
   26|      8|    int64_t result = 0;
   27|     44|    for (int i = 0; i < n; ++i) {
   28|     36|        result += (int64_t)(s[i] * (int64_t)pow(PRIME, i));
   29|     36|    }
   30|      8|    return result;
   31|      8|}
   32|       |
   33|       |/**
   34|       | * re-hash a string using known existing hash
   35|       | * \param[in] s source of string to hash
   36|       | * \param[in] old_index previous index of string
   37|       | * \param[in] new_index new index of string
   38|       | * \param[in] old_hash previous hash of substring
   39|       | * \param[in] patLength length of substring to hash
   40|       | * \returns new hash integer
   41|       | */
   42|       |int64_t recalculate_hash(const std::string& s, int old_index, int new_index,
   43|     18|                         int64_t old_hash, int patLength) {
   44|     18|    int64_t new_hash = old_hash - s[old_index];
   45|     18|    new_hash /= PRIME;
   46|     18|    new_hash += (int64_t)(s[new_index] * (int64_t)pow(PRIME, patLength - 1));
   47|     18|    return new_hash;
   48|     18|}
   49|       |
   50|       |/**
   51|       | * compare if two sub-strings are equal
   52|       | * \param[in] str1 string pattern to search
   53|       | * \param[in] str2 text in which to search
   54|       | * \param[in] start1,end1 start and end indices for substring in str1
   55|       | * \param[in] start2,end2 start and end indices for substring in str2
   56|       | * \returns `true` if pattern was found
   57|       | * \returns `false` if pattern was not found
   58|       | * @note can this be replaced by std::string::compare?
   59|       | */
   60|       |bool check_if_equal(const std::string& str1, const std::string& str2,
   61|      3|                    int start1, int end1, int start2, int end2) {
   62|      3|    if (end1 - start1 != end2 - start2) {
   63|      0|        return false;
   64|      0|    }
   65|     16|    while (start1 <= end1 && start2 <= end2) {
   66|     13|        if (str1[start1] != str2[start2]) {
   67|      0|            return false;
   68|      0|        }
   69|     13|        start1++;
   70|     13|        start2++;
   71|     13|    }
   72|      3|    return true;
   73|      3|}
   74|       |
   75|       |/**
   76|       | *  Perform string pattern search using Rabin-Karp algorithm
   77|       | *  @param[in] str string to search in
   78|       | *  @param[in] pat pattern to search for
   79|       | *  @return index of first occurrence of pattern
   80|       | *  @return -1 if pattern not found
   81|       | */
   82|       |
   83|      4|int rabin_karp(const std::string& str, const std::string& pat) {
   84|      4|    int64_t pat_hash = create_hash(pat, pat.size());
   85|      4|    int64_t str_hash = create_hash(str, pat.size());
   86|     23|    for (int i = 0; i <= str.size() - pat.size(); ++i) {
   87|     22|        if (pat_hash == str_hash &&
   88|     22|            check_if_equal(str, pat, i, i + pat.size() - 1, 0,
   89|      3|                           pat.size() - 1)) {
   90|      3|            return i;
   91|      3|        }
   92|     19|        if (i < str.size() - pat.size()) {
   93|     18|            str_hash =
   94|     18|                recalculate_hash(str, i, i + pat.size(), str_hash, pat.size());
   95|     18|        }
   96|     19|    }
   97|      1|    return -1;  // return -1 if given pattern not found
   98|      4|}
   99|       |
  100|       |}  // namespace string_search
  101|       |
  102|       |using string_search::rabin_karp;
  103|       |
  104|       |/** Main function */
  105|      1|int main(void) {
  106|      1|    assert(rabin_karp("helloWorld", "world") == -1);
  107|      0|    assert(rabin_karp("helloWorld", "World") == 5);
  108|      0|    assert(rabin_karp("this_is_c++", "c++") == 8);
  109|      0|    assert(rabin_karp("happy_coding", "happy") == 0);
  110|      0|    return 0;
  111|      1|}

