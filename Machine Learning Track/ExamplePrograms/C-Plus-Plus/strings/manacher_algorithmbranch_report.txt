    1|       |/**
    2|       | * @file
    3|       | * @brief Implementation of [Manacher's
    4|       | * Algorithm](https://en.wikipedia.org/wiki/Longest_palindromic_substring)
    5|       | * @details
    6|       | * Manacher's Algorithm is used to find the longest palindromic substring within
    7|       | * a string in O(n) time. It exploits the property of a palindrome that its
    8|       | * first half is symmetric to the last half, and thus if the first half is a
    9|       | * palindrome, then last half is also a palindrome.
   10|       | * @author [Riti Kumari](https://github.com/riti2409)
   11|       | */
   12|       |
   13|       |#include <cassert>   /// for assert
   14|       |#include <cstdint>
   15|       |#include <iostream>  /// for IO operations
   16|       |#include <vector>    /// for std::vector STL
   17|       |#ifdef _MSC_VER
   18|       |#include <string>  /// for string (required for MS Visual C++)
   19|       |#else
   20|       |#include <cstring>  /// for string
   21|       |#endif
   22|       |
   23|       |/**
   24|       | * @namespace strings
   25|       | * @brief Algorithms with strings
   26|       | */
   27|       |namespace strings {
   28|       |/**
   29|       | * @namespace manacher
   30|       | * @brief Functions for [Manacher's
   31|       | * Algorithm](https://en.wikipedia.org/wiki/Longest_palindromic_substring)
   32|       | * implementation
   33|       | */
   34|       |namespace manacher {
   35|       |/**
   36|       | * @brief A function that implements Manacher's algorithm
   37|       | * @param prototype is the string where algorithm finds a palindromic substring.
   38|       | * This string can contain any character except `@` `#` `&`
   39|       | * @returns the largest palindromic substring
   40|       | */
   41|     12|std::string manacher(const std::string &prototype) {
   42|     12|    if (prototype.size() > 0) {
   43|       |        // stuffing characters between the input string to handle cases with
   44|       |        // even length palindrome
   45|     11|        std::string stuffed_string = "";
   46|     76|        for (auto str : prototype) {
   47|     76|            stuffed_string += str;
   48|     76|            stuffed_string += "#";
   49|     76|        }
   50|     11|        stuffed_string = "@#" + stuffed_string + "&";
   51|       |
   52|     11|        std::vector<uint64_t> palindrome_max_half_length(
   53|     11|            stuffed_string.size(),
   54|     11|            0);  // this array will consist of largest possible half length of
   55|       |                 // palindrome centered at index (say i with respect to the
   56|       |                 // stuffed string). This value will be lower bound of half
   57|       |                 // length since single character is a palindrome in itself.
   58|       |
   59|     11|        uint64_t bigger_center =
   60|     11|            0;  // this is the index of the center of palindromic
   61|       |                // substring which would be considered as the larger
   62|       |                // palindrome, having symmetric halves
   63|       |
   64|     11|        uint64_t right = 0;  // this is the maximum length of the palindrome
   65|       |                             // from 'bigger_center' to the rightmost end
   66|       |
   67|       |        // i is considered as center lying within one half of the palindrone
   68|       |        // which is centered at 'bigger_center'
   69|    174|        for (uint64_t i = 1; i < stuffed_string.size() - 1; i++) {
   70|    163|            if (i < right) {  // when i is before right end, considering
   71|       |                              // 'bigger_center' as center of palindrome
   72|     44|                uint64_t opposite_to_i =
   73|     44|                    2 * bigger_center -
   74|     44|                    i;  // this is the opposite end of string, if
   75|       |                        // centered at center, and having one end as i
   76|       |
   77|       |                // finding the minimum possible half length among
   78|       |                // the palindrome on having center at opposite end,
   79|       |                // and the string between i and right end,
   80|       |                // considering 'bigger_center' as center of palindrome
   81|     44|                palindrome_max_half_length[i] = std::min(
   82|     44|                    palindrome_max_half_length[opposite_to_i], right - i);
   83|     44|            }
   84|       |
   85|       |            // expanding the palindrome across the maximum stored length in the
   86|       |            // array, centered at i
   87|    264|            while (stuffed_string[i + (palindrome_max_half_length[i] + 1)] ==
   88|    264|                   stuffed_string[i - (palindrome_max_half_length[i] + 1)]) {
   89|    101|                palindrome_max_half_length[i]++;
   90|    101|            }
   91|       |
   92|       |            // if palindrome centered at i exceeds the rightmost end of
   93|       |            // palindrome centered at 'bigger_center', then i will be made the
   94|       |            // 'bigger_center' and right value will also be updated with respect
   95|       |            // to center i
   96|    163|            if (i + palindrome_max_half_length[i] > right) {
   97|     72|                bigger_center = i;
   98|     72|                right = i + palindrome_max_half_length[i];
   99|     72|            }
  100|    163|        }
  101|       |
  102|       |        // now extracting the first largest palindrome
  103|     11|        uint64_t half_length = 0;   // half length of the largest palindrome
  104|     11|        uint64_t center_index = 0;  // index of center of the largest palindrome
  105|       |
  106|    174|        for (uint64_t i = 1; i < stuffed_string.size() - 1; i++) {
  107|    163|            if (palindrome_max_half_length[i] > half_length) {
  108|     23|                half_length = palindrome_max_half_length[i];
  109|     23|                center_index = i;
  110|     23|            }
  111|    163|        }
  112|       |
  113|     11|        std::string palindromic_substring =
  114|     11|            "";  // contains the resulting largest palindrome
  115|       |
  116|     11|        if (half_length > 0) {
  117|       |            // extra information: when '#' is the center, then palindromic
  118|       |            // substring will have even length, else palindromic substring will
  119|       |            // have odd length
  120|       |
  121|     11|            uint64_t start =
  122|     11|                center_index - half_length +
  123|     11|                1;  // index of first character of palindromic substring
  124|     11|            uint64_t end =
  125|     11|                center_index + half_length -
  126|     11|                1;  // index of last character of palindromic substring
  127|     55|            for (uint64_t index = start; index <= end; index += 2) {
  128|     44|                palindromic_substring += stuffed_string[index];
  129|     44|            }
  130|     11|        } else {
  131|       |            // if length = 0, then there does not exist any palindrome of length
  132|       |            // > 1 so we can assign any character of length 1 from string as the
  133|       |            // palindromic substring
  134|      0|            palindromic_substring = prototype[0];
  135|      0|        }
  136|     11|        return palindromic_substring;
  137|       |
  138|     11|    } else {
  139|       |        // handling case when string is empty
  140|      1|        return "";
  141|      1|    }
  142|     12|}
  143|       |
  144|       |}  // namespace manacher
  145|       |}  // namespace strings
  146|       |
  147|       |/**
  148|       | * @brief Self-test implementations
  149|       | * @returns void
  150|       | */
  151|      1|static void test() {
  152|      1|    assert(strings::manacher::manacher("") == "");
  153|      0|    assert(strings::manacher::manacher("abababc") == "ababa");
  154|      0|    assert(strings::manacher::manacher("cbaabd") == "baab");
  155|      0|    assert(strings::manacher::manacher("DedzefDeD") == "DeD");
  156|      0|    assert(strings::manacher::manacher("XZYYXXYZXX") == "YXXY");
  157|      0|    assert(strings::manacher::manacher("1sm222m10abc") == "m222m");
  158|      0|    assert(strings::manacher::manacher("798989591") == "98989");
  159|      0|    assert(strings::manacher::manacher("xacdedcax") == "xacdedcax");
  160|      0|    assert(strings::manacher::manacher("xaccax") == "xaccax");
  161|      0|    assert(strings::manacher::manacher("a") == "a");
  162|      0|    assert(strings::manacher::manacher("xy") == "x");
  163|      0|    assert(strings::manacher::manacher("abced") == "a");
  164|       |
  165|      0|    std::cout << "All tests have passed!" << std::endl;
  166|      1|}
  167|       |
  168|       |/**
  169|       | * @brief Main function
  170|       | * @returns 0 on exit
  171|       | */
  172|      1|int main() {
  173|      1|    test();  // run self-test implementations
  174|      1|    return 0;
  175|      1|}

