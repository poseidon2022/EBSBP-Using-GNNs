    1|       |/**
    2|       | * @file
    3|       | * @brief The [Knuth-Morris-Pratt
    4|       | * Algorithm](https://en.wikipedia.org/wiki/Knuth–Morris–Pratt_algorithm) for
    5|       | * finding a pattern within a piece of text with complexity O(n + m)
    6|       | * @details
    7|       | * 1. Preprocess pattern to identify any suffixes that are identical to
    8|       | * prefixes. This tells us where to continue from if we get a mismatch between a
    9|       | * character in our pattern and the text.
   10|       | * 2. Step through the text one character at a time and compare it to a
   11|       | * character in the pattern updating our location within the pattern if
   12|       | * necessary
   13|       | * @author [Yancey](https://github.com/Yancey2023)
   14|       | */
   15|       |
   16|       |#include <cassert>   /// for assert
   17|       |#include <iostream>  /// for IO operations
   18|       |#include <string>    /// for std::string
   19|       |#include <vector>    /// for std::vector
   20|       |
   21|       |/**
   22|       | * @namespace string_search
   23|       | * @brief String search algorithms
   24|       | */
   25|       |namespace string_search {
   26|       |/**
   27|       | * @brief Generate the partial match table aka failure function for a pattern to
   28|       | * search.
   29|       | * @param pattern text for which to create the partial match table
   30|       | * @returns the partial match table as a vector array
   31|       | */
   32|      5|std::vector<size_t> getFailureArray(const std::string &pattern) {
   33|      5|    size_t pattern_length = pattern.size();
   34|      5|    std::vector<size_t> failure(pattern_length + 1);
   35|      5|    failure[0] = std::string::npos;
   36|      5|    size_t j = std::string::npos;
   37|     31|    for (int i = 0; i < pattern_length; i++) {
   38|     44|        while (j != std::string::npos && pattern[j] != pattern[i]) {
   39|     18|            j = failure[j];
   40|     18|        }
   41|     26|        failure[i + 1] = ++j;
   42|     26|    }
   43|      5|    return failure;
   44|      5|}
   45|       |
   46|       |/**
   47|       | * @brief KMP algorithm to find a pattern in a text
   48|       | * @param pattern string pattern to search
   49|       | * @param text text in which to search
   50|       | * @returns the starting index of the pattern if found
   51|       | * @returns `std::string::npos` if not found
   52|       | */
   53|      6|size_t kmp(const std::string &pattern, const std::string &text) {
   54|      6|    if (pattern.empty()) {
   55|      1|        return 0;
   56|      1|    }
   57|      5|    std::vector<size_t> failure = getFailureArray(pattern);
   58|      5|    size_t text_length = text.size();
   59|      5|    size_t pattern_length = pattern.size();
   60|      5|    size_t k = 0;
   61|     55|    for (size_t j = 0; j < text_length; j++) {
   62|     81|        while (k != std::string::npos && pattern[k] != text[j]) {
   63|     27|            k = failure[k];
   64|     27|        }
   65|     54|        if (++k == pattern_length) {
   66|      4|            return j - k + 1;
   67|      4|        }
   68|     54|    }
   69|      1|    return std::string::npos;
   70|      5|}
   71|       |}  // namespace string_search
   72|       |
   73|       |using string_search::kmp;
   74|       |
   75|       |/**
   76|       | * @brief self-test implementations
   77|       | * @returns void
   78|       | */
   79|      1|static void tests() {
   80|      1|    assert(kmp("abc1abc12l", "alskfjaldsabc1abc1abc12k2") == std::string::npos);
   81|      0|    assert(kmp("bca", "abcabc") == 1);
   82|      0|    assert(kmp("World", "helloWorld") == 5);
   83|      0|    assert(kmp("c++", "his_is_c++") == 7);
   84|      0|    assert(kmp("happy", "happy_coding") == 0);
   85|      0|    assert(kmp("", "pattern is empty") == 0);
   86|       |
   87|       |    // this lets the user know that the tests have passed
   88|      0|    std::cout << "All KMP algorithm tests have successfully passed!\n";
   89|      1|}
   90|       |
   91|       |/*
   92|       | * @brief Main function
   93|       | * @returns 0 on exit
   94|       | */
   95|      1|int main() {
   96|      1|    tests();
   97|      1|    return 0;
   98|      1|}

