    1|       |/**
    2|       | * @file
    3|       | * @brief The [Z function](https://cp-algorithms.com/string/z-function.html) for
    4|       | * finding occurences of a pattern within a piece of text with time and space
    5|       | * complexity O(n + m)
    6|       | * @details
    7|       | * 1. The Z-function for a string is an array of length n where the
    8|       | * i-th element is equal to the greatest number of characters starting
    9|       | * from the position i that coincide with the first characters of s.
   10|       | * 2. E.g.: string: ababb then z[2]=2 as s[2]=s[0] and s[3]=s[1] and s[4]!=s[2]
   11|       | * @author [Ritika Gupta](https://github.com/RitikaGupta8734)
   12|       | */
   13|       |
   14|       |#include <cstdint>
   15|       |#include <iostream>  /// for IO operations
   16|       |#ifdef _MSC_VER
   17|       |#include <string>  /// for string (use this for MS Visual C++)
   18|       |#else
   19|       |#include <cstring>  /// for string
   20|       |#endif
   21|       |#include <cassert>  /// for assert
   22|       |#include <vector>   /// for std::vector
   23|       |
   24|       |/**
   25|       | * @brief Generate the Z-function for the inputted string.
   26|       | * \param[in] pattern text on which to apply the Z-function
   27|       | * \returns the Z-function output as a vector array
   28|       | */
   29|      4|std::vector<uint64_t> Z_function(const std::string &pattern) {
   30|      4|    uint64_t pattern_length = pattern.size();
   31|      4|    std::vector<uint64_t> z(pattern_length, 0);
   32|       |
   33|     66|    for (uint64_t i = 1, l = 0, r = 0; i < pattern_length; i++) {
   34|     62|        if (i <= r) {
   35|     10|            z[i] = std::min(r - i + 1, z[i - l]);
   36|     10|        }
   37|     80|        while (i + z[i] < pattern_length &&
   38|     80|               pattern[z[i]] == pattern[i + z[i]]) {
   39|     18|            z[i]++;
   40|     18|        }
   41|     62|        if (i + z[i] - 1 > r) {
   42|     42|            r = i + z[i] - 1;
   43|     42|        }
   44|     62|    }
   45|      4|    return z;
   46|      4|}
   47|       |
   48|       |/**
   49|       | * @brief Using Z_function to find a pattern in a text
   50|       | * \param[in] pattern string pattern to search
   51|       | * \param[in] text text in which to search
   52|       | * \returns a vector of starting indexes where pattern is found in the text
   53|       | */
   54|       |std::vector<uint64_t> find_pat_in_text(const std::string &pattern,
   55|      4|                                       const std::string &text) {
   56|      4|    uint64_t text_length = text.size(), pattern_length = pattern.size();
   57|      4|    std::vector<uint64_t> z = Z_function(pattern + '#' + text);
   58|      4|    std::vector<uint64_t> matching_indexes;
   59|       |
   60|     57|    for (uint64_t i = 0; i < text_length; i++) {
   61|     53|        if (z[i + pattern_length + 1] == pattern_length) {
   62|     12|            matching_indexes.push_back(i);
   63|     12|        }
   64|     53|    }
   65|      4|    return matching_indexes;
   66|      4|}
   67|       |
   68|       |/**
   69|       | * @brief Self-test implementations
   70|       | * @returns void
   71|       | */
   72|      1|static void test() {
   73|       |    // usual case
   74|      1|    std::string text1 = "alskfjaldsabc1abc1abcbksbcdnsdabcabc";
   75|      1|    std::string pattern1 = "abc";
   76|       |
   77|       |    // matching_indexes1 gets the indexes where pattern1 exists in text1
   78|      1|    std::vector<uint64_t> matching_indexes1 = find_pat_in_text(pattern1, text1);
   79|      1|    assert((matching_indexes1 == std::vector<uint64_t>{10, 14, 18, 30, 33}));
   80|       |
   81|       |    // corner case
   82|      0|    std::string text2 = "greengrass";
   83|      1|    std::string pattern2 = "abc";
   84|       |
   85|       |    // matching_indexes2 gets the indexes where pattern2 exists in text2
   86|      1|    std::vector<uint64_t> matching_indexes2 = find_pat_in_text(pattern2, text2);
   87|      1|    assert((matching_indexes2 == std::vector<uint64_t>{}));
   88|       |
   89|       |    // corner case - empty text
   90|      0|    std::string text3 = "";
   91|      1|    std::string pattern3 = "abc";
   92|       |
   93|       |    // matching_indexes3 gets the indexes where pattern3 exists in text3
   94|      1|    std::vector<uint64_t> matching_indexes3 = find_pat_in_text(pattern3, text3);
   95|      1|    assert((matching_indexes3 == std::vector<uint64_t>{}));
   96|       |
   97|       |    // corner case - empty pattern
   98|      0|    std::string text4 = "redsand";
   99|      1|    std::string pattern4 = "";
  100|       |
  101|       |    // matching_indexes4 gets the indexes where pattern4 exists in text4
  102|      1|    std::vector<uint64_t> matching_indexes4 = find_pat_in_text(pattern4, text4);
  103|      1|    assert((matching_indexes4 == std::vector<uint64_t>{0, 1, 2, 3, 4, 5, 6}));
  104|      1|}
  105|       |
  106|       |/**
  107|       | * @brief Main function
  108|       | * @returns 0 on exit
  109|       | */
  110|      1|int main() {
  111|      1|    test();  // run self-test implementations
  112|      1|    return 0;
  113|      1|}

