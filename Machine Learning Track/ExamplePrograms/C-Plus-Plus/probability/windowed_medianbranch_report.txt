    1|       |/**
    2|       | * @file
    3|       | * @brief An implementation of a median calculation of a sliding window along a
    4|       | * data stream
    5|       | *
    6|       | * @details
    7|       | * Given a stream of integers, the algorithm calculates the median of a fixed
    8|       | * size window at the back of the stream. The leading time complexity of this
    9|       | * algorithm is O(log(N), and it is inspired by the known algorithm to [find
   10|       | * median from (infinite) data
   11|       | * stream](https://www.tutorialcup.com/interview/algorithm/find-median-from-data-stream.htm),
   12|       | * with the proper modifications to account for the finite window size for which
   13|       | * the median is requested
   14|       | *
   15|       | * ### Algorithm
   16|       | * The sliding window is managed by a list, which guarantees O(1) for both
   17|       | * pushing and popping. Each new value is pushed to the window back, while a
   18|       | * value from the front of the window is popped. In addition, the algorithm
   19|       | * manages a multi-value binary search tree (BST), implemented by std::multiset.
   20|       | * For each new value that is inserted into the window, it is also inserted to
   21|       | * the BST. When a value is popped from the window, it is also erased from the
   22|       | * BST. Both insertion and erasion to/from the BST are O(logN) in time, with N
   23|       | * the size of the window. Finally, the algorithm keeps a pointer to the root of
   24|       | * the BST, and updates its position whenever values are inserted or erased
   25|       | * to/from BST. The root of the tree is the median! Hence, median retrieval is
   26|       | * always O(1)
   27|       | *
   28|       | * Time complexity: O(logN). Space complexity: O(N). N - size of window
   29|       | * @author [Yaniv Hollander](https://github.com/YanivHollander)
   30|       | */
   31|       |#include <cassert>  /// for assert
   32|       |#include <cstdlib>  /// for std::rand - needed in testing
   33|       |#include <ctime>    /// for std::time - needed in testing
   34|       |#include <list>     /// for std::list - used to manage sliding window
   35|       |#include <set>  /// for std::multiset - used to manage multi-value sorted sliding window values
   36|       |#include <vector>  /// for std::vector - needed in testing
   37|       |
   38|       |/**
   39|       | * @namespace probability
   40|       | * @brief Probability algorithms
   41|       | */
   42|       |namespace probability {
   43|       |/**
   44|       | * @namespace windowed_median
   45|       | * @brief Functions for the Windowed Median algorithm implementation
   46|       | */
   47|       |namespace windowed_median {
   48|       |using Window = std::list<int>;
   49|       |using size_type = Window::size_type;
   50|       |
   51|       |/**
   52|       | * @class WindowedMedian
   53|       | * @brief A class to calculate the median of a leading sliding window at the
   54|       | * back of a stream of integer values.
   55|       | */
   56|       |class WindowedMedian {
   57|       |    const size_type _windowSize;  ///< sliding window size
   58|       |    Window _window;  ///< a sliding window of values along the stream
   59|       |    std::multiset<int> _sortedValues;  ///< a DS to represent a balanced
   60|       |                                       /// multi-value binary search tree (BST)
   61|       |    std::multiset<int>::const_iterator
   62|       |        _itMedian;  ///< an iterator that points to the root of the multi-value
   63|       |                    /// BST
   64|       |
   65|       |    /**
   66|       |     * @brief Inserts a value to a sorted multi-value BST
   67|       |     * @param value Value to insert
   68|       |     */
   69|  1.00k|    void insertToSorted(int value) {
   70|  1.00k|        _sortedValues.insert(value);  /// Insert value to BST - O(logN)
   71|  1.00k|        const auto sz = _sortedValues.size();
   72|  1.00k|        if (sz == 1) {  /// For the first value, set median iterator to BST root
   73|     99|            _itMedian = _sortedValues.begin();
   74|     99|            return;
   75|     99|        }
   76|       |
   77|       |        /// If new value goes to left tree branch, and number of elements is
   78|       |        /// even, the new median in the balanced tree is the left child of the
   79|       |        /// median before the insertion
   80|    907|        if (value < *_itMedian && sz % 2 == 0) {
   81|    266|            --_itMedian;  // O(1) - traversing one step to the left child
   82|    266|        }
   83|       |
   84|       |        /// However, if the new value goes to the right branch, the previous
   85|       |        /// median's right child is the new median in the balanced tree
   86|    641|        else if (value >= *_itMedian && sz % 2 != 0) {
   87|    228|            ++_itMedian;  /// O(1) - traversing one step to the right child
   88|    228|        }
   89|    907|    }
   90|       |
   91|       |    /**
   92|       |     * @brief Erases a value from a sorted multi-value BST
   93|       |     * @param value Value to insert
   94|       |     */
   95|    558|    void eraseFromSorted(int value) {
   96|    558|        const auto sz = _sortedValues.size();
   97|       |
   98|       |        /// If the erased value is on the left branch or the median itself and
   99|       |        /// the number of elements is even, the new median will be the right
  100|       |        /// child of the current one
  101|    558|        if (value <= *_itMedian && sz % 2 == 0) {
  102|    174|            ++_itMedian;  /// O(1) - traversing one step to the right child
  103|    174|        }
  104|       |
  105|       |        /// However, if the erased value is on the right branch or the median
  106|       |        /// itself, and the number of elements is odd, the new median will be
  107|       |        /// the left child of the current one
  108|    384|        else if (value >= *_itMedian && sz % 2 != 0) {
  109|    127|            --_itMedian;  // O(1) - traversing one step to the left child
  110|    127|        }
  111|       |
  112|       |        /// Find the (first) position of the value we want to erase, and erase
  113|       |        /// it
  114|    558|        const auto it = _sortedValues.find(value);  // O(logN)
  115|    558|        _sortedValues.erase(it);                    // O(logN)
  116|    558|    }
  117|       |
  118|       | public:
  119|       |    /**
  120|       |     * @brief Constructs a WindowedMedian object
  121|       |     * @param windowSize Sliding window size
  122|       |     */
  123|     99|    explicit WindowedMedian(size_type windowSize) : _windowSize(windowSize){};
  124|       |
  125|       |    /**
  126|       |     * @brief Insert a new value to the stream
  127|       |     * @param value New value to insert
  128|       |     */
  129|  1.00k|    void insert(int value) {
  130|       |        /// Push new value to the back of the sliding window - O(1)
  131|  1.00k|        _window.push_back(value);
  132|  1.00k|        insertToSorted(value);  // Insert value to the multi-value BST - O(logN)
  133|  1.00k|        if (_window.size() > _windowSize) {  /// If exceeding size of window,
  134|       |                                             /// pop from its left side
  135|    558|            eraseFromSorted(
  136|    558|                _window.front());  /// Erase from the multi-value BST
  137|       |                                   /// the window left side value
  138|    558|            _window.pop_front();   /// Pop the left side value from the window -
  139|       |                                   /// O(1)
  140|    558|        }
  141|  1.00k|    }
  142|       |
  143|       |    /**
  144|       |     * @brief Gets the median of the values in the sliding window
  145|       |     * @return Median of sliding window. For even window size return the average
  146|       |     * between the two values in the middle
  147|       |     */
  148|  1.00k|    float getMedian() const {
  149|  1.00k|        if (_sortedValues.size() % 2 != 0) {
  150|    595|            return *_itMedian;  // O(1)
  151|    595|        }
  152|    411|        return 0.5f * *_itMedian + 0.5f * *next(_itMedian);  /// O(1)
  153|  1.00k|    }
  154|       |
  155|       |    /**
  156|       |     * @brief A naive and inefficient method to obtain the median of the sliding
  157|       |     * window. Used for testing!
  158|       |     * @return Median of sliding window. For even window size return the average
  159|       |     * between the two values in the middle
  160|       |     */
  161|  1.00k|    float getMedianNaive() const {
  162|  1.00k|        auto window = _window;
  163|  1.00k|        window.sort();  /// Sort window - O(NlogN)
  164|  1.00k|        auto median =
  165|  1.00k|            *next(window.begin(),
  166|  1.00k|                  window.size() / 2);  /// Find value in the middle - O(N)
  167|  1.00k|        if (window.size() % 2 != 0) {
  168|    595|            return median;
  169|    595|        }
  170|    411|        return 0.5f * median +
  171|    411|               0.5f * *next(window.begin(), window.size() / 2 - 1);  /// O(N)
  172|  1.00k|    }
  173|       |};
  174|       |}  // namespace windowed_median
  175|       |}  // namespace probability
  176|       |
  177|       |/**
  178|       | * @brief Self-test implementations
  179|       | * @param vals Stream of values
  180|       | * @param windowSize Size of sliding window
  181|       | */
  182|     99|static void test(const std::vector<int> &vals, int windowSize) {
  183|     99|    probability::windowed_median::WindowedMedian windowedMedian(windowSize);
  184|  1.00k|    for (const auto val : vals) {
  185|  1.00k|        windowedMedian.insert(val);
  186|       |
  187|       |        /// Comparing medians: efficient function vs. Naive one
  188|  1.00k|        assert(windowedMedian.getMedian() == windowedMedian.getMedianNaive());
  189|  1.00k|    }
  190|     99|}
  191|       |
  192|       |/**
  193|       | * @brief Main function
  194|       | * @param argc command line argument count (ignored)
  195|       | * @param argv command line array of arguments (ignored)
  196|       | * @returns 0 on exit
  197|       | */
  198|      1|int main(int argc, const char *argv[]) {
  199|       |    /// A few fixed test cases
  200|      1|    test({1, 2, 3, 4, 5, 6, 7, 8, 9},
  201|      1|         3);  /// Array of sorted values; odd window size
  202|      1|    test({9, 8, 7, 6, 5, 4, 3, 2, 1},
  203|      1|         3);  /// Array of sorted values - decreasing; odd window size
  204|      1|    test({9, 8, 7, 6, 5, 4, 5, 6}, 4);     /// Even window size
  205|      1|    test({3, 3, 3, 3, 3, 3, 3, 3, 3}, 3);  /// Array with repeating values
  206|      1|    test({3, 3, 3, 3, 7, 3, 3, 3, 3}, 3);  /// Array with same values except one
  207|      1|    test({4, 3, 3, -5, -5, 1, 3, 4, 5},
  208|      1|         5);  /// Array that includes repeating values including negatives
  209|       |
  210|       |    /// Array with large values - sum of few pairs exceeds MAX_INT. Window size
  211|       |    /// is even - testing calculation of average median between two middle
  212|       |    /// values
  213|      1|    test({470211272, 101027544, 1457850878, 1458777923, 2007237709, 823564440,
  214|      1|          1115438165, 1784484492, 74243042, 114807987},
  215|      1|         6);
  216|       |
  217|       |    /// Random test cases
  218|      1|    std::srand(static_cast<unsigned int>(std::time(nullptr)));
  219|      1|    std::vector<int> vals;
  220|     93|    for (int i = 8; i < 100; i++) {
  221|     92|        const auto n =
  222|     92|            1 + std::rand() /
  223|     92|                    ((RAND_MAX + 5u) / 20);  /// Array size in the range [5, 20]
  224|     92|        auto windowSize =
  225|     92|            1 + std::rand() / ((RAND_MAX + 3u) /
  226|     92|                               10);  /// Window size in the range [3, 10]
  227|     92|        vals.clear();
  228|     92|        vals.reserve(n);
  229|  1.03k|        for (int i = 0; i < n; i++) {
  230|    943|            vals.push_back(
  231|    943|                rand() - RAND_MAX);  /// Random array values (positive/negative)
  232|    943|        }
  233|     92|        test(vals, windowSize);  /// Testing randomized test
  234|     92|    }
  235|      1|    return 0;
  236|      1|}

