    1|       |/**
    2|       | * @file
    3|       | * @brief Implementation of the [A1Z26
    4|       | * cipher](https://www.dcode.fr/letter-number-cipher)
    5|       | * @details The A1Z26 cipher is a simple substiution cipher where each letter is
    6|       | * replaced by the number of the order they're in. For example, A corresponds to
    7|       | * 1, B = 2, C = 3, etc.
    8|       | *
    9|       | * @author [Focusucof](https://github.com/Focusucof)
   10|       | */
   11|       |
   12|       |#include <algorithm>  /// for std::transform and std::replace
   13|       |#include <cassert>    /// for assert
   14|       |#include <cstdint>    /// for uint8_t
   15|       |#include <iostream>   /// for IO operations
   16|       |#include <map>        /// for std::map
   17|       |#include <sstream>    /// for std::stringstream
   18|       |#include <string>     /// for std::string
   19|       |#include <vector>     /// for std::vector
   20|       |
   21|       |/**
   22|       | * @namespace ciphers
   23|       | * @brief Algorithms for encryption and decryption
   24|       | */
   25|       |namespace ciphers {
   26|       |/**
   27|       | * @namespace a1z26
   28|       | * @brief Functions for [A1Z26](https://www.dcode.fr/letter-number-cipher)
   29|       | * encryption and decryption implementation
   30|       | */
   31|       |namespace a1z26 {
   32|       |
   33|       |std::map<uint8_t, char> a1z26_decrypt_map = {
   34|       |    {1, 'a'},  {2, 'b'},  {3, 'c'},  {4, 'd'},  {5, 'e'},  {6, 'f'},  {7, 'g'},
   35|       |    {8, 'h'},  {9, 'i'},  {10, 'j'}, {11, 'k'}, {12, 'l'}, {13, 'm'}, {14, 'n'},
   36|       |    {15, 'o'}, {16, 'p'}, {17, 'q'}, {18, 'r'}, {19, 's'}, {20, 't'}, {21, 'u'},
   37|       |    {22, 'v'}, {23, 'w'}, {24, 'x'}, {25, 'y'}, {26, 'z'},
   38|       |};
   39|       |
   40|       |std::map<char, uint8_t> a1z26_encrypt_map = {
   41|       |    {'a', 1},  {'b', 2},  {'c', 3},  {'d', 4},  {'e', 5},  {'f', 6},  {'g', 7},
   42|       |    {'h', 8},  {'i', 9},  {'j', 10}, {'k', 11}, {'l', 12}, {'m', 13}, {'n', 14},
   43|       |    {'o', 15}, {'p', 16}, {'q', 17}, {'r', 18}, {'s', 19}, {'t', 20}, {'u', 21},
   44|       |    {'v', 22}, {'w', 23}, {'x', 24}, {'y', 25}, {'z', 26}};
   45|       |
   46|       |/**
   47|       | * @brief a1z26 encryption implementation
   48|       | * @param text is the plaintext input
   49|       | * @returns encoded string with dashes to seperate letters
   50|       | */
   51|      1|std::string encrypt(std::string text) {
   52|      1|    std::string result;
   53|      1|    std::transform(text.begin(), text.end(), text.begin(),
   54|      1|                   ::tolower);  // convert string to lowercase
   55|      1|    std::replace(text.begin(), text.end(), ':', ' ');
   56|     11|    for (char letter : text) {
   57|     11|        if (letter != ' ') {
   58|     10|            result += std::to_string(
   59|     10|                a1z26_encrypt_map[letter]);  // convert int to string and append
   60|       |                                             // to result
   61|     10|            result += "-";  // space out each set of numbers with spaces
   62|     10|        } else {
   63|      1|            result.pop_back();
   64|      1|            result += ' ';
   65|      1|        }
   66|     11|    }
   67|      1|    result.pop_back();  // remove leading dash
   68|      1|    return result;
   69|      1|}
   70|       |
   71|       |/**
   72|       | * @brief a1z26 decryption implementation
   73|       | * @param text is the encrypted text input
   74|       | * @param bReturnUppercase is if the decoded string should be in uppercase or
   75|       | * not
   76|       | * @returns the decrypted string in all uppercase or all lowercase
   77|       | */
   78|      2|std::string decrypt(const std::string& text, bool bReturnUppercase = false) {
   79|      2|    std::string result;
   80|       |
   81|       |    // split words seperated by spaces into a vector array
   82|      2|    std::vector<std::string> word_array;
   83|      2|    std::stringstream sstream(text);
   84|      2|    std::string word;
   85|      4|    while (sstream >> word) {
   86|      2|        word_array.push_back(word);
   87|      2|    }
   88|       |
   89|      2|    for (auto& i : word_array) {
   90|      2|        std::replace(i.begin(), i.end(), '-', ' ');
   91|      2|        std::vector<std::string> text_array;
   92|       |
   93|      2|        std::stringstream ss(i);
   94|      2|        std::string res_text;
   95|     20|        while (ss >> res_text) {
   96|     18|            text_array.push_back(res_text);
   97|     18|        }
   98|       |
   99|     18|        for (auto& i : text_array) {
  100|     18|            result += a1z26_decrypt_map[stoi(i)];
  101|     18|        }
  102|       |
  103|      2|        result += ' ';
  104|      2|    }
  105|      2|    result.pop_back();  // remove any leading whitespace
  106|       |
  107|      2|    if (bReturnUppercase) {
  108|      1|        std::transform(result.begin(), result.end(), result.begin(), ::toupper);
  109|      1|    }
  110|      2|    return result;
  111|      2|}
  112|       |
  113|       |}  // namespace a1z26
  114|       |}  // namespace ciphers
  115|       |
  116|       |/**
  117|       | * @brief Self-test implementations
  118|       | * @returns void
  119|       | */
  120|      1|static void test() {
  121|       |    // 1st test
  122|      1|    std::string input = "Hello World";
  123|      1|    std::string expected = "8-5-12-12-15 23-15-18-12-4";
  124|      1|    std::string output = ciphers::a1z26::encrypt(input);
  125|       |
  126|      1|    std::cout << "Input: " << input << std::endl;
  127|      1|    std::cout << "Expected: " << expected << std::endl;
  128|      1|    std::cout << "Output: " << output << std::endl;
  129|      1|    assert(output == expected);
  130|      0|    std::cout << "TEST PASSED";
  131|       |
  132|       |    // 2nd test
  133|      1|    input = "12-15-23-5-18-3-1-19-5";
  134|      1|    expected = "lowercase";
  135|      1|    output = ciphers::a1z26::decrypt(input);
  136|       |
  137|      1|    std::cout << "Input: " << input << std::endl;
  138|      1|    std::cout << "Expected: " << expected << std::endl;
  139|      1|    std::cout << "Output: " << output << std::endl;
  140|      1|    assert(output == expected);
  141|      0|    std::cout << "TEST PASSED";
  142|       |
  143|       |    // 3rd test
  144|      1|    input = "21-16-16-5-18-3-1-19-5";
  145|      1|    expected = "UPPERCASE";
  146|      1|    output = ciphers::a1z26::decrypt(input, true);
  147|       |
  148|      1|    std::cout << "Input: " << input << std::endl;
  149|      1|    std::cout << "Expected: " << expected << std::endl;
  150|      1|    std::cout << "Output: " << output << std::endl;
  151|      1|    assert(output == expected);
  152|      0|    std::cout << "TEST PASSED";
  153|      1|}
  154|       |
  155|       |/**
  156|       | * @brief Main function
  157|       | * @returns 0 on exit
  158|       | */
  159|      1|int main() {
  160|      1|    test();  // run self-test implementations
  161|      1|    return 0;
  162|      1|}

