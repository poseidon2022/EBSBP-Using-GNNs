/home/kidus/Desktop/GNNs/ExamplePrograms/C-Plus-Plus/ciphers/hill_cipher.cpp:
    1|       |/**
    2|       | * @file hill_cipher.cpp
    3|       | * @brief Implementation of [Hill
    4|       | * cipher](https://en.wikipedia.org/wiki/Hill_cipher) algorithm.
    5|       | *
    6|       | * Program to generate the encryption-decryption key and perform encryption and
    7|       | * decryption of ASCII text using the famous block cipher algorithm. This is a
    8|       | * powerful encryption algorithm that is relatively easy to implement with a
    9|       | * given key. The strength of the algorithm depends on the size of the block
   10|       | * encryption matrix key; the bigger the matrix, the stronger the encryption and
   11|       | * more difficult to break it. However, the important requirement for the matrix
   12|       | * is that:
   13|       | * 1. matrix should be invertible - all inversion conditions should be satisfied
   14|       | * and
   15|       | * 2. its determinant must not have any common factors with the length of
   16|       | * character set
   17|       | * Due to this restriction, most implementations only implement with small 3x3
   18|       | * encryption keys and a small subset of ASCII alphabets.
   19|       | *
   20|       | * In the current implementation, I present to you an implementation for
   21|       | * generating larger encryption keys (I have attempted upto 10x10) and an ASCII
   22|       | * character set of 97 printable characters. Hence, a typical ASCII text file
   23|       | * could be easily encrypted with the module. The larger character set increases
   24|       | * the modulo of cipher and hence the matrix determinants can get very large
   25|       | * very quickly rendering them ill-defined.
   26|       | *
   27|       | * \note This program uses determinant computation using LU decomposition from
   28|       | * the file lu_decomposition.h
   29|       | * \note The matrix generation algorithm is very rudimentary and does not
   30|       | * guarantee an invertible modulus matrix. \todo Better matrix generation
   31|       | * algorithm.
   32|       | *
   33|       | * @author [Krishna Vedala](https://github.com/kvedala)
   34|       | */
   35|       |
   36|       |#include <cassert>
   37|       |#include <cmath>
   38|       |#include <cstdint>
   39|       |#include <cstring>
   40|       |#include <ctime>
   41|       |#include <fstream>
   42|       |#include <iomanip>
   43|       |#include <iostream>
   44|       |#include <string>
   45|       |#ifdef _OPENMP
   46|       |#include <omp.h>
   47|       |#endif
   48|       |
   49|       |#include "../numerical_methods/lu_decomposition.h"
   50|       |
   51|       |/**
   52|       | * operator to print a matrix
   53|       | */
   54|       |template <typename T>
   55|      0|static std::ostream &operator<<(std::ostream &out, matrix<T> const &v) {
   56|      0|    const int width = 15;
   57|      0|    const char separator = ' ';
   58|       |
   59|      0|    for (size_t row = 0; row < v.size(); row++) {
   60|      0|        for (size_t col = 0; col < v[row].size(); col++)
   61|      0|            out << std::left << std::setw(width) << std::setfill(separator)
   62|      0|                << v[row][col];
   63|      0|        out << std::endl;
   64|      0|    }
   65|       |
   66|      0|    return out;
   67|      0|}
   68|       |
   69|       |/** \namespace ciphers
   70|       | * \brief Algorithms for encryption and decryption
   71|       | */
   72|       |namespace ciphers {
   73|       |/** dictionary of characters that can be encrypted and decrypted */
   74|       |static const char *STRKEY =
   75|       |    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789~!@#$%^&"
   76|       |    "*()_+`-=[]{}|;':\",./<>?\\\r\n \0";
   77|       |
   78|       |/**
   79|       | * @brief Implementation of [Hill
   80|       | * Cipher](https://en.wikipedia.org/wiki/Hill_cipher) algorithm
   81|       | */
   82|       |class HillCipher {
   83|       | private:
   84|       |    /**
   85|       |     * @brief Function to generate a random integer in a given interval
   86|       |     *
   87|       |     * @param a lower limit of interval
   88|       |     * @param b upper limit of interval
   89|       |     * @tparam T type of output
   90|       |     * @return random integer in the interval \f$[a,b)\f$
   91|       |     */
   92|       |    template <typename T1, typename T2>
   93|      0|    static const T2 rand_range(T1 a, T1 b) {
   94|       |        // generate random number between 0 and 1
   95|      0|        long double r = static_cast<long double>(std::rand()) / RAND_MAX;
   96|       |
   97|       |        // scale and return random number as integer
   98|      0|        return static_cast<T2>(r * (b - a) + a);
   99|      0|    }
  100|       |
  101|       |    /**
  102|       |     * @brief Function overload to fill a matrix with random integers in a given
  103|       |     * interval
  104|       |     *
  105|       |     * @param M pointer to matrix to be filled with random numbers
  106|       |     * @param a lower limit of interval
  107|       |     * @param b upper limit of interval
  108|       |     * @tparam T1 type of input range
  109|       |     * @tparam T2 type of matrix
  110|       |     * @return determinant of generated random matrix
  111|       |     *
  112|       |     * @warning There will need to be a balance between the matrix size and the
  113|       |     * range of random numbers. If the matrix is large, the range of random
  114|       |     * numbers must be small to have a well defined keys. Or if the matrix is
  115|       |     * smaller, the random numbers range can be larger. For an 8x8 matrix, range
  116|       |     * should be no more than \f$[0,10]\f$
  117|       |     */
  118|       |    template <typename T1, typename T2>
  119|      0|    static double rand_range(matrix<T2> *M, T1 a, T1 b) {
  120|      0|        for (size_t i = 0; i < M->size(); i++) {
  121|      0|            for (size_t j = 0; j < M[0][0].size(); j++) {
  122|      0|                M[0][i][j] = rand_range<T1, T2>(a, b);
  123|      0|            }
  124|      0|        }
  125|       |
  126|      0|        return determinant_lu(*M);
  127|      0|    }
  128|       |
  129|       |    /**
  130|       |     * @brief Compute
  131|       |     * [GCD](https://en.wikipedia.org/wiki/Greatest_common_divisor) of two
  132|       |     * integers using Euler's algorithm
  133|       |     *
  134|       |     * @param a first number
  135|       |     * @param b second number
  136|       |     * @return GCD of \f$a\f$ and \f$b\f$
  137|       |     */
  138|       |    template <typename T>
  139|      0|    static const T gcd(T a, T b) {
  140|      0|        if (b > a)  // ensure always a < b
  141|      0|            std::swap(a, b);
  142|       |
  143|      0|        while (b != 0) {
  144|      0|            T tmp = b;
  145|      0|            b = a % b;
  146|      0|            a = tmp;
  147|      0|        }
  148|       |
  149|      0|        return a;
  150|      0|    }
  151|       |
  152|       |    /**
  153|       |     * @brief helper function to perform vector multiplication with encryption
  154|       |     * or decryption matrix
  155|       |     *
  156|       |     * @param vector vector to multiply
  157|       |     * @param key encryption or decryption key matrix
  158|       |     * @return corresponding encrypted or decrypted text
  159|       |     */
  160|       |    static const std::valarray<uint8_t> mat_mul(
  161|      0|        const std::valarray<uint8_t> &vector, const matrix<int> &key) {
  162|      0|        std::valarray<uint8_t> out(vector);  // make a copy
  163|       |
  164|      0|        size_t L = std::strlen(STRKEY);
  165|       |
  166|      0|        for (size_t i = 0; i < key.size(); i++) {
  167|      0|            int tmp = 0;
  168|      0|            for (size_t j = 0; j < vector.size(); j++) {
  169|      0|                tmp += key[i][j] * vector[j];
  170|      0|            }
  171|      0|            out[i] = static_cast<uint8_t>(tmp % L);
  172|      0|        }
  173|       |
  174|      0|        return out;
  175|      0|    }
  176|       |
  177|       |    /**
  178|       |     * @brief Get the character at a given index in the ::STRKEY
  179|       |     *
  180|       |     * @param idx index value
  181|       |     * @return character at the index
  182|       |     */
  183|      0|    static inline char get_idx_char(const uint8_t idx) { return STRKEY[idx]; }
  184|       |
  185|       |    /**
  186|       |     * @brief Get the index of a character in the ::STRKEY
  187|       |     *
  188|       |     * @param ch character to search
  189|       |     * @return index of character
  190|       |     */
  191|      0|    static inline uint8_t get_char_idx(const char ch) {
  192|      0|        size_t L = std::strlen(STRKEY);
  193|       |
  194|      0|        for (size_t idx = 0; idx <= L; idx++)
  195|      0|            if (STRKEY[idx] == ch)
  196|      0|                return idx;
  197|       |
  198|      0|        std::cerr << __func__ << ":" << __LINE__ << ": (" << ch
  199|      0|                  << ") Should not reach here!\n";
  200|      0|        return 0;
  201|      0|    }
  202|       |
  203|       |    /**
  204|       |     * @brief Convenience function to perform block cipher operations. The
  205|       |     * operations are identical for both encryption and decryption.
  206|       |     *
  207|       |     * @param text input text to encrypt or decrypt
  208|       |     * @param key key for encryption or decryption
  209|       |     * @return encrypted/decrypted output
  210|       |     */
  211|       |    static const std::string codec(const std::string &text,
  212|      0|                                   const matrix<int> &key) {
  213|      0|        size_t text_len = text.length();
  214|      0|        size_t key_len = key.size();
  215|       |
  216|       |        // length of output string must be a multiple of key_len
  217|       |        // create output string and initialize with '\0' character
  218|      0|        size_t L2 = text_len % key_len == 0
  219|      0|                        ? text_len
  220|      0|                        : text_len + key_len - (text_len % key_len);
  221|      0|        std::string coded_text(L2, '\0');
  222|       |
  223|       |        // temporary array for batch processing
  224|      0|        int i;
  225|       |#ifdef _OPENMP
  226|       |#pragma parallel omp for private(i)
  227|       |#endif
  228|      0|        for (i = 0; i < L2 - key_len + 1; i += key_len) {
  229|      0|            std::valarray<uint8_t> batch_int(key_len);
  230|      0|            for (size_t j = 0; j < key_len; j++) {
  231|      0|                batch_int[j] = get_char_idx(text[i + j]);
  232|      0|            }
  233|       |
  234|      0|            batch_int = mat_mul(batch_int, key);
  235|       |
  236|      0|            for (size_t j = 0; j < key_len; j++) {
  237|      0|                coded_text[i + j] =
  238|      0|                    STRKEY[batch_int[j]];  // get character at key
  239|      0|            }
  240|      0|        }
  241|       |
  242|      0|        return coded_text;
  243|      0|    }
  244|       |
  245|       |    /**
  246|       |     * Get matrix inverse using Row-transformations. Given matrix must
  247|       |     * be a square and non-singular.
  248|       |     * \returns inverse matrix
  249|       |     **/
  250|       |    template <typename T>
  251|      0|    static matrix<double> get_inverse(matrix<T> const &A) {
  252|       |        // Assuming A is square matrix
  253|      0|        size_t N = A.size();
  254|       |
  255|      0|        matrix<double> inverse(N, std::valarray<double>(N));
  256|      0|        for (size_t row = 0; row < N; row++) {
  257|      0|            for (size_t col = 0; col < N; col++) {
  258|       |                // create identity matrix
  259|      0|                inverse[row][col] = (row == col) ? 1.f : 0.f;
  260|      0|            }
  261|      0|        }
  262|       |
  263|      0|        if (A.size() != A[0].size()) {
  264|      0|            std::cerr << "A must be a square matrix!" << std::endl;
  265|      0|            return inverse;
  266|      0|        }
  267|       |
  268|       |        // preallocate a temporary matrix identical to A
  269|      0|        matrix<double> temp(N, std::valarray<double>(N));
  270|      0|        for (size_t row = 0; row < N; row++) {
  271|      0|            for (size_t col = 0; col < N; col++)
  272|      0|                temp[row][col] = static_cast<double>(A[row][col]);
  273|      0|        }
  274|       |
  275|       |        // start transformations
  276|      0|        for (size_t row = 0; row < N; row++) {
  277|      0|            for (size_t row2 = row; row2 < N && temp[row][row] == 0; row2++) {
  278|       |                // this to ensure diagonal elements are not 0
  279|      0|                temp[row] = temp[row] + temp[row2];
  280|      0|                inverse[row] = inverse[row] + inverse[row2];
  281|      0|            }
  282|       |
  283|      0|            for (size_t col2 = row; col2 < N && temp[row][row] == 0; col2++) {
  284|       |                // this to further ensure diagonal elements are not 0
  285|      0|                for (size_t row2 = 0; row2 < N; row2++) {
  286|      0|                    temp[row2][row] = temp[row2][row] + temp[row2][col2];
  287|      0|                    inverse[row2][row] =
  288|      0|                        inverse[row2][row] + inverse[row2][col2];
  289|      0|                }
  290|      0|            }
  291|       |
  292|      0|            if (temp[row][row] == 0) {
  293|       |                // Probably a low-rank matrix and hence singular
  294|      0|                std::cerr << "Low-rank matrix, no inverse!" << std::endl;
  295|      0|                return inverse;
  296|      0|            }
  297|       |
  298|       |            // set diagonal to 1
  299|      0|            double divisor = temp[row][row];
  300|      0|            temp[row] = temp[row] / divisor;
  301|      0|            inverse[row] = inverse[row] / divisor;
  302|       |            // Row transformations
  303|      0|            for (size_t row2 = 0; row2 < N; row2++) {
  304|      0|                if (row2 == row)
  305|      0|                    continue;
  306|      0|                double factor = temp[row2][row];
  307|      0|                temp[row2] = temp[row2] - factor * temp[row];
  308|      0|                inverse[row2] = inverse[row2] - factor * inverse[row];
  309|      0|            }
  310|      0|        }
  311|       |
  312|      0|        return inverse;
  313|      0|    }
  314|       |
  315|      0|    static int modulo(int a, int b) {
  316|      0|        int ret = a % b;
  317|      0|        if (ret < 0)
  318|      0|            ret += b;
  319|      0|        return ret;
  320|      0|    }
  321|       |
  322|       | public:
  323|       |    /**
  324|       |     * @brief Generate encryption matrix of a given size. Larger size matrices
  325|       |     * are difficult to generate but provide more security. Important conditions
  326|       |     * are:
  327|       |     * 1. matrix should be invertible
  328|       |     * 2. determinant must not have any common factors with the length of
  329|       |     * character key
  330|       |     * There is no head-fast way to generate hte matrix under the given
  331|       |     * numerical restrictions of the machine but the conditions added achieve
  332|       |     * the goals. Bigger the matrix, greater is the probability of the matrix
  333|       |     * being ill-defined.
  334|       |     *
  335|       |     * @param size size of matrix (typically \f$\text{size}\le10\f$)
  336|       |     * @param limit1 lower limit of range of random elements (default=0)
  337|       |     * @param limit2 upper limit of range of random elements (default=10)
  338|       |     * @return Encryption martix
  339|       |     */
  340|       |    static matrix<int> generate_encryption_key(size_t size, int limit1 = 0,
  341|      0|                                               int limit2 = 10) {
  342|      0|        matrix<int> encrypt_key(size, std::valarray<int>(size));
  343|      0|        matrix<int> min_mat = encrypt_key;
  344|      0|        int mat_determinant = -1;  // because matrix has only ints, the
  345|       |                                   // determinant will also be an int
  346|      0|        int L = std::strlen(STRKEY);
  347|       |
  348|      0|        double dd;
  349|      0|        do {
  350|       |            // keeping the random number range smaller generates better
  351|       |            // defined matrices with more ease of cracking
  352|      0|            dd = rand_range(&encrypt_key, limit1, limit2);
  353|      0|            mat_determinant = static_cast<int>(dd);
  354|       |
  355|      0|            if (mat_determinant < 0)
  356|      0|                mat_determinant = (mat_determinant % L);
  357|      0|        } while (std::abs(dd) > 1e3 ||  // while ill-defined
  358|      0|                 dd < 0.1 ||  // while singular or negative determinant
  359|      0|                 !std::isfinite(dd) ||  // while determinant is not finite
  360|      0|                 gcd(mat_determinant, L) != 1);  // while no common factors
  361|       |        // std::cout <<
  362|       |
  363|      0|        return encrypt_key;
  364|      0|    }
  365|       |
  366|       |    /**
  367|       |     * @brief Generate decryption matrix from an encryption matrix key.
  368|       |     *
  369|       |     * @param encrypt_key encryption key for which to create a decrypt key
  370|       |     * @return Decryption martix
  371|       |     */
  372|      0|    static matrix<int> generate_decryption_key(matrix<int> const &encrypt_key) {
  373|      0|        size_t size = encrypt_key.size();
  374|      0|        int L = std::strlen(STRKEY);
  375|       |
  376|      0|        matrix<int> decrypt_key(size, std::valarray<int>(size));
  377|      0|        int det_encrypt = static_cast<int>(determinant_lu(encrypt_key));
  378|       |
  379|      0|        int mat_determinant = det_encrypt < 0 ? det_encrypt % L : det_encrypt;
  380|       |
  381|      0|        matrix<double> tmp_inverse = get_inverse(encrypt_key);
  382|      0|        double d2 = determinant_lu(decrypt_key);
  383|       |
  384|       |        // find co-prime factor for inversion
  385|      0|        int det_inv = -1;
  386|      0|        for (int i = 0; i < L; i++) {
  387|      0|            if (modulo(mat_determinant * i, L) == 1) {
  388|      0|                det_inv = i;
  389|      0|                break;
  390|      0|            }
  391|      0|        }
  392|       |
  393|      0|        if (det_inv == -1) {
  394|      0|            std::cerr << "Could not find a co-prime for inversion\n";
  395|      0|            std::exit(EXIT_FAILURE);
  396|      0|        }
  397|       |
  398|      0|        mat_determinant = det_inv * det_encrypt;
  399|       |
  400|       |        // perform modular inverse of encryption matrix
  401|      0|        int i;
  402|       |#ifdef _OPENMP
  403|       |#pragma parallel omp for private(i)
  404|       |#endif
  405|      0|        for (i = 0; i < size; i++) {
  406|      0|            for (int j = 0; j < size; j++) {
  407|      0|                int temp = std::round(tmp_inverse[i][j] * mat_determinant);
  408|      0|                decrypt_key[i][j] = modulo(temp, L);
  409|      0|            }
  410|      0|        }
  411|      0|        return decrypt_key;
  412|      0|    }
  413|       |
  414|       |    /**
  415|       |     * @brief Generate encryption and decryption key pair
  416|       |     *
  417|       |     * @param size size of matrix key (typically \f$\text{size}\le10\f$)
  418|       |     * @param limit1 lower limit of range of random elements (default=0)
  419|       |     * @param limit2 upper limit of range of random elements (default=10)
  420|       |     * @return std::pair<matrix<int>, matrix<int>> encryption and decryption
  421|       |     * keys as a pair
  422|       |     *
  423|       |     * @see ::generate_encryption_key
  424|       |     */
  425|       |    static std::pair<matrix<int>, matrix<int>> generate_keys(size_t size,
  426|       |                                                             int limit1 = 0,
  427|      0|                                                             int limit2 = 10) {
  428|      0|        matrix<int> encrypt_key = generate_encryption_key(size);
  429|      0|        matrix<int> decrypt_key = generate_decryption_key(encrypt_key);
  430|      0|        double det2 = determinant_lu(decrypt_key);
  431|      0|        while (std::abs(det2) < 0.1 || std::abs(det2) > 1e3) {
  432|      0|            encrypt_key = generate_encryption_key(size, limit1, limit2);
  433|      0|            decrypt_key = generate_decryption_key(encrypt_key);
  434|      0|            det2 = determinant_lu(decrypt_key);
  435|      0|        }
  436|      0|        return std::make_pair(encrypt_key, decrypt_key);
  437|      0|    }
  438|       |
  439|       |    /**
  440|       |     * @brief Encrypt a given text using a given key
  441|       |     *
  442|       |     * @param text string to encrypt
  443|       |     * @param encrypt_key  key for encryption
  444|       |     * @return encrypted text
  445|       |     */
  446|       |    static const std::string encrypt_text(const std::string &text,
  447|      0|                                          const matrix<int> &encrypt_key) {
  448|      0|        return codec(text, encrypt_key);
  449|      0|    }
  450|       |
  451|       |    /**
  452|       |     * @brief Decrypt a given text using a given key
  453|       |     *
  454|       |     * @param text string to decrypt
  455|       |     * @param decrypt_key  key for decryption
  456|       |     * @return decrypted text
  457|       |     */
  458|       |    static const std::string decrypt_text(const std::string &text,
  459|      0|                                          const matrix<int> &decrypt_key) {
  460|      0|        return codec(text, decrypt_key);
  461|      0|    }
  462|       |};
  463|       |
  464|       |}  // namespace ciphers
  465|       |
  466|       |/**
  467|       | * @brief Self test 1 - using 3x3 randomly generated key
  468|       | *
  469|       | * @param text string to encrypt and decrypt
  470|       | */
  471|      0|void test1(const std::string &text) {
  472|       |    // std::string text = "Hello world!";
  473|      0|    std::cout << "======Test 1 (3x3 key) ======\nOriginal text:\n\t" << text
  474|      0|              << std::endl;
  475|       |
  476|      0|    std::pair<matrix<int>, matrix<int>> p =
  477|      0|        ciphers::HillCipher::generate_keys(3, 0, 100);
  478|      0|    matrix<int> ekey = p.first;
  479|      0|    matrix<int> dkey = p.second;
  480|       |
  481|       |    // matrix<int> ekey = {{22, 28, 25}, {5, 26, 15}, {14, 18, 9}};
  482|       |    // std::cout << "Encryption key: \n" << ekey;
  483|      0|    std::string gibberish = ciphers::HillCipher::encrypt_text(text, ekey);
  484|      0|    std::cout << "Encrypted text:\n\t" << gibberish << std::endl;
  485|       |
  486|       |    // matrix<int> dkey = ciphers::HillCipher::generate_decryption_key(ekey);
  487|       |    // std::cout << "Decryption key: \n" << dkey;
  488|      0|    std::string txt_back = ciphers::HillCipher::decrypt_text(gibberish, dkey);
  489|      0|    std::cout << "Reconstruct text:\n\t" << txt_back << std::endl;
  490|       |
  491|      0|    std::ofstream out_file("hill_cipher_test1.txt");
  492|      0|    out_file << "Block size: " << ekey.size() << "\n";
  493|      0|    out_file << "Encryption Key:\n" << ekey;
  494|      0|    out_file << "\nDecryption Key:\n" << dkey;
  495|      0|    out_file.close();
  496|       |
  497|      0|    assert(txt_back == text);
  498|      0|    std::cout << "Passed :)\n";
  499|      0|}
  500|       |
  501|       |/**
  502|       | * @brief Self test 2 - using 8x8 randomly generated key
  503|       | *
  504|       | * @param text string to encrypt and decrypt
  505|       | */
  506|      0|void test2(const std::string &text) {
  507|       |    // std::string text = "Hello world!";
  508|      0|    std::cout << "======Test 2 (8x8 key) ======\nOriginal text:\n\t" << text
  509|      0|              << std::endl;
  510|       |
  511|      0|    std::pair<matrix<int>, matrix<int>> p =
  512|      0|        ciphers::HillCipher::generate_keys(8, 0, 3);
  513|      0|    matrix<int> ekey = p.first;
  514|      0|    matrix<int> dkey = p.second;
  515|       |
  516|      0|    std::string gibberish = ciphers::HillCipher::encrypt_text(text, ekey);
  517|      0|    std::cout << "Encrypted text:\n\t" << gibberish << std::endl;
  518|       |
  519|      0|    std::string txt_back = ciphers::HillCipher::decrypt_text(gibberish, dkey);
  520|      0|    std::cout << "Reconstruct text:\n\t" << txt_back << std::endl;
  521|       |
  522|      0|    std::ofstream out_file("hill_cipher_test2.txt");
  523|      0|    out_file << "Block size: " << ekey.size() << "\n";
  524|      0|    out_file << "Encryption Key:\n" << ekey;
  525|      0|    out_file << "\nDecryption Key:\n" << dkey;
  526|      0|    out_file.close();
  527|       |
  528|      0|    assert(txt_back.compare(0, text.size(), text) == 0);
  529|      0|    std::cout << "Passed :)\n";
  530|      0|}
  531|       |
  532|       |/** Main function */
  533|      0|int main() {
  534|      0|    std::srand(std::time(nullptr));
  535|      0|    std::cout << "Key dictionary: (" << std::strlen(ciphers::STRKEY) << ")\n\t"
  536|      0|              << ciphers::STRKEY << "\n";
  537|       |
  538|      0|    std::string text = "This is a simple text with numb3r5 and exclamat!0n.";
  539|       |
  540|      0|    test1(text);
  541|      0|    test2(text);
  542|       |
  543|      0|    return 0;
  544|      0|}

/home/kidus/Desktop/GNNs/ExamplePrograms/C-Plus-Plus/numerical_methods/lu_decomposition.h:
    1|       |/**
    2|       | * @file lu_decomposition.h
    3|       | * @author [Krishna Vedala](https://github.com/kvedala)
    4|       | * @brief Functions associated with [LU
    5|       | * Decomposition](https://en.wikipedia.org/wiki/LU_decomposition)
    6|       | * of a square matrix.
    7|       | */
    8|       |#pragma once
    9|       |
   10|       |#include <iostream>
   11|       |#include <valarray>
   12|       |#include <vector>
   13|       |#ifdef _OPENMP
   14|       |#include <omp.h>
   15|       |#endif
   16|       |
   17|       |/** Define matrix type as a `std::vector` of `std::valarray` */
   18|       |template <typename T>
   19|       |using matrix = std::vector<std::valarray<T>>;
   20|       |
   21|       |/** Perform LU decomposition on matrix
   22|       | * \param[in] A matrix to decompose
   23|       | * \param[out] L output L matrix
   24|       | * \param[out] U output U matrix
   25|       | * \returns 0 if no errors
   26|       | * \returns negative if error occurred
   27|       | */
   28|       |template <typename T>
   29|      0|int lu_decomposition(const matrix<T> &A, matrix<double> *L, matrix<double> *U) {
   30|      0|    int row, col, j;
   31|      0|    int mat_size = A.size();
   32|       |
   33|      0|    if (mat_size != A[0].size()) {
   34|       |        // check matrix is a square matrix
   35|      0|        std::cerr << "Not a square matrix!\n";
   36|      0|        return -1;
   37|      0|    }
   38|       |
   39|       |    // regularize each row
   40|      0|    for (row = 0; row < mat_size; row++) {
   41|       |        // Upper triangular matrix
   42|       |#ifdef _OPENMP
   43|       |#pragma omp for
   44|       |#endif
   45|      0|        for (col = row; col < mat_size; col++) {
   46|       |            // Summation of L[i,j] * U[j,k]
   47|      0|            double lu_sum = 0.;
   48|      0|            for (j = 0; j < row; j++) {
   49|      0|                lu_sum += L[0][row][j] * U[0][j][col];
   50|      0|            }
   51|       |
   52|       |            // Evaluate U[i,k]
   53|      0|            U[0][row][col] = A[row][col] - lu_sum;
   54|      0|        }
   55|       |
   56|       |        // Lower triangular matrix
   57|       |#ifdef _OPENMP
   58|       |#pragma omp for
   59|       |#endif
   60|      0|        for (col = row; col < mat_size; col++) {
   61|      0|            if (row == col) {
   62|      0|                L[0][row][col] = 1.;
   63|      0|                continue;
   64|      0|            }
   65|       |
   66|       |            // Summation of L[i,j] * U[j,k]
   67|      0|            double lu_sum = 0.;
   68|      0|            for (j = 0; j < row; j++) {
   69|      0|                lu_sum += L[0][col][j] * U[0][j][row];
   70|      0|            }
   71|       |
   72|       |            // Evaluate U[i,k]
   73|      0|            L[0][col][row] = (A[col][row] - lu_sum) / U[0][row][row];
   74|      0|        }
   75|      0|    }
   76|       |
   77|      0|    return 0;
   78|      0|}
   79|       |
   80|       |/**
   81|       | * Compute determinant of an NxN square matrix using LU decomposition.
   82|       | * Using LU decomposition, the determinant is given by the product of diagonal
   83|       | * elements of matrices L and U.
   84|       | *
   85|       | * @tparam T datatype of input matrix - int, unsigned int, double, etc
   86|       | * @param A input square matrix
   87|       | * @return determinant of matrix A
   88|       | */
   89|       |template <typename T>
   90|      0|double determinant_lu(const matrix<T> &A) {
   91|      0|    matrix<double> L(A.size(), std::valarray<double>(A.size()));
   92|      0|    matrix<double> U(A.size(), std::valarray<double>(A.size()));
   93|       |
   94|      0|    if (lu_decomposition(A, &L, &U) < 0)
   95|      0|        return 0;
   96|       |
   97|      0|    double result = 1.f;
   98|      0|    for (size_t i = 0; i < A.size(); i++) {
   99|      0|        result *= L[i][i] * U[i][i];
  100|      0|    }
  101|      0|    return result;
  102|      0|}

