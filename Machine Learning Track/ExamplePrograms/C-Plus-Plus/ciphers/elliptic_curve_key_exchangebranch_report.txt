/home/kidus/Desktop/GNNs/ExamplePrograms/C-Plus-Plus/ciphers/elliptic_curve_key_exchange.cpp:
    1|       |/**
    2|       | * @file
    3|       | * @brief Implementation of [Elliptic Curve Diffie Hellman Key
    4|       | * Exchange](https://cryptobook.nakov.com/asymmetric-key-ciphers/ecdh-key-exchange).
    5|       | *
    6|       | * @details
    7|       | * The ECDH (Elliptic Curve Diffie–Hellman Key Exchange) is anonymous key
    8|       | * agreement scheme, which allows two parties, each having an elliptic-curve
    9|       | * public–private key pair, to establish a shared secret over an insecure
   10|       | * channel.
   11|       | * ECDH is very similar to the classical DHKE (Diffie–Hellman Key Exchange)
   12|       | * algorithm, but it uses ECC point multiplication instead of modular
   13|       | * exponentiations. ECDH is based on the following property of EC points:
   14|       | * (a * G) * b = (b * G) * a
   15|       | * If we have two secret numbers a and b (two private keys, belonging to Alice
   16|       | * and Bob) and an ECC elliptic curve with generator point G, we can exchange
   17|       | * over an insecure channel the values (a * G) and (b * G) (the public keys of
   18|       | * Alice and Bob) and then we can derive a shared secret:
   19|       | * secret = (a * G) * b = (b * G) * a.
   20|       | * Pretty simple. The above equation takes the following form:
   21|       | * alicePubKey * bobPrivKey = bobPubKey * alicePrivKey = secret
   22|       | * @author [Ashish Daulatabad](https://github.com/AshishYUO)
   23|       | */
   24|       |#include <cassert>   /// for assert
   25|       |#include <iostream>  /// for IO operations
   26|       |
   27|       |#include "uint256_t.hpp"  /// for 256-bit integer
   28|       |
   29|       |/**
   30|       | * @namespace ciphers
   31|       | * @brief Cipher algorithms
   32|       | */
   33|       |namespace ciphers {
   34|       |/**
   35|       | * @brief namespace elliptic_curve_key_exchange
   36|       | * @details Demonstration of [Elliptic Curve
   37|       | * Diffie-Hellman](https://cryptobook.nakov.com/asymmetric-key-ciphers/ecdh-key-exchange)
   38|       | * key exchange.
   39|       | */
   40|       |namespace elliptic_curve_key_exchange {
   41|       |
   42|       |/**
   43|       | * @brief Definition of struct Point
   44|       | * @details Definition of Point in the curve.
   45|       | */
   46|       |typedef struct Point {
   47|       |    uint256_t x, y;  /// x and y co-ordinates
   48|       |
   49|       |    /**
   50|       |     * @brief operator == for Point
   51|       |     * @details check whether co-ordinates are equal to the given point
   52|       |     * @param p given point to be checked with this
   53|       |     * @returns true if x and y are both equal with Point p, else false
   54|       |     */
   55|      1|    inline bool operator==(const Point &p) { return x == p.x && y == p.y; }
   56|       |
   57|       |    /**
   58|       |     * @brief ostream operator for printing Point
   59|       |     * @param op ostream operator
   60|       |     * @param p Point to be printed on console
   61|       |     * @returns op, the ostream object
   62|       |     */
   63|      4|    friend std::ostream &operator<<(std::ostream &op, const Point &p) {
   64|      4|        op << p.x << " " << p.y;
   65|      4|        return op;
   66|      4|    }
   67|       |} Point;
   68|       |
   69|       |/**
   70|       | * @brief This function calculates number raised to exponent power under modulo
   71|       | * mod using [Modular
   72|       | * Exponentiation](https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/math/modular_exponentiation.cpp).
   73|       | * @param number integer base
   74|       | * @param power unsigned integer exponent
   75|       | * @param mod integer modulo
   76|       | * @return number raised to power modulo mod
   77|       | */
   78|    632|uint256_t exp(uint256_t number, uint256_t power, const uint256_t &mod) {
   79|    632|    if (!power) {
   80|      0|        return uint256_t(1);
   81|      0|    }
   82|    632|    uint256_t ans(1);
   83|    632|    number = number % mod;
   84|  71.4k|    while (power) {
   85|  70.7k|        if ((power & 1)) {
   86|  37.2k|            ans = (ans * number) % mod;
   87|  37.2k|        }
   88|  70.7k|        power >>= 1;
   89|  70.7k|        if (power) {
   90|  70.1k|            number = (number * number) % mod;
   91|  70.1k|        }
   92|  70.7k|    }
   93|    632|    return ans;
   94|    632|}
   95|       |
   96|       |/**
   97|       | * @brief Addition of points
   98|       | * @details Add given point to generate third point. More description can be
   99|       | * found
  100|       | * [here](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication#Point_addition),
  101|       | * and
  102|       | * [here](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication#Point_doubling)
  103|       | * @param a First point
  104|       | * @param b Second point
  105|       | * @param curve_a_coeff Coefficient `a` of the given curve (y^2 = x^3 + ax + b)
  106|       | * % mod
  107|       | * @param mod Given field
  108|       | * @return the resultant point
  109|       | */
  110|       |Point addition(Point a, Point b, const uint256_t &curve_a_coeff,
  111|    632|               uint256_t mod) {
  112|    632|    uint256_t lambda(0);  /// Slope
  113|    632|    uint256_t zero(0);    /// value zero
  114|    632|    lambda = zero = 0;
  115|    632|    uint256_t inf = ~zero;
  116|    632|    if (a.x != b.x || a.y != b.y) {
  117|       |        // Slope being infinite.
  118|    198|        if (b.x == a.x) {
  119|      0|            return {inf, inf};
  120|      0|        }
  121|    198|        uint256_t num = (b.y - a.y + mod), den = (b.x - a.x + mod);
  122|    198|        lambda = (num * (exp(den, mod - 2, mod))) % mod;
  123|    434|    } else {
  124|       |        /**
  125|       |         *  slope when the line is tangent to curve. This operation is performed
  126|       |         * while doubling. Taking derivative of `y^2 = x^3 + ax + b`
  127|       |         * => `2y dy = (3 * x^2 + a)dx`
  128|       |         * => `(dy/dx) = (3x^2 + a)/(2y)`
  129|       |         */
  130|       |        /**
  131|       |         * if y co-ordinate is zero, the slope is infinite, return inf.
  132|       |         * else calculate the slope (here % mod and store in lambda)
  133|       |         */
  134|    434|        if (!a.y) {
  135|      0|            return {inf, inf};
  136|      0|        }
  137|    434|        uint256_t axsq = ((a.x * a.x)) % mod;
  138|       |        // Mulitply by 3 adjustment
  139|    434|        axsq += (axsq << 1);
  140|    434|        axsq %= mod;
  141|       |        // Mulitply by 2 adjustment
  142|    434|        uint256_t a_2 = (a.y << 1);
  143|    434|        lambda =
  144|    434|            (((axsq + curve_a_coeff) % mod) * exp(a_2, mod - 2, mod)) % mod;
  145|    434|    }
  146|    632|    Point c;
  147|       |    // new point: x = ((lambda^2) - x1 - x2)
  148|       |    // y = (lambda * (x1 - x)) - y1
  149|    632|    c.x = ((lambda * lambda) % mod + (mod << 1) - a.x - b.x) % mod;
  150|    632|    c.y = (((lambda * (a.x + mod - c.x)) % mod) + mod - a.y) % mod;
  151|    632|    return c;
  152|    632|}
  153|       |
  154|       |/**
  155|       | * @brief multiply Point and integer
  156|       | * @details Multiply Point by a scalar factor (here it is a private key p). The
  157|       | * multiplication is called as [double and add
  158|       | * method](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication#Double-and-add)
  159|       | * @param a Point to multiply
  160|       | * @param curve_a_coeff Coefficient of given curve (y^2 = x^3 + ax + b) % mod
  161|       | * @param p The scalar value
  162|       | * @param mod Given field
  163|       | * @returns the resultant point
  164|       | */
  165|       |Point multiply(const Point &a, const uint256_t &curve_a_coeff, uint256_t p,
  166|      4|               const uint256_t &mod) {
  167|      4|    Point N = a;
  168|      4|    N.x %= mod;
  169|      4|    N.y %= mod;
  170|      4|    uint256_t inf{};
  171|      4|    inf = ~uint256_t(0);
  172|      4|    Point Q = {inf, inf};
  173|    442|    while (p) {
  174|    438|        if ((p & 1)) {
  175|    202|            if (Q.x == inf && Q.y == inf) {
  176|      4|                Q.x = N.x;
  177|      4|                Q.y = N.y;
  178|    198|            } else {
  179|    198|                Q = addition(Q, N, curve_a_coeff, mod);
  180|    198|            }
  181|    202|        }
  182|    438|        p >>= 1;
  183|    438|        if (p) {
  184|    434|            N = addition(N, N, curve_a_coeff, mod);
  185|    434|        }
  186|    438|    }
  187|      4|    return Q;
  188|      4|}
  189|       |}  // namespace elliptic_curve_key_exchange
  190|       |}  // namespace ciphers
  191|       |
  192|       |/**
  193|       | * @brief Function to test the
  194|       | * uint128_t header
  195|       | * @returns void
  196|       | */
  197|      1|static void uint128_t_tests() {
  198|       |    // 1st test: Operations test
  199|      1|    uint128_t a("122"), b("2312");
  200|      1|    assert(a + b == 2434);
  201|      0|    assert(b - a == 2190);
  202|      0|    assert(a * b == 282064);
  203|      0|    assert(b / a == 18);
  204|      0|    assert(b % a == 116);
  205|      0|    assert((a & b) == 8);
  206|      0|    assert((a | b) == 2426);
  207|      0|    assert((a ^ b) == 2418);
  208|      0|    assert((a << 64) == uint128_t("2250502776992565297152"));
  209|      0|    assert((b >> 7) == 18);
  210|       |
  211|       |    // 2nd test: Operations test
  212|      0|    a = uint128_t("12321421424232142122");
  213|      1|    b = uint128_t("23123212");
  214|      1|    assert(a + b == uint128_t("12321421424255265334"));
  215|      0|    assert(a - b == uint128_t("12321421424209018910"));
  216|      0|    assert(a * b == uint128_t("284910839733861759501135864"));
  217|      0|    assert(a / b == 532859423865LL);
  218|      0|    assert(a % b == 3887742);
  219|      0|    assert((a & b) == 18912520);
  220|      0|    assert((a | b) == uint128_t("12321421424236352814"));
  221|      0|    assert((a ^ b) == uint128_t("12321421424217440294"));
  222|      0|    assert((a << 64) == uint128_t("227290107637132170748078080907806769152"));
  223|      1|}
  224|       |
  225|       |/**
  226|       | * @brief Function to test the
  227|       | * uint256_t header
  228|       | * @returns void
  229|       | */
  230|      1|static void uint256_t_tests() {
  231|       |    // 1st test: Operations test
  232|      1|    uint256_t a("122"), b("2312");
  233|      1|    assert(a + b == 2434);
  234|      0|    assert(b - a == 2190);
  235|      0|    assert(a * b == 282064);
  236|      0|    assert(b / a == 18);
  237|      0|    assert(b % a == 116);
  238|      0|    assert((a & b) == 8);
  239|      0|    assert((a | b) == 2426);
  240|      0|    assert((a ^ b) == 2418);
  241|      0|    assert((a << 64) == uint256_t("2250502776992565297152"));
  242|      0|    assert((b >> 7) == 18);
  243|       |
  244|       |    // 2nd test: Operations test
  245|      0|    a = uint256_t("12321423124513251424232142122");
  246|      1|    b = uint256_t("23124312431243243215354315132413213212");
  247|      1|    assert(a + b == uint256_t("23124312443564666339867566556645355334"));
  248|       |    // Since a < b, the value is greater
  249|      0|    assert(a - b == uint256_t("115792089237316195423570985008687907853246860353"
  250|      1|                              "221642219366742944204948568846"));
  251|      0|    assert(a * b == uint256_t("284924437928789743312147393953938013677909398222"
  252|      1|                              "169728183872115864"));
  253|      0|    assert(b / a == uint256_t("1876756621"));
  254|      0|    assert(b % a == uint256_t("2170491202688962563936723450"));
  255|      0|    assert((a & b) == uint256_t("3553901085693256462344"));
  256|      0|    assert((a | b) == uint256_t("23124312443564662785966480863388892990"));
  257|      0|    assert((a ^ b) == uint256_t("23124312443564659232065395170132430646"));
  258|      0|    assert((a << 128) == uint256_t("4192763024643754272961909047609369343091683"
  259|      1|                                   "376561852756163540549632"));
  260|      1|}
  261|       |
  262|       |/**
  263|       | * @brief Function to test the
  264|       | * provided algorithm above
  265|       | * @returns void
  266|       | */
  267|      1|static void test() {
  268|       |    // demonstration of key exchange using curve secp112r1
  269|       |
  270|       |    // Equation of the form y^2 = (x^3 + ax + b) % P (here p is mod)
  271|      1|    uint256_t a("4451685225093714772084598273548424"),
  272|      1|        b("2061118396808653202902996166388514"),
  273|      1|        mod("4451685225093714772084598273548427");
  274|       |
  275|       |    // Generator value: is pre-defined for the given curve
  276|      1|    ciphers::elliptic_curve_key_exchange::Point ptr = {
  277|      1|        uint256_t("188281465057972534892223778713752"),
  278|      1|        uint256_t("3419875491033170827167861896082688")};
  279|       |
  280|       |    // Shared key generation.
  281|       |    // For alice
  282|      1|    std::cout << "For alice:\n";
  283|       |    // Alice's private key (can be generated randomly)
  284|      1|    uint256_t alice_private_key("164330438812053169644452143505618");
  285|      1|    ciphers::elliptic_curve_key_exchange::Point alice_public_key =
  286|      1|        multiply(ptr, a, alice_private_key, mod);
  287|      1|    std::cout << "\tPrivate key: " << alice_private_key << "\n";
  288|      1|    std::cout << "\tPublic Key: " << alice_public_key << std::endl;
  289|       |
  290|       |    // For Bob
  291|      1|    std::cout << "For Bob:\n";
  292|       |    // Bob's private key (can be generated randomly)
  293|      1|    uint256_t bob_private_key("1959473333748537081510525763478373");
  294|      1|    ciphers::elliptic_curve_key_exchange::Point bob_public_key =
  295|      1|        multiply(ptr, a, bob_private_key, mod);
  296|      1|    std::cout << "\tPrivate key: " << bob_private_key << "\n";
  297|      1|    std::cout << "\tPublic Key: " << bob_public_key << std::endl;
  298|       |
  299|       |    // After public key exchange, create a shared key for communication.
  300|       |    // create shared key:
  301|      1|    ciphers::elliptic_curve_key_exchange::Point alice_shared_key = multiply(
  302|      1|                                                    bob_public_key, a,
  303|      1|                                                    alice_private_key, mod),
  304|      1|                                                bob_shared_key = multiply(
  305|      1|                                                    alice_public_key, a,
  306|      1|                                                    bob_private_key, mod);
  307|       |
  308|      1|    std::cout << "Shared keys:\n";
  309|      1|    std::cout << alice_shared_key << std::endl;
  310|      1|    std::cout << bob_shared_key << std::endl;
  311|       |
  312|       |    // Check whether shared keys are equal
  313|      1|    assert(alice_shared_key == bob_shared_key);
  314|      1|}
  315|       |
  316|       |/**
  317|       | * @brief Main function
  318|       | * @returns 0 on exit
  319|       | */
  320|      1|int main() {
  321|      1|    uint128_t_tests();  // running predefined 128-bit unsigned integer tests
  322|      1|    uint256_t_tests();  // running predefined 256-bit unsigned integer tests
  323|      1|    test();             // running self-test implementations
  324|      1|    return 0;
  325|      1|}

/home/kidus/Desktop/GNNs/ExamplePrograms/C-Plus-Plus/ciphers/uint128_t.hpp:
    1|       |/**
    2|       | * @file
    3|       | *
    4|       | * @details Implementation of 128-bit unsigned integers.
    5|       | * @note The implementation can be flagged as not completed. This header is used
    6|       | * with enough operations as a part of bigger integer types 256-bit integer.
    7|       | * @author [Ashish Daulatabad](https://github.com/AshishYUO)
    8|       | */
    9|       |
   10|       |#include <algorithm>  /// for `std::reverse` and other operations
   11|       |#include <cstdint>
   12|       |#include <ostream>    /// for `std::cout` overload
   13|       |#include <string>     /// for `std::string`
   14|       |#include <utility>    /// for `std::pair` library
   15|       |
   16|       |#ifdef _MSC_VER
   17|       |#include <intrin.h>  /// for _BitScanForward64 and __BitScanReverse64 operation
   18|       |#endif
   19|       |
   20|       |#ifndef CIPHERS_UINT128_T_HPP_
   21|       |#define CIPHERS_UINT128_T_HPP_
   22|       |class uint128_t;
   23|       |
   24|       |template <>
   25|       |struct std::is_integral<uint128_t> : std::true_type {};
   26|       |template <>
   27|       |struct std::is_arithmetic<uint128_t> : std::true_type {};
   28|       |template <>
   29|       |struct std::is_unsigned<uint128_t> : std::true_type {};
   30|       |
   31|       |/**
   32|       | * @brief Adding two string
   33|       | * @details Adds two long integer, only used for printing numbers
   34|       | * @param first First integer string
   35|       | * @param second Second integer string
   36|       | * @returns string denoting the addition of both the strings
   37|       | */
   38|  1.82k|std::string add(const std::string &first, const std::string &second) {
   39|  1.82k|    std::string third;
   40|  1.82k|    int16_t sum = 0, carry = 0;
   41|  1.82k|    for (int32_t i = static_cast<int32_t>(first.size()) - 1,
   42|  1.82k|                 j = static_cast<int32_t>(second.size()) - 1;
   43|  35.9k|         i >= 0 || j >= 0; --i, --j) {
   44|  34.0k|        sum = ((i >= 0 ? first[i] - '0' : 0) + (j >= 0 ? second[j] - '0' : 0) +
   45|  34.0k|               carry);
   46|  34.0k|        carry = sum / 10;
   47|  34.0k|        sum %= 10;
   48|  34.0k|        third.push_back(sum + '0');
   49|  34.0k|    }
   50|  1.82k|    if (carry) {
   51|    470|        third.push_back('1');
   52|    470|    }
   53|  1.82k|    std::reverse(third.begin(), third.end());
   54|  1.82k|    return third;
   55|  1.82k|}
   56|       |/**
   57|       | * @class uint128_t
   58|       | * @brief class for 128-bit unsigned integer
   59|       | */
   60|       |class uint128_t {
   61|       |    uint64_t f{}, s{};  /// First and second half of 128 bit number
   62|       |
   63|       |    /**
   64|       |     * @brief Get integer from given string.
   65|       |     * @details Create an integer from a given string
   66|       |     * @param str integer string, can be hexadecimal (starting on 0x... or
   67|       |     * number)
   68|       |     * @returns void
   69|       |     */
   70|     11|    void __get_integer_from_string(const std::string &str) {
   71|     11|        this->f = this->s = 0;
   72|     11|        if (str.size() > 1 && str[1] == 'x') {  // if hexadecimal
   73|      0|            for (auto i = 2; i < str.size(); ++i) {
   74|      0|                *this *= 16LL;
   75|      0|                if (str[i] >= '0' && str[i] <= '9') {
   76|      0|                    *this += (str[i] - '0');
   77|      0|                } else if (str[i] >= 'A' && str[i] <= 'F') {
   78|      0|                    *this += (str[i] - 'A' + 10);
   79|      0|                } else if (str[i] >= 'a' && str[i] <= 'f') {
   80|      0|                    *this += (str[i] - 'a' + 10);
   81|      0|                }
   82|      0|            }
   83|     11|        } else {  // if decimal
   84|    203|            for (auto &x : str) {
   85|    203|                *this *= 10LL;
   86|    203|                *this += (x - '0');
   87|    203|            }
   88|     11|        }
   89|     11|    }
   90|       |
   91|       | public:
   92|  2.57k|    uint128_t() = default;
   93|       |
   94|       |    /**
   95|       |     * @brief Parameterized constructor
   96|       |     * @tparam T integral type
   97|       |     * @param low lower part 8-bit unisgned integer
   98|       |     */
   99|       |    template <typename T, typename = typename std::enable_if<
  100|       |                              std::is_integral<T>::value, T>::type>
  101|  7.04M|    explicit uint128_t(T low) : s(low) {}
  ------------------
  | _ZN9uint128_tC2IiiEET_:
  |  101|  6.60M|    explicit uint128_t(T low) : s(low) {}
  ------------------
  | _ZN9uint128_tC2ImmEET_:
  |  101|   441k|    explicit uint128_t(T low) : s(low) {}
  ------------------
  | _ZN9uint128_tC2IxxEET_:
  |  101|    921|    explicit uint128_t(T low) : s(low) {}
  ------------------
  102|       |
  103|       |    /**
  104|       |     * @brief Parameterized constructor
  105|       |     * @param str Integer string (hexadecimal starting with 0x.. or decimal)
  106|       |     */
  107|     11|    explicit uint128_t(const std::string &str) {
  108|     11|        __get_integer_from_string(str);
  109|     11|    }
  110|       |
  111|       |    /**
  112|       |     * @brief Parameterized constructor
  113|       |     * @param high higher part 64-bit unsigned integer
  114|       |     * @param low lower part 64-bit unsigned integer
  115|       |     */
  116|  94.3M|    uint128_t(const uint64_t high, const uint64_t low) : f(high), s(low) {}
  117|       |
  118|       |    /**
  119|       |     * @brief Copy constructor
  120|       |     * @param num 128-bit unsigned integer
  121|       |     */
  122|       |    uint128_t(const uint128_t &num) = default;
  123|       |
  124|       |    /**
  125|       |     * @brief Move constructor
  126|       |     * @param num 128-bit unsigned integer
  127|       |     */
  128|  1.05M|    uint128_t(uint128_t &&num) noexcept : f(num.f), s(num.s) {}
  129|       |
  130|       |    /**
  131|       |     * @brief Destructor for uint128_t
  132|       |     */
  133|       |    ~uint128_t() = default;
  134|       |
  135|       |    /**
  136|       |     * @brief Leading zeroes in binary
  137|       |     * @details Calculates leading zeros in 128-bit integer
  138|       |     * @returns Integer denoting leading zeroes
  139|       |     */
  140|  12.2M|    inline uint32_t _lez() {
  141|  12.2M|#ifndef _MSC_VER
  142|  12.2M|        if (f) {
  143|  5.25M|            return __builtin_clzll(f);
  144|  5.25M|        }
  145|  6.98M|        return 64 + __builtin_clzll(s);
  146|       |#else
  147|       |        unsigned long r = 0;
  148|       |        _BitScanForward64(&r, f);
  149|       |        if (r == 64) {
  150|       |            unsigned long l = 0;
  151|       |            _BitScanForward64(&l, s);
  152|       |            return 64 + l;
  153|       |        }
  154|       |        return r;
  155|       |#endif
  156|  12.2M|    }
  157|       |
  158|       |    /**
  159|       |     * @brief Trailing zeroes in binary
  160|       |     * @details Calculates leading zeros in 128-bit integer
  161|       |     * @returns Integer denoting Trailing zeroes
  162|       |     */
  163|      0|    inline uint32_t _trz() {
  164|      0|#ifndef _MSC_VER
  165|      0|        if (f) {
  166|      0|            return __builtin_ctzll(f);
  167|      0|        }
  168|      0|        return 64 + __builtin_ctzll(s);
  169|      0|#else
  170|      0|        unsigned long r = 0;
  171|      0|        _BitScanReverse64(&r, s);
  172|      0|        if (r == 64) {
  173|      0|            unsigned long l = 0;
  174|      0|            _BitScanReverse64(&l, f);
  175|      0|            return 64 + l;
  176|      0|        }
  177|      0|        return r;
  178|      0|#endif
  179|      0|    }
  180|       |
  181|       |    /**
  182|       |     * @brief casting operator to boolean value
  183|       |     * @returns true if value of this is non-zero, else false
  184|       |     */
  185|  12.2M|    inline explicit operator bool() const { return (f || s); }
  186|       |
  187|       |    /**
  188|       |     * @brief casting operator to any integer valu
  189|       |     * @tparam T any integer type
  190|       |     * @returns integer value casted to mentioned type
  191|       |     */
  192|       |    template <typename T, typename = typename std::enable_if<
  193|       |                              std::is_integral<T>::value, T>::type>
  194|       |    inline explicit operator T() const {
  195|       |        return static_cast<T>(s);
  196|       |    }
  197|       |
  198|       |    /**
  199|       |     * @brief returns lower 64-bit integer part
  200|       |     * @returns returns lower 64-bit integer part
  201|       |     */
  202|   220k|    inline uint64_t lower() const { return s; }
  203|       |
  204|       |    /**
  205|       |     * @brief returns upper 64-bit integer part
  206|       |     * @returns returns upper 64-bit integer part
  207|       |     */
  208|   441k|    inline uint64_t upper() const { return f; }
  209|       |
  210|       |    /**
  211|       |     * @brief operator = for other types
  212|       |     * @tparam T denoting any integer type
  213|       |     * @param p an integer to assign it's value
  214|       |     * @returns this pointer with it's value equal to `p`
  215|       |     */
  216|       |    template <typename T, typename = typename std::enable_if<
  217|       |                              std::is_integral<T>::value, T>::type>
  218|    632|    inline uint128_t &operator=(const T &p) {
  219|    632|        this->s = p;
  220|    632|        return *this;
  221|    632|    }
  222|       |
  223|       |    /**
  224|       |     * @brief operator = for type string
  225|       |     * @param p a string to assign it's value to equivalent integer
  226|       |     * @returns this pointer with it's value equal to `p`
  227|       |     */
  228|      0|    inline uint128_t &operator=(const std::string &p) {
  229|      0|        this->__get_integer_from_string(p);
  230|      0|        return *this;
  231|      0|    }
  232|       |
  233|       |    /**
  234|       |     * @brief operator = for uint128_t
  235|       |     * @param p an 128-bit integer to assign it's value
  236|       |     * @returns this pointer with it's value equal to `p`
  237|       |     */
  238|       |    inline uint128_t &operator=(const uint128_t &p) = default;
  239|       |
  240|       |    /**
  241|       |     * @brief Move assignment operator
  242|       |     */
  243|       |    inline uint128_t &operator=(uint128_t &&p) = default;
  244|       |
  245|       |    /**
  246|       |     * @brief operator + for uint128_t and other integer types.
  247|       |     * @tparam T denoting integral type
  248|       |     * @param p a type of integer variable
  249|       |     * @returns addition of this and p, returning uint128_t integer
  250|       |     */
  251|       |    template <typename T, typename = typename std::enable_if<
  252|       |                              std::is_integral<T>::value, T>::type>
  253|   334k|    inline uint128_t operator+(const T p) {
  254|   334k|        return uint128_t(f + (p + s < s), p + s);
  255|   334k|    }
  ------------------
  | _ZN9uint128_tplImmEES_T_:
  |  253|   220k|    inline uint128_t operator+(const T p) {
  |  254|   220k|        return uint128_t(f + (p + s < s), p + s);
  |  255|   220k|    }
  ------------------
  | _ZN9uint128_tplIiiEES_T_:
  |  253|   110k|    inline uint128_t operator+(const T p) {
  |  254|   110k|        return uint128_t(f + (p + s < s), p + s);
  |  255|   110k|    }
  ------------------
  | _ZN9uint128_tplIbbEES_T_:
  |  253|  3.16k|    inline uint128_t operator+(const T p) {
  |  254|  3.16k|        return uint128_t(f + (p + s < s), p + s);
  |  255|  3.16k|    }
  ------------------
  256|       |
  257|       |    /**
  258|       |     * @brief operator + for uint128_t and other integer types.
  259|       |     * @param p 128-bit unsigned integer
  260|       |     * @returns addition of this and p, returning uint128_t integer
  261|       |     */
  262|  23.6M|    inline uint128_t operator+(const uint128_t &p) {
  263|  23.6M|        return uint128_t(f + (p.s + s < s) + p.f, p.s + s);
  264|  23.6M|    }
  265|       |
  266|       |    /**
  267|       |     * @brief operator += for uint128_t and other integer types.
  268|       |     * @tparam T denoting integral type
  269|       |     * @param p a type of integer variable
  270|       |     * @returns addition of this and p, returning this
  271|       |     */
  272|       |    template <typename T, typename = typename std::enable_if<
  273|       |                              std::is_integral<T>::value, T>::type>
  274|  12.0M|    inline uint128_t &operator+=(const T p) {
  275|  12.0M|        bool app = p + s < s;
  276|  12.0M|        this->f += app;
  277|  12.0M|        this->s += p;
  278|  12.0M|        return *this;
  279|  12.0M|    }
  ------------------
  | _ZN9uint128_tpLIbbEERS_T_:
  |  274|  6.00M|    inline uint128_t &operator+=(const T p) {
  |  275|  6.00M|        bool app = p + s < s;
  |  276|  6.00M|        this->f += app;
  |  277|  6.00M|        this->s += p;
  |  278|  6.00M|        return *this;
  |  279|  6.00M|    }
  ------------------
  | _ZN9uint128_tpLIiiEERS_T_:
  |  274|  6.00M|    inline uint128_t &operator+=(const T p) {
  |  275|  6.00M|        bool app = p + s < s;
  |  276|  6.00M|        this->f += app;
  |  277|  6.00M|        this->s += p;
  |  278|  6.00M|        return *this;
  |  279|  6.00M|    }
  ------------------
  280|       |
  281|       |    /**
  282|       |     * @brief operator += for uint128_t
  283|       |     * @param p 128-bit unsigned integer
  284|       |     * @returns addition of this and p, returning this
  285|       |     */
  286|   110k|    uint128_t &operator+=(const uint128_t &p) {
  287|   110k|        bool app = p.s + s < s;
  288|   110k|        f = f + app + p.f;
  289|   110k|        s = p.s + s;
  290|   110k|        return *this;
  291|   110k|    }
  292|       |
  293|       |    /**
  294|       |     * @brief pre-increment operator
  295|       |     * @returns incremented value of this.
  296|       |     */
  297|     42|    inline uint128_t &operator++() {
  298|     42|        *this += 1;
  299|     42|        return *this;
  300|     42|    }
  301|       |
  302|       |    /**
  303|       |     * @brief post-increment operator
  304|       |     * @returns incremented value of this.
  305|       |     */
  306|      0|    inline uint128_t operator++(int) {
  307|      0|        ++*this;
  308|      0|        return *this;
  309|      0|    }
  310|       |
  311|       |    /**
  312|       |     * @brief operator - for uint128_t and other integer types.
  313|       |     * @tparam T denoting integral type
  314|       |     * @param p a type of integer variable
  315|       |     * @returns subtraction of this and p, returning uint128_t integer
  316|       |     */
  317|       |    template <typename T, typename = typename std::enable_if<
  318|       |                              std::is_integral<T>::value, T>::type>
  319|  6.00M|    inline uint128_t operator-(const T &p) {
  320|  6.00M|        bool app = p > s;
  321|  6.00M|        return uint128_t(f - app, s - p);
  322|  6.00M|    }
  ------------------
  | _ZN9uint128_tmiIbbEES_RKT_:
  |  319|  6.00M|    inline uint128_t operator-(const T &p) {
  |  320|  6.00M|        bool app = p > s;
  |  321|  6.00M|        return uint128_t(f - app, s - p);
  |  322|  6.00M|    }
  ------------------
  | _ZN9uint128_tmiIiiEES_RKT_:
  |  319|    632|    inline uint128_t operator-(const T &p) {
  |  320|    632|        bool app = p > s;
  |  321|    632|        return uint128_t(f - app, s - p);
  |  322|    632|    }
  ------------------
  323|       |
  324|       |    /**
  325|       |     * @brief operator - for uint128_t
  326|       |     * @param p a type of integer variable
  327|       |     * @returns subtraction of this and p, returning uint128_t integer
  328|       |     */
  329|  12.0M|    inline uint128_t operator-(const uint128_t &p) {
  330|  12.0M|        bool app = p.s > s;
  331|  12.0M|        return uint128_t(f - p.f - app, s - p.s);
  332|  12.0M|    }
  333|       |
  334|       |    /**
  335|       |     * @brief operator - using twos complement
  336|       |     * @returns 2's complement of this.
  337|       |     */
  338|      0|    inline uint128_t operator-() { return ~*this + uint128_t(1); }
  339|       |
  340|       |    /**
  341|       |     * @brief operator -- (pre-decrement)
  342|       |     * @returns decremented value of this
  343|       |     */
  344|      0|    inline uint128_t &operator--() {
  345|      0|        *this -= 1;
  346|      0|        return *this;
  347|      0|    }
  348|       |
  349|       |    /**
  350|       |     * @brief operator -- (post-decrement)
  351|       |     * @returns decremented value of this
  352|       |     */
  353|      0|    inline uint128_t operator--(int p) {
  354|      0|        --*this;
  355|      0|        return *this;
  356|      0|    }
  357|       |
  358|       |    /**
  359|       |     * @brief operator -= for uint128_t and other integer types.
  360|       |     * @tparam T denoting integral type
  361|       |     * @param p a type of integer variable
  362|       |     * @returns subtraction of this and p, returning this
  363|       |     */
  364|       |    template <typename T, typename = typename std::enable_if<
  365|       |                              std::is_integral<T>::value, T>::type>
  366|      0|    uint128_t &operator-=(const T &p) {
  367|      0|        bool app = p > s;
  368|      0|        f -= app;
  369|      0|        s -= p;
  370|      0|        return *this;
  371|      0|    }
  372|       |
  373|       |    /**
  374|       |     * @brief operator -= for uint128_t
  375|       |     * @param p 128-bit unsigned integer
  376|       |     * @returns subtraction of this and p, returning this
  377|       |     */
  378|     42|    uint128_t &operator-=(const uint128_t &p) {
  379|     42|        bool app = p.s > s;
  380|     42|        f = f - p.f - app;
  381|     42|        s = s - p.s;
  382|     42|        return *this;
  383|     42|    }
  384|       |
  385|       |    /**
  386|       |     * @brief operator * for uint128_t and other integer types.
  387|       |     * @tparam T denoting integral type
  388|       |     * @param p a type of integer variable
  389|       |     * @returns multiplication of this and p, returning uint128_t integer
  390|       |     */
  391|       |    template <typename T, typename = typename std::enable_if<
  392|       |                              std::is_integral<T>::value, T>::type>
  393|       |    inline uint128_t operator*(const T p) {
  394|       |        return *this * uint128_t(p);
  395|       |    }
  396|       |
  397|       |    /**
  398|       |     * @brief operator * for uint128_t and other integer types.
  399|       |     * @param p 128-bit unsigned integer
  400|       |     * @returns multiplication of this and p, returning uint128_t integer
  401|       |     */
  402|   662k|    uint128_t operator*(const uint128_t &p) {
  403|   662k|        uint64_t f_first = s >> 32, f_second = s & 0xFFFFFFFF,
  404|   662k|                 s_first = p.s >> 32, s_second = p.s & 0xFFFFFFFF;
  405|   662k|        uint64_t fi = f_first * s_first, se = f_first * s_second,
  406|   662k|                 th = s_first * f_second, fo = s_second * f_second;
  407|   662k|        uint64_t tmp = ((se & 0xFFFFFFFF) << 32), tmp2 = (th & 0xFFFFFFFF)
  408|   662k|                                                         << 32;
  409|   662k|        int cc = (tmp + tmp2 < tmp);
  410|   662k|        tmp += tmp2;
  411|   662k|        cc += (tmp + fo < tmp);
  412|   662k|        uint64_t carry = fi + (se >> 32) + (th >> 32);
  413|   662k|        return uint128_t(this->f * p.s + this->s * p.f + carry + cc, tmp + fo);
  414|   662k|    }
  415|       |
  416|       |    /**
  417|       |     * @brief operator *= for uint128_t and other integer types.
  418|       |     * @tparam T denoting integral type
  419|       |     * @param p a type of integer variable
  420|       |     * @returns multiplication of this and p, returning this
  421|       |     */
  422|       |    template <typename T, typename = typename std::enable_if<
  423|       |                              std::is_integral<T>::value, T>::type>
  424|    203|    inline uint128_t &operator*=(const T p) {
  425|    203|        *this *= uint128_t(p);
  426|    203|        return *this;
  427|    203|    }
  428|       |
  429|       |    /**
  430|       |     * @brief operator *= for uint128_t and other integer types.
  431|       |     * @param p 128-bit unsigned integer
  432|       |     * @returns multiplication of this and p, returning this
  433|       |     */
  434|    203|    uint128_t &operator*=(const uint128_t &p) {
  435|    203|        uint64_t f_first = s >> 32, f_second = s & 0xFFFFFFFF,
  436|    203|                 s_first = p.s >> 32, s_second = p.s & 0xFFFFFFFF;
  437|    203|        uint64_t fi = f_first * s_first, se = f_first * s_second,
  438|    203|                 th = s_first * f_second, fo = s_second * f_second;
  439|    203|        uint64_t tmp = (se << 32), tmp2 = (th << 32);
  440|    203|        int cc = (tmp + tmp2 < tmp);
  441|    203|        tmp += tmp2;
  442|    203|        cc += (tmp + fo < tmp);
  443|    203|        uint64_t carry = fi + (se >> 32) + (th >> 32);
  444|    203|        f = this->f * p.s + this->s * p.f + carry + cc;
  445|    203|        s = tmp + fo;
  446|    203|        return *this;
  447|    203|    }
  448|       |
  449|       |    /**
  450|       |     * @brief divide function for uint128_t and other integer types.
  451|       |     * @details divide this value and
  452|       |     * @param p 128-bit unsigned integer
  453|       |     * @returns pair denoting quotient and remainder.
  454|       |     */
  455|      4|    std::pair<uint128_t, uint128_t> divide(const uint128_t &p) {
  456|      4|        if (*this < p) {  // if this is less than divisor
  457|      0|            return {uint128_t(0), *this};
  458|      4|        } else if (*this == p) {  // if this is equal to divisor
  459|      0|            return {uint128_t(1), uint128_t(0)};
  460|      0|        }
  461|      4|        uint128_t tmp = p, tmp2 = *this;
  462|      4|        uint16_t left = tmp._lez() - _lez();
  463|      4|        tmp <<= left;
  464|      4|        uint128_t quotient(0);
  465|      4|        uint128_t zero(0);
  466|     46|        while (tmp2 >= p) {
  467|     42|            uint16_t shf = tmp2._lez() - tmp._lez();
  468|     42|            if (shf) {
  469|     26|                tmp >>= shf;
  470|     26|                quotient <<= shf;
  471|     26|                left -= shf;
  472|     26|            }
  473|     42|            if (tmp2 < tmp) {
  474|     26|                tmp >>= 1;
  475|     26|                quotient <<= 1;
  476|     26|                --left;
  477|     26|            }
  478|     42|            tmp2 -= tmp;
  479|     42|            ++quotient;
  480|     42|        }
  481|      4|        return {quotient << left, tmp2};
  482|      4|    }
  483|       |
  484|       |    /**
  485|       |     * @brief operator / for uint128_t and other integer types.
  486|       |     * @param p 128-bit unsigned integer
  487|       |     * @returns unsigned 128-bit quotient.
  488|       |     */
  489|      2|    inline uint128_t operator/(const uint128_t &p) { return divide(p).first; }
  490|       |
  491|       |    /**
  492|       |     * @brief operator / for uint128_t and other integer types.
  493|       |     * @tparam T denoting integral type
  494|       |     * @param p a type of integer variable
  495|       |     * @returns unsigned 128-bit quotient.
  496|       |     */
  497|       |    template <typename T, typename = typename std::enable_if<
  498|       |                              std::is_integral<T>::value, T>::type>
  499|       |    inline uint128_t operator/(const T p) {
  500|       |        uint128_t tmp = *this;
  501|       |        tmp /= uint128_t(0, p);
  502|       |        return tmp;
  503|       |    }
  504|       |
  505|       |    /**
  506|       |     * @brief operator /= for uint128_t
  507|       |     * @param p 128-bit unsigned integer
  508|       |     * @returns this set as unsigned 128-bit quotient.
  509|       |     */
  510|      0|    inline uint128_t &operator/=(const uint128_t &p) {
  511|      0|        *this = divide(p).first;
  512|      0|        return *this;
  513|      0|    }
  514|       |
  515|       |    /**
  516|       |     * @brief operator /= for uint128_t and other integer types.
  517|       |     * @tparam T denoting integral type
  518|       |     * @param p a type of integer variable
  519|       |     * @returns this set as unsigned 128-bit quotient.
  520|       |     */
  521|       |    template <typename T, typename = typename std::enable_if<
  522|       |                              std::is_integral<T>::value, T>::type>
  523|       |    inline uint128_t &operator/=(const T p) {
  524|       |        *this /= uint128_t(0, p);
  525|       |        return *this;
  526|       |    }
  527|       |
  528|       |    /**
  529|       |     * @brief operator % for uint128_t
  530|       |     * @param p 128-bit unsigned integer
  531|       |     * @returns unsigned 128-bit remainder.
  532|       |     */
  533|      2|    inline uint128_t operator%(const uint128_t &p) { return divide(p).second; }
  534|       |
  535|       |    /**
  536|       |     * @brief operator % for uint128_t and other integer types.
  537|       |     * @tparam T denoting integral type
  538|       |     * @param p a type of integer variable
  539|       |     * @returns unsigned 128-bit remainder.
  540|       |     */
  541|       |    template <typename T, typename = typename std::enable_if<
  542|       |                              std::is_integral<T>::value, T>::type>
  543|       |    inline uint128_t operator%(const T &p) {
  544|       |        return *this % uint128_t(p);
  545|       |    }
  546|       |
  547|       |    /**
  548|       |     * @brief operator %= for uint128_t
  549|       |     * @param p 128-bit unsigned integer
  550|       |     * @returns this set as unsigned 128-bit remainder.
  551|       |     */
  552|      0|    inline uint128_t &operator%=(const uint128_t &p) {
  553|      0|        *this = divide(p).second;
  554|      0|        return *this;
  555|      0|    }
  556|       |
  557|       |    /**
  558|       |     * @brief operator %= for uint128_t
  559|       |     * @tparam T denoting integral type
  560|       |     * @param p a type of integer variable
  561|       |     * @returns this set as unsigned 128-bit remainder.
  562|       |     */
  563|       |    template <typename T, typename = typename std::enable_if<
  564|       |                              std::is_integral<T>::value, T>::type>
  565|       |    inline uint128_t &operator%=(const T &p) {
  566|       |        *this %= uint128_t(p);
  567|       |        return *this;
  568|       |    }
  569|       |
  570|       |    /**
  571|       |     * @brief operator < for uint128_t
  572|       |     * @param other number to be compared with this
  573|       |     * @returns true if this is less than other, else false
  574|       |     */
  575|  19.3M|    inline bool operator<(const uint128_t &other) {
  576|  19.3M|        return f < other.f || (f == other.f && s < other.s);
  577|  19.3M|    }
  578|       |
  579|       |    /**
  580|       |     * @brief operator <= for uint128_t
  581|       |     * @param other number to be compared with this
  582|       |     * @returns true if this is less than or equal to other, else false
  583|       |     */
  584|      0|    inline bool operator<=(const uint128_t &other) {
  585|      0|        return f < other.f || (f == other.f && s <= other.s);
  586|      0|    }
  587|       |
  588|       |    /**
  589|       |     * @brief operator > for uint128_t
  590|       |     * @param other number to be compared with this
  591|       |     * @returns true if this is greater than other, else false
  592|       |     */
  593|  6.11M|    inline bool operator>(const uint128_t &other) {
  594|  6.11M|        return f > other.f || (f == other.f && s > other.s);
  595|  6.11M|    }
  596|       |
  597|       |    /**
  598|       |     * @brief operator >= for uint128_t
  599|       |     * @param other number to be compared with this
  600|       |     * @returns true if this is greater than or equal than other, else false
  601|       |     */
  602|   994k|    inline bool operator>=(const uint128_t &other) {
  603|   994k|        return (f > other.f) || (f == other.f && s >= other.s);
  604|   994k|    }
  605|       |
  606|       |    /**
  607|       |     * @brief operator == for uint128_t
  608|       |     * @param other number to be compared with this
  609|       |     * @returns true if this is equal than other, else false
  610|       |     */
  611|  3.04M|    inline bool operator==(const uint128_t &other) {
  612|  3.04M|        return f == other.f && s == other.s;
  613|  3.04M|    }
  614|       |
  615|       |    /**
  616|       |     * @brief operator != for uint128_t
  617|       |     * @param other number to be compared with this
  618|       |     * @returns true if this is not equal than other, else false
  619|       |     */
  620|      0|    inline bool operator!=(const uint128_t &other) {
  621|      0|        return f != other.f || s != other.s;
  622|      0|    }
  623|       |
  624|       |    /**
  625|       |     * @brief operator ! for uint128_t
  626|       |     * @returns true if this has zero value, else false
  627|       |     */
  628|  2.14k|    inline bool operator!() { return !f && !s; }
  629|       |
  630|       |    /**
  631|       |     * @brief operator && for uint128_t
  632|       |     * @param b number to be compared with this
  633|       |     * @returns true if both of the values are not zero, else false
  634|       |     */
  635|      0|    inline bool operator&&(const uint128_t &b) {
  636|      0|        return (s || f) && (b.s || b.f);
  637|      0|    }
  638|       |
  639|       |    /**
  640|       |     * @brief operator || for uint128_t
  641|       |     * @param b number to be compared with this
  642|       |     * @returns true if one of the values are not zero, else false
  643|       |     */
  644|   214k|    inline bool operator||(const uint128_t &b) {
  645|   214k|        return (s || f) || (b.s || b.f);
  646|   214k|    }
  647|       |
  648|       |    /**
  649|       |     * @brief operator () for uint128_t
  650|       |     * @returns true if this value is non-zero, else false
  651|       |     */
  652|      0|    inline bool operator()() { return s || f; }
  653|       |
  654|       |    /**
  655|       |     * @brief operator < for other types
  656|       |     * @tparam T integral type
  657|       |     * @param other number to be compared with this
  658|       |     * @returns true if this is less than other, else false
  659|       |     */
  660|       |    template <typename T, typename = typename std::enable_if<
  661|       |                              std::is_integral<T>::value, T>::type>
  662|       |    inline bool operator<(const T other) {
  663|       |        return *this < uint128_t(other);
  664|       |    }
  665|       |
  666|       |    /**
  667|       |     * @brief operator <= for other types
  668|       |     * @tparam T integral type
  669|       |     * @param other number to be compared with this
  670|       |     * @returns true if this is less than or equal to other, else false
  671|       |     */
  672|       |    template <typename T, typename = typename std::enable_if<
  673|       |                              std::is_integral<T>::value, T>::type>
  674|       |    inline bool operator<=(const T other) {
  675|       |        return *this <= uint128_t(other);
  676|       |    }
  677|       |
  678|       |    /**
  679|       |     * @brief operator > for other types
  680|       |     * @tparam T integral type
  681|       |     * @param other number to be compared with this
  682|       |     * @returns true if this is greater than other, else false
  683|       |     */
  684|       |    template <typename T, typename = typename std::enable_if<
  685|       |                              std::is_integral<T>::value, T>::type>
  686|       |    inline bool operator>(const T other) {
  687|       |        return *this > uint128_t(other);
  688|       |    }
  689|       |
  690|       |    /**
  691|       |     * @brief operator >= for other types
  692|       |     * @tparam T integral type
  693|       |     * @param other number to be compared with this
  694|       |     * @returns true if this is greater than or equal other, else false
  695|       |     */
  696|       |    template <typename T, typename = typename std::enable_if<
  697|       |                              std::is_integral<T>::value, T>::type>
  698|       |    inline bool operator>=(const T other) {
  699|       |        return *this >= uint128_t(other);
  700|       |    }
  701|       |
  702|       |    /**
  703|       |     * @brief operator == for other types
  704|       |     * @tparam T integral type
  705|       |     * @param other number to be compared with this
  706|       |     * @returns true if this is equal to other, else false
  707|       |     */
  708|       |    template <typename T, typename = typename std::enable_if<
  709|       |                              std::is_integral<T>::value, T>::type>
  710|     12|    inline bool operator==(const T other) {
  711|     12|        return *this == uint128_t(other);
  712|     12|    }
  ------------------
  | _ZN9uint128_teqIiiEEbT_:
  |  710|     11|    inline bool operator==(const T other) {
  |  711|     11|        return *this == uint128_t(other);
  |  712|     11|    }
  ------------------
  | _ZN9uint128_teqIxxEEbT_:
  |  710|      1|    inline bool operator==(const T other) {
  |  711|      1|        return *this == uint128_t(other);
  |  712|      1|    }
  ------------------
  713|       |
  714|       |    /**
  715|       |     * @brief operator != for other types
  716|       |     * @tparam T integral type
  717|       |     * @param other number to be compared with this
  718|       |     * @returns true if this is not equal to other, else false
  719|       |     */
  720|       |    template <typename T, typename = typename std::enable_if<
  721|       |                              std::is_integral<T>::value, T>::type>
  722|       |    inline bool operator!=(const T other) {
  723|       |        return *this != uint128_t(other);
  724|       |    }
  725|       |
  726|       |    /**
  727|       |     * @brief operator && for other types
  728|       |     * @tparam T integral type
  729|       |     * @param other number to be compared with this
  730|       |     * @returns true if this is both values are non-zero, else false
  731|       |     */
  732|       |    template <typename T, typename = typename std::enable_if<
  733|       |                              std::is_integral<T>::value, T>::type>
  734|       |    inline bool operator&&(const T b) {
  735|       |        return (f || s) && b;
  736|       |    }
  737|       |
  738|       |    /**
  739|       |     * @brief operator || for other types
  740|       |     * @tparam T integral type
  741|       |     * @param other number to be compared with this
  742|       |     * @returns true if this is either one of the values are non-zero, else
  743|       |     * false
  744|       |     */
  745|       |    template <typename T, typename = typename std::enable_if<
  746|       |                              std::is_integral<T>::value, T>::type>
  747|       |    inline bool operator||(const T b) {
  748|       |        return (f || s) || b;
  749|       |    }
  750|       |
  751|       |    /**
  752|       |     * @brief operator ~ for uint128_t
  753|       |     * @returns 1's complement of this number
  754|       |     */
  755|  1.27k|    uint128_t operator~() { return uint128_t(~this->f, ~this->s); }
  756|       |
  757|       |    /**
  758|       |     * @brief operator << for uint128_t
  759|       |     * @tparam T integral type
  760|       |     * @param p number denoting number of shifts
  761|       |     * @returns value of this shifted by p to left
  762|       |     */
  763|       |    template <typename T, typename = typename std::enable_if<
  764|       |                              std::is_integral<T>::value, T>::type>
  765|  25.9M|    uint128_t operator<<(const T p) {
  766|  25.9M|        if (!p) {
  767|      3|            return uint128_t(f, s);
  768|  25.9M|        } else if (p >= 64 && p <= 128) {
  769|  8.93M|            return uint128_t((this->s << (p - 64)), 0);
  770|  16.9M|        } else if (p < 64 && p > 0) {
  771|  16.9M|            return uint128_t((this->f << p) + ((this->s >> (64 - p))),
  772|  16.9M|                             this->s << p);
  773|  16.9M|        }
  774|      0|        return uint128_t(0);
  775|  25.9M|    }
  ------------------
  | _ZN9uint128_tlsIiiEES_T_:
  |  765|  18.7M|    uint128_t operator<<(const T p) {
  |  766|  18.7M|        if (!p) {
  |  767|      1|            return uint128_t(f, s);
  |  768|  18.7M|        } else if (p >= 64 && p <= 128) {
  |  769|  8.71M|            return uint128_t((this->s << (p - 64)), 0);
  |  770|  9.99M|        } else if (p < 64 && p > 0) {
  |  771|  9.99M|            return uint128_t((this->f << p) + ((this->s >> (64 - p))),
  |  772|  9.99M|                             this->s << p);
  |  773|  9.99M|        }
  |  774|      0|        return uint128_t(0);
  |  775|  18.7M|    }
  ------------------
  | _ZN9uint128_tlsIttEES_T_:
  |  765|  7.19M|    uint128_t operator<<(const T p) {
  |  766|  7.19M|        if (!p) {
  |  767|      2|            return uint128_t(f, s);
  |  768|  7.19M|        } else if (p >= 64 && p <= 128) {
  |  769|   218k|            return uint128_t((this->s << (p - 64)), 0);
  |  770|  6.97M|        } else if (p < 64 && p > 0) {
  |  771|  6.97M|            return uint128_t((this->f << p) + ((this->s >> (64 - p))),
  |  772|  6.97M|                             this->s << p);
  |  773|  6.97M|        }
  |  774|      0|        return uint128_t(0);
  |  775|  7.19M|    }
  ------------------
  776|       |
  777|       |    /**
  778|       |     * @brief operator <<= for uint128_t
  779|       |     * @tparam T integral type
  780|       |     * @param p number denoting number of shifts
  781|       |     * @returns this shifted by p to left
  782|       |     */
  783|       |    template <typename T, typename = typename std::enable_if<
  784|       |                              std::is_integral<T>::value, T>::type>
  785|     56|    uint128_t &operator<<=(const T p) {
  786|     56|        if (p) {
  787|     56|            if (p >= 64 && p <= 128) {
  788|      0|                this->f = (this->s << (p - 64));
  789|      0|                this->s = 0;
  790|     56|            } else {
  791|     56|                f = ((this->f << p) + (this->s >> (64 - p)));
  792|     56|                s = (this->s << p);
  793|     56|            }
  794|     56|        }
  795|     56|        return *this;
  796|     56|    }
  ------------------
  | _ZN9uint128_tlSIttEERS_T_:
  |  785|     30|    uint128_t &operator<<=(const T p) {
  |  786|     30|        if (p) {
  |  787|     30|            if (p >= 64 && p <= 128) {
  |  788|      0|                this->f = (this->s << (p - 64));
  |  789|      0|                this->s = 0;
  |  790|     30|            } else {
  |  791|     30|                f = ((this->f << p) + (this->s >> (64 - p)));
  |  792|     30|                s = (this->s << p);
  |  793|     30|            }
  |  794|     30|        }
  |  795|     30|        return *this;
  |  796|     30|    }
  ------------------
  | _ZN9uint128_tlSIiiEERS_T_:
  |  785|     26|    uint128_t &operator<<=(const T p) {
  |  786|     26|        if (p) {
  |  787|     26|            if (p >= 64 && p <= 128) {
  |  788|      0|                this->f = (this->s << (p - 64));
  |  789|      0|                this->s = 0;
  |  790|     26|            } else {
  |  791|     26|                f = ((this->f << p) + (this->s >> (64 - p)));
  |  792|     26|                s = (this->s << p);
  |  793|     26|            }
  |  794|     26|        }
  |  795|     26|        return *this;
  |  796|     26|    }
  ------------------
  797|       |
  798|       |    /**
  799|       |     * @brief operator >> for uint128_t
  800|       |     * @tparam T integral type
  801|       |     * @param p number denoting number of shifts
  802|       |     * @returns value of this shifted by p to right
  803|       |     */
  804|       |    template <typename T, typename = typename std::enable_if<
  805|       |                              std::is_integral<T>::value, T>::type>
  806|  25.5M|    uint128_t operator>>(const T p) {
  807|  25.5M|        if (!p) {
  808|      0|            return uint128_t(this->f, this->s);
  809|  25.5M|        } else if (p >= 64 && p <= 128) {
  810|  8.48M|            return uint128_t(0, (this->f >> (p - 64)));
  811|  17.1M|        } else if (p < 64 && p > 0) {
  812|  17.1M|            return uint128_t((this->f >> p),
  813|  17.1M|                             (this->s >> p) + (this->f << (64 - p)));
  814|  17.1M|        }
  815|      0|        return uint128_t(0);
  816|  25.5M|    }
  ------------------
  | _ZN9uint128_trsIiiEES_T_:
  |  806|  18.7M|    uint128_t operator>>(const T p) {
  |  807|  18.7M|        if (!p) {
  |  808|      0|            return uint128_t(this->f, this->s);
  |  809|  18.7M|        } else if (p >= 64 && p <= 128) {
  |  810|  8.48M|            return uint128_t(0, (this->f >> (p - 64)));
  |  811|  10.2M|        } else if (p < 64 && p > 0) {
  |  812|  10.2M|            return uint128_t((this->f >> p),
  |  813|  10.2M|                             (this->s >> p) + (this->f << (64 - p)));
  |  814|  10.2M|        }
  |  815|      0|        return uint128_t(0);
  |  816|  18.7M|    }
  ------------------
  | _ZN9uint128_trsIttEES_T_:
  |  806|  6.86M|    uint128_t operator>>(const T p) {
  |  807|  6.86M|        if (!p) {
  |  808|      0|            return uint128_t(this->f, this->s);
  |  809|  6.86M|        } else if (p >= 64 && p <= 128) {
  |  810|      0|            return uint128_t(0, (this->f >> (p - 64)));
  |  811|  6.86M|        } else if (p < 64 && p > 0) {
  |  812|  6.86M|            return uint128_t((this->f >> p),
  |  813|  6.86M|                             (this->s >> p) + (this->f << (64 - p)));
  |  814|  6.86M|        }
  |  815|      0|        return uint128_t(0);
  |  816|  6.86M|    }
  ------------------
  817|       |
  818|       |    /**
  819|       |     * @brief operator >>= for uint128_t
  820|       |     * @tparam T integral type
  821|       |     * @param p number denoting number of shifts
  822|       |     * @returns this shifted by p to right
  823|       |     */
  824|       |    template <typename T, typename = typename std::enable_if<
  825|       |                              std::is_integral<T>::value, T>::type>
  826|     52|    uint128_t &operator>>=(const T p) {
  827|     52|        if (p) {
  828|     52|            if (p >= 64) {
  829|      0|                f = 0;
  830|      0|                s = (this->f >> (p - 64));
  831|     52|            } else {
  832|     52|                s = (this->s >> p) + (this->f << (64 - p));
  833|     52|                f = (this->f >> p);
  834|     52|            }
  835|     52|        }
  836|     52|        return *this;
  837|     52|    }
  ------------------
  | _ZN9uint128_trSIttEERS_T_:
  |  826|     26|    uint128_t &operator>>=(const T p) {
  |  827|     26|        if (p) {
  |  828|     26|            if (p >= 64) {
  |  829|      0|                f = 0;
  |  830|      0|                s = (this->f >> (p - 64));
  |  831|     26|            } else {
  |  832|     26|                s = (this->s >> p) + (this->f << (64 - p));
  |  833|     26|                f = (this->f >> p);
  |  834|     26|            }
  |  835|     26|        }
  |  836|     26|        return *this;
  |  837|     26|    }
  ------------------
  | _ZN9uint128_trSIiiEERS_T_:
  |  826|     26|    uint128_t &operator>>=(const T p) {
  |  827|     26|        if (p) {
  |  828|     26|            if (p >= 64) {
  |  829|      0|                f = 0;
  |  830|      0|                s = (this->f >> (p - 64));
  |  831|     26|            } else {
  |  832|     26|                s = (this->s >> p) + (this->f << (64 - p));
  |  833|     26|                f = (this->f >> p);
  |  834|     26|            }
  |  835|     26|        }
  |  836|     26|        return *this;
  |  837|     26|    }
  ------------------
  838|       |
  839|       |    /**
  840|       |     * @brief operator & for uint128_t (bitwise operator)
  841|       |     * @param p number to be operated
  842|       |     * @returns value of this & p (& is bit-wise operator)
  843|       |     */
  844|   142k|    inline uint128_t operator&(const uint128_t &p) {
  845|   142k|        return uint128_t(this->f & p.f, this->s & p.s);
  846|   142k|    }
  847|       |
  848|       |    /**
  849|       |     * @brief operator & for other types (bitwise operator)
  850|       |     * @tparam T integral type
  851|       |     * @param p number to be operated
  852|       |     * @returns value of this & p (& is bit-wise operator)
  853|       |     */
  854|       |    template <typename T, typename = typename std::enable_if<
  855|       |                              std::is_integral<T>::value, T>::type>
  856|       |    uint128_t operator&(const T p) {
  857|       |        uint128_t tmp = *this;
  858|       |        return tmp & uint128_t(p);
  859|       |    }
  860|       |
  861|       |    /**
  862|       |     * @brief operator &= for uint128_t (bitwise operator)
  863|       |     * @param p number to be operated
  864|       |     * @returns this = this & p (& is bit-wise operator)
  865|       |     */
  866|      0|    uint128_t &operator&=(const uint128_t &p) {
  867|      0|        this->f &= p.f;
  868|      0|        this->s &= p.s;
  869|      0|        return *this;
  870|      0|    }
  871|       |
  872|       |    /**
  873|       |     * @brief operator &= for other types (bitwise operator)
  874|       |     * @tparam T integral type
  875|       |     * @param p number to be operated
  876|       |     * @returns this = this & p (& is bit-wise operator)
  877|       |     */
  878|       |    template <typename T, typename = typename std::enable_if<
  879|       |                              std::is_integral<T>::value, T>::type>
  880|       |    uint128_t &operator&=(const T p) {
  881|       |        *this &= uint128_t(p);
  882|       |        return *this;
  883|       |    }
  884|       |
  885|       |    /**
  886|       |     * @brief operator | for other types (bitwise operator)
  887|       |     * @tparam T integral type
  888|       |     * @param p number to be operated
  889|       |     * @returns value of this | p (| is bit-wise operator)
  890|       |     */
  891|       |    template <typename T, typename = typename std::enable_if<
  892|       |                              std::is_integral<T>::value, T>::type>
  893|       |    inline uint128_t operator|(const T p) {
  894|       |        return uint128_t(p | s);
  895|       |    }
  896|       |
  897|       |    /**
  898|       |     * @brief operator | for uint128_t (bitwise operator)
  899|       |     * @param p number to be operated
  900|       |     * @returns value of this | p (| is bit-wise OR operator)
  901|       |     */
  902|      6|    inline uint128_t operator|(const uint128_t &p) {
  903|      6|        return uint128_t(this->f | p.f, this->s | p.s);
  904|      6|    }
  905|       |
  906|       |    /**
  907|       |     * @brief operator |= for uint128_t (bitwise operator)
  908|       |     * @param p number to be operated
  909|       |     * @returns this = this | p (| is bit-wise OR operator)
  910|       |     */
  911|      0|    uint128_t &operator|=(const uint128_t &p) {
  912|      0|        f |= p.f;
  913|      0|        s |= p.s;
  914|      0|        return *this;
  915|      0|    }
  916|       |
  917|       |    /**
  918|       |     * @brief operator |= for other types (bitwise operator)
  919|       |     * @tparam T integral type
  920|       |     * @param p number to be operated
  921|       |     * @returns this = this | p (| is bit-wise OR operator)
  922|       |     */
  923|       |    template <typename T, typename = typename std::enable_if<
  924|       |                              std::is_integral<T>::value, T>::type>
  925|       |    inline uint128_t &operator|=(const T p) {
  926|       |        s |= p.s;
  927|       |        return *this;
  928|       |    }
  929|       |
  930|       |    /**
  931|       |     * @brief operator ^ for other types (bitwise operator)
  932|       |     * @tparam T integral type
  933|       |     * @param p number to be operated
  934|       |     * @returns value of this ^ p (^ is bit-wise XOR operator)
  935|       |     */
  936|       |    template <typename T, typename = typename std::enable_if<
  937|       |                              std::is_integral<T>::value, T>::type>
  938|       |    inline uint128_t operator^(const T p) {
  939|       |        return uint128_t(this->f, this->s ^ p);
  940|       |    }
  941|       |
  942|       |    /**
  943|       |     * @brief operator ^ for uint128_t (bitwise operator)
  944|       |     * @param p number to be operated
  945|       |     * @returns value of this ^ p (^ is bit-wise XOR operator)
  946|       |     */
  947|      6|    inline uint128_t operator^(const uint128_t &p) {
  948|      6|        return uint128_t(this->f ^ p.f, this->s ^ p.s);
  949|      6|    }
  950|       |
  951|       |    /**
  952|       |     * @brief operator ^= for uint128_t (bitwise operator)
  953|       |     * @param p number to be operated
  954|       |     * @returns this = this ^ p (^ is bit-wise XOR operator)
  955|       |     */
  956|      0|    uint128_t &operator^=(const uint128_t &p) {
  957|      0|        f ^= p.f;
  958|      0|        s ^= p.s;
  959|      0|        return *this;
  960|      0|    }
  961|       |
  962|       |    /**
  963|       |     * @brief operator ^= for other types (bitwise operator)
  964|       |     * @tparam T integral type
  965|       |     * @param p number to be operated
  966|       |     * @returns this = this ^ p (^ is bit-wise XOR operator)
  967|       |     */
  968|       |    template <typename T, typename = typename std::enable_if<
  969|       |                              std::is_integral<T>::value, T>::type>
  970|       |    inline uint128_t &operator^=(const T &p) {
  971|       |        s ^= p;
  972|       |        return *this;
  973|       |    }
  974|       |
  975|       |    /**
  976|       |     * @brief operator << for printing uint128_t integer
  977|       |     * @details Prints the uint128_t integer in decimal form
  978|       |     * @note Note that this operator is costly since it uses strings to print
  979|       |     * the value
  980|       |     * @param op ostream object
  981|       |     * @param p 128-bit integer
  982|       |     * @returns op, ostream object.
  983|       |     */
  984|     10|    friend std::ostream &operator<<(std::ostream &op, const uint128_t &p) {
  985|     10|        if (!p.f) {
  986|      0|            op << p.s;
  987|     10|        } else {
  988|     10|            std::string out = "0", p_2 = "1";
  989|    650|            for (int i = 0; i < 64; ++i) {
  990|    640|                if (p.s & (1LL << i)) {
  991|    339|                    out = add(out, p_2);
  992|    339|                }
  993|    640|                p_2 = add(p_2, p_2);
  994|    640|            }
  995|    650|            for (int i = 0; i < 64; ++i) {
  996|    640|                if (p.f & (1LL << i)) {
  997|    208|                    out = add(out, p_2);
  998|    208|                }
  999|    640|                p_2 = add(p_2, p_2);
 1000|    640|            }
 1001|     10|            op << out;
 1002|     10|        }
 1003|     10|        return op;
 1004|     10|    }
 1005|       |};
 1006|       |
 1007|       |// Arithmetic operators
 1008|       |template <typename T, typename = typename std::enable_if<
 1009|       |                          std::is_integral<T>::value, T>::type>
 1010|  6.00M|inline uint128_t operator+(const T &p, const uint128_t &q) {
 1011|  6.00M|    return uint128_t(p) + q;
 1012|  6.00M|}
 1013|       |
 1014|       |template <typename T, typename = typename std::enable_if<
 1015|       |                          std::is_integral<T>::value, T>::type>
 1016|       |inline uint128_t operator-(const T p, const uint128_t &q) {
 1017|       |    return uint128_t(p) - q;
 1018|       |}
 1019|       |
 1020|       |template <typename T, typename = typename std::enable_if<
 1021|       |                          std::is_integral<T>::value, T>::type>
 1022|       |inline uint128_t operator*(const T p, const uint128_t &q) {
 1023|       |    return uint128_t(p) * q;
 1024|       |}
 1025|       |
 1026|       |template <typename T, typename = typename std::enable_if<
 1027|       |                          std::is_integral<T>::value, T>::type>
 1028|       |inline uint128_t operator/(const T p, const uint128_t &q) {
 1029|       |    return uint128_t(p) / q;
 1030|       |}
 1031|       |
 1032|       |template <typename T, typename = typename std::enable_if<
 1033|       |                          std::is_integral<T>::value, T>::type>
 1034|       |inline uint128_t operator%(const T p, const uint128_t &q) {
 1035|       |    return uint128_t(p) % q;
 1036|       |}
 1037|       |
 1038|       |// Bitwise operators
 1039|       |template <typename T, typename = typename std::enable_if<
 1040|       |                          std::is_integral<T>::value, T>::type>
 1041|       |inline uint128_t operator&(const T &p, const uint128_t &q) {
 1042|       |    return uint128_t(p) & q;
 1043|       |}
 1044|       |
 1045|       |template <typename T, typename = typename std::enable_if<
 1046|       |                          std::is_integral<T>::value, T>::type>
 1047|       |inline uint128_t operator|(const T p, const uint128_t &q) {
 1048|       |    return uint128_t(p) | q;
 1049|       |}
 1050|       |
 1051|       |template <typename T, typename = typename std::enable_if<
 1052|       |                          std::is_integral<T>::value, T>::type>
 1053|       |inline uint128_t operator^(const T p, const uint128_t &q) {
 1054|       |    return uint128_t(p) ^ q;
 1055|       |}
 1056|       |
 1057|       |// Boolean operators
 1058|       |template <typename T, typename = typename std::enable_if<
 1059|       |                          std::is_integral<T>::value, T>::type>
 1060|       |inline bool operator&&(const T p, const uint128_t &q) {
 1061|       |    return uint128_t(p) && q;
 1062|       |}
 1063|       |
 1064|       |template <typename T, typename = typename std::enable_if<
 1065|       |                          std::is_integral<T>::value, T>::type>
 1066|   214k|inline bool operator||(const T p, const uint128_t &q) {
 1067|   214k|    return uint128_t(p) || q;
 1068|   214k|}
 1069|       |
 1070|       |// Comparison operators
 1071|       |template <typename T, typename = typename std::enable_if<
 1072|       |                          std::is_integral<T>::value, T>::type>
 1073|       |inline bool operator==(const T p, const uint128_t &q) {
 1074|       |    return uint128_t(p) == q;
 1075|       |}
 1076|       |
 1077|       |template <typename T, typename = typename std::enable_if<
 1078|       |                          std::is_integral<T>::value, T>::type>
 1079|       |inline bool operator!=(const T p, const uint128_t &q) {
 1080|       |    return uint128_t(p) != q;
 1081|       |}
 1082|       |
 1083|       |template <typename T, typename = typename std::enable_if<
 1084|       |                          std::is_integral<T>::value, T>::type>
 1085|       |inline bool operator<(const T p, const uint128_t &q) {
 1086|       |    return uint128_t(p) < q;
 1087|       |}
 1088|       |
 1089|       |template <typename T, typename = typename std::enable_if<
 1090|       |                          std::is_integral<T>::value, T>::type>
 1091|       |inline bool operator<=(const T p, const uint128_t &q) {
 1092|       |    return uint128_t(p) <= q;
 1093|       |}
 1094|       |
 1095|       |template <typename T, typename = typename std::enable_if<
 1096|       |                          std::is_integral<T>::value, T>::type>
 1097|    632|inline bool operator>(const T p, const uint128_t &q) {
 1098|    632|    return uint128_t(p) > q;
 1099|    632|}
 1100|       |
 1101|       |template <typename T, typename = typename std::enable_if<
 1102|       |                          std::is_integral<T>::value, T>::type>
 1103|       |inline bool operator>=(const T p, const uint128_t &q) {
 1104|       |    return uint128_t(p) >= q;
 1105|       |}
 1106|       |
 1107|       |#endif  // CIPHERS_UINT128_T_HPP_

/home/kidus/Desktop/GNNs/ExamplePrograms/C-Plus-Plus/ciphers/uint256_t.hpp:
    1|       |/**
    2|       | * @file
    3|       | *
    4|       | * @details Implementation of 256-bit unsigned integers.
    5|       | * @note The implementation can be flagged as not completed. This header is used
    6|       | * with enough operations to demonstrate the usage of ECDH (Elliptic Curve
    7|       | * Diffie-Hellman) Key exchange.
    8|       | * @author [Ashish Daulatabad](https://github.com/AshishYUO)
    9|       | */
   10|       |#include <string>   /// for `std::string`
   11|       |#include <utility>  /// for `std::pair` library
   12|       |
   13|       |#include "uint128_t.hpp"  /// for uint128_t integer
   14|       |
   15|       |#ifndef CIPHERS_UINT256_T_HPP_
   16|       |#define CIPHERS_UINT256_T_HPP_
   17|       |
   18|       |class uint256_t;
   19|       |
   20|       |template <>
   21|       |struct std::is_integral<uint256_t> : std::true_type {};
   22|       |
   23|       |template <>
   24|       |struct std::is_arithmetic<uint256_t> : std::true_type {};
   25|       |
   26|       |template <>
   27|       |struct std::is_unsigned<uint256_t> : std::true_type {};
   28|       |
   29|       |/**
   30|       | * @class uint256_t
   31|       | * @brief class for 256-bit unsigned integer
   32|       | */
   33|       |class uint256_t {
   34|       |    uint128_t f{}, s{};  /// First and second half of 256 bit number
   35|       |
   36|       |    /**
   37|       |     * @brief Get integer from given string.
   38|       |     * @details Create an integer from a given string
   39|       |     * @param str integer string, can be hexadecimal (starting on 0x... or
   40|       |     * number)
   41|       |     * @returns void
   42|       |     */
   43|     21|    void __get_integer_from_string(const std::string &str) {
   44|     21|        this->f = this->s = uint128_t(0);
   45|     21|        if (str.size() > 1 && str[1] == 'x') {
   46|      0|            for (auto i = 2; i < str.size(); ++i) {
   47|      0|                *this *= 16LL;
   48|      0|                if (str[i] >= '0' && str[i] <= '9') {
   49|      0|                    *this += (str[i] - '0');
   50|      0|                } else if (str[i] >= 'A' && str[i] <= 'F') {
   51|      0|                    *this += (str[i] - 'A' + 10);
   52|      0|                } else if (str[i] >= 'a' && str[i] <= 'f') {
   53|      0|                    *this += (str[i] - 'a' + 10);
   54|      0|                }
   55|      0|            }
   56|     21|        } else {
   57|    717|            for (auto &x : str) {
   58|    717|                *this *= 10LL;
   59|    717|                *this += (x - '0');
   60|    717|            }
   61|     21|        }
   62|     21|    }
   63|       |
   64|       | public:
   65|       |    // Constructors
   66|  1.26k|    uint256_t() = default;
   67|       |
   68|       |    /**
   69|       |     * @brief Parameterized constructor
   70|       |     * @tparam T template for integer types
   71|       |     * @param low Integer denoting lower 128-bits
   72|       |     */
   73|       |    template <typename T, typename = typename std::enable_if<
   74|       |                              std::is_integral<T>::value, T>::type>
   75|   297k|    explicit uint256_t(T low) : s(low), f(0) {}
  ------------------
  | _ZN9uint256_tC2IxxEET_:
  |   75|    717|    explicit uint256_t(T low) : s(low), f(0) {}
  ------------------
  | _ZN9uint256_tC2IiiEET_:
  |   75|   296k|    explicit uint256_t(T low) : s(low), f(0) {}
  ------------------
   76|       |
   77|       |    /**
   78|       |     * @brief Parameterized constructor
   79|       |     * @param str Integer string (hexadecimal starting with 0x.. or decimal)
   80|       |     */
   81|     21|    explicit uint256_t(const std::string &str) {
   82|     21|        __get_integer_from_string(str);
   83|     21|    }
   84|       |
   85|       |    /**
   86|       |     * @brief Copy constructor
   87|       |     * @param num 256-bit unsigned integer
   88|       |     */
   89|       |    uint256_t(const uint256_t &num) = default;
   90|       |
   91|       |    /**
   92|       |     * @brief Move constructor
   93|       |     * @param num 256-bit unsigned integer
   94|       |     */
   95|       |    uint256_t(uint256_t &&num) noexcept
   96|   224k|        : f(std::move(num.f)), s(std::move(num.s)) {}
   97|       |
   98|       |    /**
   99|       |     * @brief Parameterized constructor
  100|       |     * @param high higher part 128-bit unsigned integer
  101|       |     * @param low lower part 128-bit unsigned integer
  102|       |     */
  103|       |    uint256_t(uint128_t high, uint128_t low)
  104|   300k|        : f(std::move(high)), s(std::move(low)) {}
  105|       |
  106|       |    /**
  107|       |     * @brief Parameterized constructor
  108|       |     * @param high higher part 64-bit unsigned integer
  109|       |     * @param low lower part 64-bit unsigned integer
  110|       |     */
  111|      0|    uint256_t(const uint64_t high, const uint64_t low) : f(high), s(low) {}
  112|       |
  113|       |    /**
  114|       |     * @brief Destructor for uint256_t
  115|       |     */
  116|       |    ~uint256_t() = default;
  117|       |
  118|       |    /**
  119|       |     * @brief Leading zeroes in binary
  120|       |     * @details Calculates leading zeros in 256-bit integer
  121|       |     * @returns Integer denoting leading zeroes
  122|       |     */
  123|  12.2M|    inline uint32_t _lez() {
  124|  12.2M|        if (f) {
  125|  10.4M|            return f._lez();
  126|  10.4M|        }
  127|  1.81M|        return 128 + s._lez();
  128|  12.2M|    }
  129|       |
  130|       |    /**
  131|       |     * @brief Trailing zeroes in binary
  132|       |     * @details Calculates leading zeros in 256-bit integer
  133|       |     * @returns Integer denoting Trailing zeroes
  134|       |     */
  135|      0|    inline uint32_t _trz() {
  136|      0|        if (s) {
  137|      0|            return s._trz();
  138|      0|        }
  139|      0|        return 128 + f._trz();
  140|      0|    }
  141|       |
  142|       |    /**
  143|       |     * @brief casting operator to boolean value
  144|       |     * @returns true if value of this is non-zero, else false
  145|       |     */
  146|   214k|    inline explicit operator bool() const { return f || s; }
  147|       |
  148|       |    /**
  149|       |     * @brief casting operator to any integer value
  150|       |     * @tparam T any integer type
  151|       |     * @returns integer value casted to mentioned type
  152|       |     */
  153|       |    template <typename T, typename = typename std::enable_if<
  154|       |                              std::is_integral<T>::value, T>::type>
  155|       |    inline explicit operator T() const {
  156|       |        return static_cast<T>(s);
  157|       |    }
  158|       |
  159|       |    /**
  160|       |     * @brief casting operator to uint128_t
  161|       |     * @returns returns lower 128-bit integer part
  162|       |     */
  163|      0|    inline explicit operator uint128_t() const { return s; }
  164|       |
  165|       |    /**
  166|       |     * @brief returns lower 128-bit integer part
  167|       |     * @returns returns lower 128-bit integer part
  168|       |     */
  169|      0|    inline uint128_t lower() const { return s; }
  170|       |
  171|       |    /**
  172|       |     * @brief returns upper 128-bit integer part
  173|       |     * @returns returns upper 128-bit integer part
  174|       |     */
  175|      0|    inline uint128_t upper() const { return f; }
  176|       |
  177|       |    /**
  178|       |     * @brief operator = for uint256_t
  179|       |     * @param p an 256-bit integer to assign it's value
  180|       |     * @returns this pointer with it's value equal to `p`
  181|       |     */
  182|       |    inline uint256_t &operator=(const uint256_t &p) = default;
  183|       |
  184|       |    /**
  185|       |     * @brief operator = for other types
  186|       |     * @tparam T denoting any integer type
  187|       |     * @param p an integer to assign it's value
  188|       |     * @returns this pointer with it's value equal to `p`
  189|       |     */
  190|       |    template <typename T, typename = typename std::enable_if<
  191|       |                              std::is_integral<T>::value, T>::type>
  192|    632|    inline uint256_t &operator=(const T &p) {
  193|    632|        this->s = p;
  194|    632|        return *this;
  195|    632|    }
  196|       |
  197|       |    /**
  198|       |     * @brief operator = for type string
  199|       |     * @param p a string to assign it's value to equivalent integer
  200|       |     * @returns this pointer with it's value equal to `p`
  201|       |     */
  202|      0|    inline uint256_t &operator=(const std::string &p) {
  203|      0|        __get_integer_from_string(p);
  204|      0|        return *this;
  205|      0|    }
  206|       |
  207|       |    /**
  208|       |     * @brief Move assignment operator
  209|       |     */
  210|       |    inline uint256_t &operator=(uint256_t &&p) = default;
  211|       |
  212|       |    /**
  213|       |     * @brief operator + for uint256_t and other integer types.
  214|       |     * @tparam T denoting integral type
  215|       |     * @param p a type of integer variable
  216|       |     * @returns addition of this and p, returning uint256_t integer
  217|       |     */
  218|       |    template <typename T, typename = typename std::enable_if<
  219|       |                              std::is_integral<T>::value, T>::type>
  220|       |    inline uint256_t operator+(const T &p) {
  221|       |        bool app = s + p < s;
  222|       |        return uint256_t(f + app, s + p);
  223|       |    }
  224|       |
  225|       |    /**
  226|       |     * @brief operator + for uint256_t and other integer types.
  227|       |     * @param p 256-bit unsigned integer
  228|       |     * @returns addition of this and p, returning uint256_t integer
  229|       |     */
  230|  2.72k|    inline uint256_t operator+(const uint256_t &p) {
  231|  2.72k|        bool app = (s + p.s < s);
  232|  2.72k|        return {f + app + p.f, s + p.s};
  233|  2.72k|    }
  234|       |
  235|       |    /**
  236|       |     * @brief operator += for uint256_t and other integer types.
  237|       |     * @tparam T denoting integral type
  238|       |     * @param p a type of integer variable
  239|       |     * @returns addition of this and p, returning this
  240|       |     */
  241|       |    template <typename T, typename = typename std::enable_if<
  242|       |                              std::is_integral<T>::value, T>::type>
  243|  6.00M|    inline uint256_t &operator+=(const T &p) {
  244|  6.00M|        bool app = (p + s < s);
  245|  6.00M|        this->f += app;
  246|  6.00M|        this->s += p;
  247|  6.00M|        return *this;
  248|  6.00M|    }
  249|       |
  250|       |    /**
  251|       |     * @brief operator += for uint256_t
  252|       |     * @param p 256-bit unsigned integer
  253|       |     * @returns addition of this and p, returning this
  254|       |     */
  255|    434|    inline uint256_t &operator+=(const uint256_t &p) {
  256|    434|        bool app = (s + p.s < s);
  257|    434|        f = f + app + p.f;
  258|    434|        s = s + p.s;
  259|    434|        return *this;
  260|    434|    }
  261|       |
  262|       |    /**
  263|       |     * @brief pre-increment operator
  264|       |     * @returns incremented value of this.
  265|       |     */
  266|  6.00M|    inline uint256_t &operator++() {
  267|  6.00M|        *this += 1;
  268|  6.00M|        return *this;
  269|  6.00M|    }
  270|       |
  271|       |    /**
  272|       |     * @brief post-increment operator
  273|       |     * @returns incremented value of this.
  274|       |     */
  275|      0|    inline uint256_t operator++(int) {
  276|      0|        ++*this;
  277|      0|        return *this;
  278|      0|    }
  279|       |
  280|       |    /**
  281|       |     * @brief operator - for uint256_t and other integer types.
  282|       |     * @tparam T denoting integral type
  283|       |     * @param p a type of integer variable
  284|       |     * @returns subtraction of this and p, returning uint256_t integer
  285|       |     */
  286|       |    template <typename T, typename = typename std::enable_if<
  287|       |                              std::is_integral<T>::value, T>::type>
  288|    632|    inline uint256_t operator-(const T &p) {
  289|    632|        bool app = (p > s);
  290|    632|        return uint256_t(f - app, s - p);
  291|    632|    }
  292|       |
  293|       |    /**
  294|       |     * @brief operator - for uint256_t
  295|       |     * @param p a type of integer variable
  296|       |     * @returns subtraction of this and p, returning uint256_t integer
  297|       |     */
  298|  2.92k|    inline uint256_t operator-(const uint256_t &p) {
  299|  2.92k|        bool app = s < p.s;
  300|  2.92k|        return {f - p.f - app, s - p.s};
  301|  2.92k|    }
  302|       |
  303|       |    /**
  304|       |     * @brief operator - using twos complement
  305|       |     * @returns 2's complement of this.
  306|       |     */
  307|      0|    inline uint256_t operator-() { return ~*this + uint256_t(1); }
  308|       |
  309|       |    /**
  310|       |     * @brief operator -- (pre-decrement)
  311|       |     * @returns decremented value of this
  312|       |     */
  313|      0|    inline uint256_t &operator--() {
  314|      0|        *this -= 1;
  315|      0|        return *this;
  316|      0|    }
  317|       |
  318|       |    /**
  319|       |     * @brief operator -- (post-decrement)
  320|       |     * @returns decremented value of this
  321|       |     */
  322|      0|    inline uint256_t operator--(int p) {
  323|      0|        --*this;
  324|      0|        return *this;
  325|      0|    }
  326|       |
  327|       |    /**
  328|       |     * @brief operator -= for uint256_t and other integer types.
  329|       |     * @tparam T denoting integral type
  330|       |     * @param p a type of integer variable
  331|       |     * @returns subtraction of this and p, returning this
  332|       |     */
  333|       |    template <typename T, typename = typename std::enable_if<
  334|       |                              std::is_integral<T>::value, T>::type>
  335|      0|    inline uint256_t operator-=(const T p) {
  336|      0|        bool app = (p > s);
  337|      0|        f = f - app;
  338|      0|        s = s - p;
  339|      0|        return *this;
  340|      0|    }
  341|       |
  342|       |    /**
  343|       |     * @brief operator -= for uint256_t
  344|       |     * @param p 256-bit unsigned integer
  345|       |     * @returns subtraction of this and p, returning this
  346|       |     */
  347|  6.00M|    inline uint256_t &operator-=(const uint256_t &p) {
  348|  6.00M|        bool app = s < p.s;
  349|  6.00M|        f = f - app - p.f;
  350|  6.00M|        s = s - p.s;
  351|  6.00M|        return *this;
  352|  6.00M|    }
  353|       |
  354|       |    /**
  355|       |     * @brief operator * for uint256_t and other integer types.
  356|       |     * @tparam T denoting integral type
  357|       |     * @param p a type of integer variable
  358|       |     * @returns multiplication of this and p, returning uint256_t integer
  359|       |     */
  360|       |    template <typename T, typename = typename std::enable_if<
  361|       |                              std::is_integral<T>::value, T>::type>
  362|       |    inline uint256_t operator*(const T &p) {
  363|       |        return *this * uint256_t(p);
  364|       |    }
  365|       |
  366|       |    /**
  367|       |     * @brief operator * for uint256_t and other integer types.
  368|       |     * @param p 256-bit unsigned integer
  369|       |     * @returns multiplication of this and p, returning uint256_t integer
  370|       |     */
  371|   109k|    uint256_t operator*(const uint256_t &p) {
  372|   109k|        uint128_t f_first(s.upper()), f_second(s.lower()), s_first(p.s.upper()),
  373|   109k|            s_second(p.s.lower());
  374|   109k|        uint128_t fi = f_first * s_first, se = f_first * s_second,
  375|   109k|                  th = s_first * f_second, fo = s_second * f_second;
  376|   109k|        uint128_t tmp = se << 64, tmp2 = th << 64;
  377|   109k|        int cc = (tmp + tmp2 < tmp);
  378|   109k|        tmp += tmp2;
  379|   109k|        cc += (tmp + fo < tmp);
  380|   109k|        return {f * p.s + s * p.f + fi + se.upper() + th.upper() + cc,
  381|   109k|                tmp + fo};
  382|   109k|    }
  383|       |
  384|       |    /**
  385|       |     * @brief operator *= for uint256_t and other integer types.
  386|       |     * @tparam T denoting integral type
  387|       |     * @param p a type of integer variable
  388|       |     * @returns multiplication of this and p, returning this
  389|       |     */
  390|       |    template <typename T, typename = typename std::enable_if<
  391|       |                              std::is_integral<T>::value, T>::type>
  392|    717|    inline uint256_t &operator*=(const T &p) {
  393|    717|        return (*this *= uint256_t(p));
  394|    717|    }
  395|       |
  396|       |    /**
  397|       |     * @brief operator *= for uint256_t and other integer types.
  398|       |     * @param p 256-bit unsigned integer
  399|       |     * @returns multiplication of this and p, returning this
  400|       |     */
  401|    717|    uint256_t &operator*=(const uint256_t &p) {
  402|    717|        uint128_t f_first(s.upper()), f_second(s.lower()), s_first(p.s.upper()),
  403|    717|            s_second(p.s.lower());
  404|    717|        uint128_t fi = f_first * s_first, se = f_first * s_second,
  405|    717|                  th = s_first * f_second, fo = s_second * f_second;
  406|    717|        uint128_t tmp = se << 64, tmp2 = th << 64;
  407|    717|        int cc = (tmp + tmp2 < tmp);
  408|    717|        tmp += tmp2;
  409|    717|        cc += (tmp + fo < tmp);
  410|    717|        f = f * p.s + s * p.f + fi + se.upper() + th.upper() + cc;
  411|    717|        s = tmp + fo;
  412|    717|        return *this;
  413|    717|    }
  414|       |
  415|       |    /**
  416|       |     * @brief divide function for uint256_t and other integer types.
  417|       |     * @details divide this value and
  418|       |     * @param p 256-bit unsigned integer
  419|       |     * @returns pair denoting quotient and remainder.
  420|       |     */
  421|   112k|    std::pair<uint256_t, uint256_t> divide(const uint256_t &p) {
  422|   112k|        if (*this < p) {  // if this is less than divisor
  423|  1.56k|            return {uint256_t(0), *this};
  424|   110k|        } else if (*this == p) {  // if this is equal to divisor
  425|      0|            return {uint256_t(1), uint256_t(0)};
  426|      0|        }
  427|   110k|        uint256_t tmp = p, tmp2 = *this;
  428|   110k|        uint16_t left = tmp._lez() - _lez();
  429|   110k|        tmp <<= left;
  430|   110k|        uint256_t quotient(0);
  431|   110k|        uint256_t zero(0);
  432|  6.11M|        while (tmp2 >= p) {
  433|  6.00M|            uint16_t shf = tmp2._lez() - tmp._lez();
  434|  6.00M|            if (shf) {
  435|  3.43M|                tmp >>= shf;
  436|  3.43M|                quotient <<= shf;
  437|  3.43M|                left -= shf;
  438|  3.43M|            }
  439|  6.00M|            if (tmp2 < tmp) {
  440|  4.99M|                tmp >>= 1;
  441|  4.99M|                quotient <<= 1;
  442|  4.99M|                --left;
  443|  4.99M|            }
  444|  6.00M|            tmp2 -= tmp;
  445|  6.00M|            ++quotient;
  446|  6.00M|        }
  447|   110k|        return {quotient << left, tmp2};
  448|   112k|    }
  449|       |
  450|       |    /**
  451|       |     * @brief operator / for uint256_t and other integer types.
  452|       |     * @tparam T denoting integral type
  453|       |     * @param p a type of integer variable
  454|       |     * @returns unsigned 256-bit quotient.
  455|       |     */
  456|       |    template <typename T, typename = typename std::enable_if<
  457|       |                              std::is_integral<T>::value, T>::type>
  458|       |    inline uint256_t operator/(const T &p) {
  459|       |        uint256_t tmp = *this;
  460|       |        tmp /= uint256_t(p);
  461|       |        return tmp;
  462|       |    }
  463|       |
  464|       |    /**
  465|       |     * @brief operator / for uint256_t and other integer types.
  466|       |     * @param p 256-bit unsigned integer
  467|       |     * @returns unsigned 256-bit quotient.
  468|       |     */
  469|      2|    inline uint256_t operator/(const uint256_t &p) { return divide(p).first; }
  470|       |
  471|       |    /**
  472|       |     * @brief operator /= for uint256_t
  473|       |     * @param p 256-bit unsigned integer
  474|       |     * @returns this set as unsigned 256-bit quotient.
  475|       |     */
  476|      0|    inline uint256_t &operator/=(const uint256_t &p) {
  477|      0|        *this = divide(p).first;
  478|      0|        return *this;
  479|      0|    }
  480|       |
  481|       |    /**
  482|       |     * @brief operator /= for uint256_t and other integer types.
  483|       |     * @tparam T denoting integral type
  484|       |     * @param p a type of integer variable
  485|       |     * @returns this set as unsigned 256-bit quotient.
  486|       |     */
  487|       |    template <typename T, typename = typename std::enable_if<
  488|       |                              std::is_integral<T>::value, T>::type>
  489|       |    inline uint256_t &operator/=(const T &p) {
  490|       |        *this /= uint256_t(p);
  491|       |        return *this;
  492|       |    }
  493|       |
  494|       |    /**
  495|       |     * @brief operator % for uint256_t
  496|       |     * @param p 256-bit unsigned integer
  497|       |     * @returns unsigned 256-bit remainder.
  498|       |     */
  499|   112k|    inline uint256_t operator%(const uint256_t &p) { return divide(p).second; }
  500|       |
  501|       |    /**
  502|       |     * @brief operator % for uint256_t and other integer types.
  503|       |     * @tparam T denoting integral type
  504|       |     * @param p a type of integer variable
  505|       |     * @returns unsigned 256-bit remainder.
  506|       |     */
  507|       |    template <typename T, typename = typename std::enable_if<
  508|       |                              std::is_integral<T>::value, T>::type>
  509|       |    inline uint256_t operator%(const T &p) {
  510|       |        uint256_t tmp = *this;
  511|       |        tmp %= uint256_t(p);
  512|       |        return tmp;
  513|       |    }
  514|       |
  515|       |    /**
  516|       |     * @brief operator %= for uint256_t
  517|       |     * @param p 256-bit unsigned integer
  518|       |     * @returns this set as unsigned 256-bit remainder.
  519|       |     */
  520|    442|    inline uint256_t &operator%=(const uint256_t &p) {
  521|    442|        *this = divide(p).second;
  522|    442|        return *this;
  523|    442|    }
  524|       |
  525|       |    /**
  526|       |     * @brief operator %= for uint256_t
  527|       |     * @tparam T denoting integral type
  528|       |     * @param p a type of integer variable
  529|       |     * @returns this set as unsigned 256-bit remainder.
  530|       |     */
  531|       |    template <typename T, typename = typename std::enable_if<
  532|       |                              std::is_integral<T>::value, T>::type>
  533|       |    inline uint256_t &operator%=(const T &p) {
  534|       |        *this %= uint256_t(p);
  535|       |        return *this;
  536|       |    }
  537|       |
  538|       |    /**
  539|       |     * @brief operator < for uint256_t
  540|       |     * @param other number to be compared with this
  541|       |     * @returns true if this is less than other, else false
  542|       |     */
  543|  6.11M|    inline bool operator<(const uint256_t &other) {
  544|  6.11M|        return f < other.f || (f == other.f && s < other.s);
  545|  6.11M|    }
  546|       |
  547|       |    /**
  548|       |     * @brief operator <= for uint256_t
  549|       |     * @param other number to be compared with this
  550|       |     * @returns true if this is less than or equal to other, else false
  551|       |     */
  552|      0|    inline bool operator<=(const uint256_t &other) {
  553|      0|        return f < other.f || (f == other.f && s <= other.s);
  554|      0|    }
  555|       |
  556|       |    /**
  557|       |     * @brief operator > for uint256_t
  558|       |     * @param other number to be compared with this
  559|       |     * @returns true if this is greater than other, else false
  560|       |     */
  561|      0|    inline bool operator>(const uint256_t &other) {
  562|      0|        return f > other.f || (f == other.f && s > other.s);
  563|      0|    }
  564|       |
  565|       |    /**
  566|       |     * @brief operator >= for uint256_t
  567|       |     * @param other number to be compared with this
  568|       |     * @returns true if this is greater than or equal than other, else false
  569|       |     */
  570|  6.11M|    inline bool operator>=(const uint256_t &other) {
  571|  6.11M|        return (f > other.f) || (f == other.f && s >= other.s);
  572|  6.11M|    }
  573|       |
  574|       |    /**
  575|       |     * @brief operator == for uint256_t
  576|       |     * @param other number to be compared with this
  577|       |     * @returns true if this is equal than other, else false
  578|       |     */
  579|   112k|    inline bool operator==(const uint256_t &other) {
  580|   112k|        return f == other.f && s == other.s;
  581|   112k|    }
  582|       |
  583|       |    /**
  584|       |     * @brief operator != for uint256_t
  585|       |     * @param other number to be compared with this
  586|       |     * @returns true if this is not equal than other, else false
  587|       |     */
  588|  1.06k|    inline bool operator!=(const uint256_t &other) {
  589|  1.06k|        return !((*this) == other);
  590|  1.06k|    }
  591|       |
  592|       |    /**
  593|       |     * @brief operator ! for uint256_t
  594|       |     * @returns true if this has zero value, else false
  595|       |     */
  596|  1.06k|    inline bool operator!() { return !f && !s; }
  597|       |
  598|       |    /**
  599|       |     * @brief operator && for uint256_t
  600|       |     * @param b number to be compared with this
  601|       |     * @returns true if both of the values are not zero, else false
  602|       |     */
  603|      0|    inline bool operator&&(const uint256_t &b) {
  604|      0|        return (s || f) && (b.s || b.f);
  605|      0|    }
  606|       |
  607|       |    /**
  608|       |     * @brief operator || for uint256_t
  609|       |     * @param b number to be compared with this
  610|       |     * @returns true if one of the values are not zero, else false
  611|       |     */
  612|      0|    inline bool operator||(const uint256_t &b) {
  613|      0|        return (s || f) || (b.s || b.f);
  614|      0|    }
  615|       |
  616|       |    /**
  617|       |     * @brief operator () for uint256_t
  618|       |     * @returns true if this value is non-zero, else false
  619|       |     */
  620|      0|    inline bool operator()() { return s || f; }
  621|       |
  622|       |    /**
  623|       |     * @brief operator < for other types
  624|       |     * @tparam T integral type
  625|       |     * @param other number to be compared with this
  626|       |     * @returns true if this is less than other, else false
  627|       |     */
  628|       |    template <typename T, typename = typename std::enable_if<
  629|       |                              std::is_integral<T>::value, T>::type>
  630|       |    bool operator<(const T &other) {
  631|       |        return *this < uint256_t(other);
  632|       |    }
  633|       |
  634|       |    /**
  635|       |     * @brief operator <= for other types
  636|       |     * @tparam T integral type
  637|       |     * @param other number to be compared with this
  638|       |     * @returns true if this is less than or equal to other, else false
  639|       |     */
  640|       |    template <typename T, typename = typename std::enable_if<
  641|       |                              std::is_integral<T>::value, T>::type>
  642|       |    bool operator<=(const T &other) {
  643|       |        return *this <= uint256_t(other);
  644|       |    }
  645|       |
  646|       |    /**
  647|       |     * @brief operator > for other types
  648|       |     * @tparam T integral type
  649|       |     * @param other number to be compared with this
  650|       |     * @returns true if this is greater than other, else false
  651|       |     */
  652|       |    template <typename T, typename = typename std::enable_if<
  653|       |                              std::is_integral<T>::value, T>::type>
  654|       |    bool operator>(const T &other) {
  655|       |        return *this > uint256_t(other);
  656|       |    }
  657|       |
  658|       |    /**
  659|       |     * @brief operator >= for other types
  660|       |     * @tparam T integral type
  661|       |     * @param other number to be compared with this
  662|       |     * @returns true if this is greater than or equal other, else false
  663|       |     */
  664|       |    template <typename T, typename = typename std::enable_if<
  665|       |                              std::is_integral<T>::value, T>::type>
  666|       |    bool operator>=(const T &other) {
  667|       |        return *this >= uint256_t(other);
  668|       |    }
  669|       |
  670|       |    /**
  671|       |     * @brief operator == for other types
  672|       |     * @tparam T integral type
  673|       |     * @param other number to be compared with this
  674|       |     * @returns true if this is equal to other, else false
  675|       |     */
  676|       |    template <typename T, typename = typename std::enable_if<
  677|       |                              std::is_integral<T>::value, T>::type>
  678|      9|    bool operator==(const T &other) {
  679|      9|        return *this == uint256_t(other);
  680|      9|    }
  681|       |
  682|       |    /**
  683|       |     * @brief operator != for other types
  684|       |     * @tparam T integral type
  685|       |     * @param other number to be compared with this
  686|       |     * @returns true if this is not equal to other, else false
  687|       |     */
  688|       |    template <typename T, typename = typename std::enable_if<
  689|       |                              std::is_integral<T>::value, T>::type>
  690|       |    bool operator!=(const T &other) {
  691|       |        return *this != uint256_t(other);
  692|       |    }
  693|       |
  694|       |    /**
  695|       |     * @brief operator && for other types
  696|       |     * @tparam T integral type
  697|       |     * @param other number to be compared with this
  698|       |     * @returns true if this is both values are non-zero, else false
  699|       |     */
  700|       |    template <typename T, typename = typename std::enable_if<
  701|       |                              std::is_integral<T>::value, T>::type>
  702|       |    inline bool operator&&(const T &b) {
  703|       |        return (s || f) && (b);
  704|       |    }
  705|       |
  706|       |    /**
  707|       |     * @brief operator || for other types
  708|       |     * @tparam T integral type
  709|       |     * @param other number to be compared with this
  710|       |     * @returns true if this is either one of the values are non-zero, else
  711|       |     * false
  712|       |     */
  713|       |    template <typename T, typename = typename std::enable_if<
  714|       |                              std::is_integral<T>::value, T>::type>
  715|       |    inline bool operator||(const T &b) {
  716|       |        return (s || f) || (b);
  717|       |    }
  718|       |
  719|       |    /**
  720|       |     * @brief operator ~ for uint256_t
  721|       |     * @returns 1's complement of this number
  722|       |     */
  723|    636|    inline uint256_t operator~() { return {~f, ~s}; }
  724|       |
  725|       |    /**
  726|       |     * @brief operator << for uint256_t
  727|       |     * @tparam T integral type
  728|       |     * @param p number denoting number of shifts
  729|       |     * @returns value of this shifted by p to left
  730|       |     */
  731|       |    template <typename T, typename = typename std::enable_if<
  732|       |                              std::is_integral<T>::value, T>::type>
  733|   112k|    uint256_t operator<<(const T &p) {
  734|   112k|        if (!p) {
  735|  56.3k|            return {this->f, this->s};
  736|  56.3k|        } else if (p >= 128) {
  737|      1|            return uint256_t((this->s << (p - 128)), uint128_t(0));
  738|      1|        }
  739|  56.1k|        return uint256_t((this->f << p) + (this->s >> (128 - p)),
  740|  56.1k|                         (this->s << p));
  741|   112k|    }
  ------------------
  | _ZN9uint256_tlsIttEES_RKT_:
  |  733|   110k|    uint256_t operator<<(const T &p) {
  |  734|   110k|        if (!p) {
  |  735|  56.3k|            return {this->f, this->s};
  |  736|  56.3k|        } else if (p >= 128) {
  |  737|      0|            return uint256_t((this->s << (p - 128)), uint128_t(0));
  |  738|      0|        }
  |  739|  54.6k|        return uint256_t((this->f << p) + (this->s >> (128 - p)),
  |  740|  54.6k|                         (this->s << p));
  |  741|   110k|    }
  ------------------
  | _ZN9uint256_tlsIiiEES_RKT_:
  |  733|  1.50k|    uint256_t operator<<(const T &p) {
  |  734|  1.50k|        if (!p) {
  |  735|      0|            return {this->f, this->s};
  |  736|  1.50k|        } else if (p >= 128) {
  |  737|      1|            return uint256_t((this->s << (p - 128)), uint128_t(0));
  |  738|      1|        }
  |  739|  1.50k|        return uint256_t((this->f << p) + (this->s >> (128 - p)),
  |  740|  1.50k|                         (this->s << p));
  |  741|  1.50k|    }
  ------------------
  742|       |
  743|       |    /**
  744|       |     * @brief operator <<= for uint256_t
  745|       |     * @tparam T integral type
  746|       |     * @param p number denoting number of shifts
  747|       |     * @returns this shifted by p to left
  748|       |     */
  749|       |    template <typename T, typename = typename std::enable_if<
  750|       |                              std::is_integral<T>::value, T>::type>
  751|  8.53M|    uint256_t &operator<<=(const T &p) {
  752|  8.53M|        if (p) {
  753|  8.53M|            if (p >= 128) {
  754|      0|                this->f = (this->s << (p - 128));
  755|      0|                this->s = uint128_t(0);
  756|  8.53M|            } else {
  757|  8.53M|                f = ((this->s >> (128 - p)) + (this->f << p));
  758|  8.53M|                s = (this->s << p);
  759|  8.53M|            }
  760|  8.53M|        }
  761|  8.53M|        return *this;
  762|  8.53M|    }
  ------------------
  | _ZN9uint256_tlSIttEERS_RKT_:
  |  751|  3.54M|    uint256_t &operator<<=(const T &p) {
  |  752|  3.54M|        if (p) {
  |  753|  3.54M|            if (p >= 128) {
  |  754|      0|                this->f = (this->s << (p - 128));
  |  755|      0|                this->s = uint128_t(0);
  |  756|  3.54M|            } else {
  |  757|  3.54M|                f = ((this->s >> (128 - p)) + (this->f << p));
  |  758|  3.54M|                s = (this->s << p);
  |  759|  3.54M|            }
  |  760|  3.54M|        }
  |  761|  3.54M|        return *this;
  |  762|  3.54M|    }
  ------------------
  | _ZN9uint256_tlSIiiEERS_RKT_:
  |  751|  4.99M|    uint256_t &operator<<=(const T &p) {
  |  752|  4.99M|        if (p) {
  |  753|  4.99M|            if (p >= 128) {
  |  754|      0|                this->f = (this->s << (p - 128));
  |  755|      0|                this->s = uint128_t(0);
  |  756|  4.99M|            } else {
  |  757|  4.99M|                f = ((this->s >> (128 - p)) + (this->f << p));
  |  758|  4.99M|                s = (this->s << p);
  |  759|  4.99M|            }
  |  760|  4.99M|        }
  |  761|  4.99M|        return *this;
  |  762|  4.99M|    }
  ------------------
  763|       |
  764|       |    /**
  765|       |     * @brief operator >> for uint256_t
  766|       |     * @tparam T integral type
  767|       |     * @param p number denoting number of shifts
  768|       |     * @returns value of this shifted by p to right
  769|       |     */
  770|       |    template <typename T, typename = typename std::enable_if<
  771|       |                              std::is_integral<T>::value, T>::type>
  772|      1|    uint256_t operator>>(const T &p) {
  773|      1|        if (!p) {
  774|      0|            return {this->f, this->s};
  775|      1|        } else if (p >= 128) {
  776|      0|            return uint256_t(uint128_t(0), (this->f >> (p - 128)));
  777|      0|        }
  778|      1|        return uint256_t((this->f >> p),
  779|      1|                         (this->s >> p) + (this->f << (128 - p)));
  780|      1|    }
  781|       |
  782|       |    /**
  783|       |     * @brief operator >>= for uint256_t
  784|       |     * @tparam T integral type
  785|       |     * @param p number denoting number of shifts
  786|       |     * @returns this shifted by p to right
  787|       |     */
  788|       |    template <typename T, typename = typename std::enable_if<
  789|       |                              std::is_integral<T>::value, T>::type>
  790|  8.49M|    uint256_t &operator>>=(const T &p) {
  791|  8.49M|        if (p) {
  792|  8.49M|            if (p >= 128) {
  793|      0|                f = uint128_t(0);
  794|      0|                s = (this->f >> (p - 128));
  795|  8.49M|            } else {
  796|  8.49M|                s = (this->s >> p) + (this->f << (128 - p));
  797|  8.49M|                f = (this->f >> p);
  798|  8.49M|            }
  799|  8.49M|        }
  800|  8.49M|        return *this;
  801|  8.49M|    }
  ------------------
  | _ZN9uint256_trSIttEERS_RKT_:
  |  790|  3.43M|    uint256_t &operator>>=(const T &p) {
  |  791|  3.43M|        if (p) {
  |  792|  3.43M|            if (p >= 128) {
  |  793|      0|                f = uint128_t(0);
  |  794|      0|                s = (this->f >> (p - 128));
  |  795|  3.43M|            } else {
  |  796|  3.43M|                s = (this->s >> p) + (this->f << (128 - p));
  |  797|  3.43M|                f = (this->f >> p);
  |  798|  3.43M|            }
  |  799|  3.43M|        }
  |  800|  3.43M|        return *this;
  |  801|  3.43M|    }
  ------------------
  | _ZN9uint256_trSIiiEERS_RKT_:
  |  790|  5.06M|    uint256_t &operator>>=(const T &p) {
  |  791|  5.06M|        if (p) {
  |  792|  5.06M|            if (p >= 128) {
  |  793|      0|                f = uint128_t(0);
  |  794|      0|                s = (this->f >> (p - 128));
  |  795|  5.06M|            } else {
  |  796|  5.06M|                s = (this->s >> p) + (this->f << (128 - p));
  |  797|  5.06M|                f = (this->f >> p);
  |  798|  5.06M|            }
  |  799|  5.06M|        }
  |  800|  5.06M|        return *this;
  |  801|  5.06M|    }
  ------------------
  802|       |
  803|       |    /**
  804|       |     * @brief operator & for other types (bitwise operator)
  805|       |     * @tparam T integral type
  806|       |     * @param p number to be operated
  807|       |     * @returns value of this & p (& is bit-wise operator)
  808|       |     */
  809|       |    template <typename T, typename = typename std::enable_if<
  810|       |                              std::is_integral<T>::value, T>::type>
  811|  71.2k|    inline uint256_t operator&(const T &p) {
  812|  71.2k|        return *this & uint256_t(p);
  813|  71.2k|    }
  814|       |
  815|       |    /**
  816|       |     * @brief operator & for uint256_t (bitwise operator)
  817|       |     * @param p number to be operated
  818|       |     * @returns value of this & p (& is bit-wise operator)
  819|       |     */
  820|  71.2k|    inline uint256_t operator&(const uint256_t &p) {
  821|  71.2k|        return {f & p.f, s & p.s};
  822|  71.2k|    }
  823|       |
  824|       |    /**
  825|       |     * @brief operator &= for uint256_t (bitwise operator)
  826|       |     * @param p number to be operated
  827|       |     * @returns this = this & p (& is bit-wise operator)
  828|       |     */
  829|      0|    inline uint256_t &operator&=(const uint256_t &p) {
  830|      0|        f &= p.f;
  831|      0|        s &= p.s;
  832|      0|        return *this;
  833|      0|    }
  834|       |
  835|       |    /**
  836|       |     * @brief operator &= for other types (bitwise operator)
  837|       |     * @tparam T integral type
  838|       |     * @param p number to be operated
  839|       |     * @returns this = this & p (& is bit-wise operator)
  840|       |     */
  841|       |    template <typename T, typename = typename std::enable_if<
  842|       |                              std::is_integral<T>::value, T>::type>
  843|       |    inline uint256_t &operator&=(const T p) {
  844|       |        s &= p.s;
  845|       |        return *this;
  846|       |    }
  847|       |
  848|       |    /**
  849|       |     * @brief operator | for other types (bitwise operator)
  850|       |     * @tparam T integral type
  851|       |     * @param p number to be operated
  852|       |     * @returns value of this | p (| is bit-wise operator)
  853|       |     */
  854|       |    template <typename T, typename = typename std::enable_if<
  855|       |                              std::is_integral<T>::value, T>::type>
  856|       |    inline uint256_t operator|(const T &p) {
  857|       |        return *this | uint256_t(p);
  858|       |    }
  859|       |
  860|       |    /**
  861|       |     * @brief operator | for uint256_t (bitwise operator)
  862|       |     * @param p number to be operated
  863|       |     * @returns value of this | p (| is bit-wise OR operator)
  864|       |     */
  865|      2|    inline uint256_t operator|(const uint256_t &p) {
  866|      2|        return {this->f | p.f, this->s | p.s};
  867|      2|    }
  868|       |
  869|       |    /**
  870|       |     * @brief operator |= for other types (bitwise operator)
  871|       |     * @tparam T integral type
  872|       |     * @param p number to be operated
  873|       |     * @returns this = this | p (| is bit-wise OR operator)
  874|       |     */
  875|       |    template <typename T, typename = typename std::enable_if<
  876|       |                              std::is_integral<T>::value, T>::type>
  877|       |    inline uint256_t &operator|=(const T &p) {
  878|       |        s |= p;
  879|       |        return *this;
  880|       |    }
  881|       |
  882|       |    /**
  883|       |     * @brief operator |= for uint256_t (bitwise operator)
  884|       |     * @param p number to be operated
  885|       |     * @returns this = this | p (| is bit-wise OR operator)
  886|       |     */
  887|      0|    inline uint256_t &operator|=(const uint256_t &p) {
  888|      0|        f |= p.f;
  889|      0|        s |= p.s;
  890|      0|        return *this;
  891|      0|    }
  892|       |
  893|       |    /**
  894|       |     * @brief operator ^ for other types (bitwise operator)
  895|       |     * @tparam T integral type
  896|       |     * @param p number to be operated
  897|       |     * @returns value of this ^ p (^ is bit-wise XOR operator)
  898|       |     */
  899|       |    template <typename T, typename = typename std::enable_if<
  900|       |                              std::is_integral<T>::value, T>::type>
  901|       |    inline uint256_t operator^(const T &p) {
  902|       |        return uint256_t(f, s ^ p);
  903|       |    }
  904|       |
  905|       |    /**
  906|       |     * @brief operator ^ for uint256_t (bitwise operator)
  907|       |     * @param p number to be operated
  908|       |     * @returns value of this ^ p (^ is bit-wise XOR operator)
  909|       |     */
  910|      2|    inline uint256_t operator^(const uint256_t &p) {
  911|      2|        return {this->f ^ p.f, this->s ^ p.s};
  912|      2|    }
  913|       |
  914|       |    /**
  915|       |     * @brief operator ^= for uint256_t (bitwise operator)
  916|       |     * @param p number to be operated
  917|       |     * @returns this = this ^ p (^ is bit-wise XOR operator)
  918|       |     */
  919|      0|    inline uint256_t &operator^=(const uint256_t &p) {
  920|      0|        f ^= p.f;
  921|      0|        s ^= p.s;
  922|      0|        return *this;
  923|      0|    }
  924|       |
  925|       |    /**
  926|       |     * @brief operator ^= for other types (bitwise operator)
  927|       |     * @tparam T integral type
  928|       |     * @param p number to be operated
  929|       |     * @returns this = this ^ p (^ is bit-wise XOR operator)
  930|       |     */
  931|       |    template <typename T, typename = typename std::enable_if<
  932|       |                              std::is_integral<T>::value, T>::type>
  933|       |    inline uint256_t &operator^=(const T &p) {
  934|       |        s ^= p;
  935|       |        return *this;
  936|       |    }
  937|       |
  938|       |    /**
  939|       |     * @brief operator << for printing uint256_t integer
  940|       |     * @details Prints the uint256_t integer in decimal form
  941|       |     * @note Note that this operator is costly since it uses strings to print
  942|       |     * the value
  943|       |     * @param op ostream object
  944|       |     * @param p 256-bit integer
  945|       |     * @returns op, ostream object.
  946|       |     */
  947|     10|    friend std::ostream &operator<<(std::ostream &op, uint256_t p) {
  948|     10|        if (!p.f) {
  949|     10|            op << p.s;
  950|     10|        } else {
  951|      0|            std::string out = "0", p_2 = "1";
  952|      0|            uint128_t L(1);
  953|      0|            for (uint64_t i = 0; i < 128; ++i) {
  954|      0|                if ((p.s & L)) {
  955|      0|                    out = add(out, p_2);
  956|      0|                }
  957|      0|                p_2 = add(p_2, p_2);
  958|      0|                L <<= 1;
  959|      0|            }
  960|      0|            L = uint128_t(1);
  961|      0|            for (int i = 0; i < 128; ++i) {
  962|      0|                if ((p.f & L)) {
  963|      0|                    out = add(out, p_2);
  964|      0|                }
  965|      0|                p_2 = add(p_2, p_2);
  966|      0|                L <<= 1;
  967|      0|            }
  968|      0|            op << out;
  969|      0|        }
  970|     10|        return op;
  971|     10|    }
  972|       |};
  973|       |
  974|       |// Artihmetic
  975|       |template <typename T, typename = typename std::enable_if<
  976|       |                          std::is_integral<T>::value, T>::type>
  977|       |inline uint256_t operator+(const T p, const uint256_t &q) {
  978|       |    return uint256_t(p) + q;
  979|       |}
  980|       |
  981|       |template <typename T, typename = typename std::enable_if<
  982|       |                          std::is_integral<T>::value, T>::type>
  983|       |inline uint256_t operator-(const T p, const uint256_t &q) {
  984|       |    return (uint256_t(p) - q);
  985|       |}
  986|       |
  987|       |template <typename T, typename = typename std::enable_if<
  988|       |                          std::is_integral<T>::value, T>::type>
  989|       |inline uint256_t operator*(const T p, const uint256_t &q) {
  990|       |    return uint256_t(p) * q;
  991|       |}
  992|       |
  993|       |template <typename T, typename = typename std::enable_if<
  994|       |                          std::is_integral<T>::value, T>::type>
  995|       |inline uint256_t operator/(const T p, const uint256_t &q) {
  996|       |    return uint256_t(p) / q;
  997|       |}
  998|       |
  999|       |template <typename T, typename = typename std::enable_if<
 1000|       |                          std::is_integral<T>::value, T>::type>
 1001|       |inline uint256_t operator%(const T p, const uint256_t &q) {
 1002|       |    return uint256_t(p) % q;
 1003|       |}
 1004|       |
 1005|       |// Bitwise operators
 1006|       |template <typename T, typename = typename std::enable_if<
 1007|       |                          std::is_integral<T>::value, T>::type>
 1008|       |inline uint256_t operator&(const T &p, const uint256_t &q) {
 1009|       |    return uint256_t(p) & q;
 1010|       |}
 1011|       |
 1012|       |template <typename T, typename = typename std::enable_if<
 1013|       |                          std::is_integral<T>::value, T>::type>
 1014|       |inline uint256_t operator|(const T p, const uint256_t &q) {
 1015|       |    return uint256_t(p) | q;
 1016|       |}
 1017|       |
 1018|       |template <typename T, typename = typename std::enable_if<
 1019|       |                          std::is_integral<T>::value, T>::type>
 1020|       |inline uint256_t operator^(const T p, const uint256_t &q) {
 1021|       |    return uint256_t(p) ^ q;
 1022|       |}
 1023|       |
 1024|       |// Boolean operators
 1025|       |template <typename T, typename = typename std::enable_if<
 1026|       |                          std::is_integral<T>::value, T>::type>
 1027|       |inline bool operator&&(const T p, const uint256_t &q) {
 1028|       |    return uint256_t(p) && q;
 1029|       |}
 1030|       |
 1031|       |template <typename T, typename = typename std::enable_if<
 1032|       |                          std::is_integral<T>::value, T>::type>
 1033|       |inline bool operator||(const T p, const uint256_t &q) {
 1034|       |    return uint256_t(p) || q;
 1035|       |}
 1036|       |
 1037|       |// Comparison operators
 1038|       |template <typename T, typename = typename std::enable_if<
 1039|       |                          std::is_integral<T>::value, T>::type>
 1040|       |inline bool operator==(const T p, const uint256_t &q) {
 1041|       |    return uint256_t(p) == q;
 1042|       |}
 1043|       |
 1044|       |template <typename T, typename = typename std::enable_if<
 1045|       |                          std::is_integral<T>::value, T>::type>
 1046|       |inline bool operator!=(const T p, const uint256_t &q) {
 1047|       |    return uint256_t(p) != q;
 1048|       |}
 1049|       |
 1050|       |template <typename T, typename = typename std::enable_if<
 1051|       |                          std::is_integral<T>::value, T>::type>
 1052|       |inline bool operator<(const T p, const uint256_t &q) {
 1053|       |    return uint256_t(p) < q;
 1054|       |}
 1055|       |
 1056|       |template <typename T, typename = typename std::enable_if<
 1057|       |                          std::is_integral<T>::value, T>::type>
 1058|       |inline bool operator<=(const T p, const uint256_t &q) {
 1059|       |    return uint256_t(p) <= q;
 1060|       |}
 1061|       |
 1062|       |template <typename T, typename = typename std::enable_if<
 1063|       |                          std::is_integral<T>::value, T>::type>
 1064|       |inline bool operator>(const T p, const uint256_t &q) {
 1065|       |    return uint256_t(p) > q;
 1066|       |}
 1067|       |
 1068|       |template <typename T, typename = typename std::enable_if<
 1069|       |                          std::is_integral<T>::value, T>::type>
 1070|       |inline bool operator>=(const T p, const uint256_t &q) {
 1071|       |    return uint256_t(p) >= q;
 1072|       |}
 1073|       |
 1074|       |#endif  // CIPHERS_UINT256_T_HPP_

