    1|       |/**
    2|       | * @brief [Base64 Encoding and
    3|       | * Decoding](https://en.wikipedia.org/wiki/Base64)
    4|       | * @details In programming, [Base64](https://en.wikipedia.org/wiki/Base64) is a
    5|       | * group of binary-to-text encoding schemes that represent binary data (more
    6|       | * specifically, a sequence of 8-bit bytes) in an ASCII string format by
    7|       | * translating the data into a radix-64 representation. The term Base64
    8|       | * originates from a specific MIME content transfer encoding. Each non-final
    9|       | * Base64 digit represents exactly 6 bits of data. Three 8-bit bytes (i.e., a
   10|       | * total of 24 bits) can therefore be represented by four 6-bit Base64
   11|       | * digits.
   12|       | * @author [Ashish Daulatabad](https://github.com/AshishYUO)
   13|       | */
   14|       |#include <array>     /// for `std::array`
   15|       |#include <cassert>   /// for `assert` operations
   16|       |#include <cstdint>
   17|       |#include <iostream>  /// for IO operations
   18|       |
   19|       |/**
   20|       | * @namespace ciphers
   21|       | * @brief Cipher algorithms
   22|       | */
   23|       |namespace ciphers {
   24|       |/**
   25|       | * @namespace base64_encoding
   26|       | * @brief Functions for [Base64 Encoding and
   27|       | * Decoding](https://en.wikipedia.org/wiki/Base64) implementation.
   28|       | */
   29|       |namespace base64_encoding {
   30|       |// chars denoting the format for encoding and decoding array.
   31|       |// This array is already decided by
   32|       |// [RFC4648](https://tools.ietf.org/html/rfc4648#section-4) standard
   33|       |const std::string chars =
   34|       |    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
   35|       |/**
   36|       | * @brief Base64 Encoder
   37|       | * @details Converts the given string to Base64 equivalent.
   38|       | * @param input Input as a string
   39|       | * @returns Base64 encoded string
   40|       | */
   41|      2|std::string base64_encode(const std::string &input) {
   42|      2|    std::string base64_string;  /// Output of this function: base64 string
   43|       |    // base64 deals with 6-bit chars encoded as per chars, so
   44|       |    // we will always filter 6-bits from input.
   45|    114|    for (uint32_t i = 0; i < input.size(); i += 3) {
   46|    112|        char first_byte = input[i];  /// First byte of the iteration
   47|       |        // Take first six bits of first character.
   48|       |        // Encode the first six bits with character defined in string `chars`
   49|    112|        base64_string.push_back(chars[first_byte >> 2]);
   50|       |
   51|    112|        if (i + 1 < input.size()) {
   52|    112|            char second_byte = input[i + 1];  /// Second byte of the iteration
   53|       |            // Take remaining two bits of first character, and four first bits
   54|       |            // from second character Combine two numbers as 6-bit digits and
   55|       |            // encode by array chars (first two bits of first byte and next four
   56|       |            // of second byte)
   57|    112|            base64_string.push_back(
   58|    112|                chars[(((first_byte & 3) << 4) | ((second_byte & 0xF0) >> 4))]);
   59|       |
   60|    112|            if (i + 2 < input.size()) {
   61|    111|                char third_byte = input[i + 2];  /// Third byte of the iteration
   62|       |                // Take remaining four bits of second character, and first two
   63|       |                // bits from third character Combine two numbers as 6-bit digits
   64|       |                // and encode by array chars (remaining four bits of second byte
   65|       |                // and first two of third byte)
   66|    111|                base64_string.push_back(chars[((third_byte & 0xC0) >> 6) |
   67|    111|                                              ((second_byte & 0x0F) << 2)]);
   68|       |                // Encode remaining 6-bit of third byte by array chars
   69|    111|                base64_string.push_back(chars[(third_byte & 0x3F)]);
   70|    111|            } else {
   71|       |                // Take remaining four bits of second character as 6-bit number
   72|      1|                base64_string.push_back(chars[((second_byte & 0x0F) << 2)]);
   73|      1|                base64_string.push_back('=');  // padding characters
   74|      1|            }
   75|    112|        } else {
   76|       |            // Take remaining two bits of first character as 6-bit number
   77|      0|            base64_string.push_back(chars[((first_byte & 3) << 4)]);
   78|      0|            base64_string.push_back('=');  // padding characters
   79|      0|            base64_string.push_back('=');  // padding characters
   80|      0|        }
   81|    112|    }
   82|      2|    return base64_string;
   83|      2|}
   84|       |/**
   85|       | * @brief Utility function for finding index
   86|       | * @details Utility function for finding the position of a character in array
   87|       | * `chars`
   88|       | * @param c character to search in array `chars`
   89|       | * @returns integer denoting position of character in array `chars`
   90|       | */
   91|    670|uint8_t find_idx(const char c) {
   92|    670|    if (c >= 'A' && c <= 'Z') {
   93|    345|        return c - 'A';
   94|    345|    } else if (c >= 'a' && c <= 'z') {
   95|    249|        return c - 'a' + 26;
   96|    249|    } else if (c >= '0' && c <= '9') {
   97|     76|        return c - '0' + 52;
   98|     76|    } else if (c == '+') {
   99|      0|        return 62;
  100|      0|    } else if (c == '/') {
  101|      0|        return 63;
  102|      0|    }
  103|      0|    return -1;
  104|    670|}
  105|       |/**
  106|       | * @brief Base64 Decoder
  107|       | * @details Decodes the Base64 string
  108|       | * @param base64_str Input as a Base64 string
  109|       | * @returns Base64 decoded string
  110|       | */
  111|      2|std::string base64_decode(const std::string &base64_str) {
  112|      2|    std::string
  113|      2|        base64_decoded;  /// Output of this function: base64 decoded string
  114|    114|    for (uint32_t i = 0; i < base64_str.size(); i += 4) {
  115|       |        /// First 6-bit representation of Base64
  116|    112|        char first_byte = base64_str[i];
  117|       |        /// Second 6-bit representation of Base64
  118|    112|        char second_byte = base64_str[i + 1];
  119|       |        // Actual str characters are of 8 bits (or 1 byte):
  120|       |        // :: 8 bits are decode by taking 6 bits from 1st byte of base64 string
  121|       |        // and first 2 bits from 2nd byte of base64 string.
  122|    112|        char first_actual_byte = static_cast<char>(
  123|    112|            (find_idx(first_byte) << 2) | ((find_idx(second_byte)) >> 4));
  124|    112|        base64_decoded.push_back(first_actual_byte);
  125|    112|        if (i + 2 < base64_str.size() && base64_str[i + 2] != '=') {
  126|       |            /// Third 6-bit representation of Base64
  127|    112|            char third_byte = base64_str[i + 2];
  128|       |            // :: Next 8 bits are decode by taking remaining 4 bits from 2nd
  129|       |            // byte of base64 string and first 4 bits from 3rd byte of base64
  130|       |            // string.
  131|    112|            char second_actual_byte =
  132|    112|                static_cast<char>(((find_idx(second_byte) & 0x0F) << 4) |
  133|    112|                                  (find_idx(third_byte) >> 2));
  134|    112|            base64_decoded.push_back(second_actual_byte);
  135|       |
  136|    112|            if (i + 3 < base64_str.size() && base64_str[i + 3] != '=') {
  137|       |                /// Fourth 6-bit representation of Base64 string
  138|    111|                char fourth_byte = base64_str[i + 3];
  139|       |                // :: Taking remaining 2 bits from 3rd byte of base64 string
  140|       |                // and all 6 bits from 4th byte of base64 string.
  141|    111|                char third_actual_byte =
  142|    111|                    static_cast<char>(((find_idx(third_byte) & 0x03) << 6) |
  143|    111|                                      find_idx(fourth_byte));
  144|    111|                base64_decoded.push_back(third_actual_byte);
  145|    111|            }
  146|    112|        }
  147|    112|    }
  148|      2|    return base64_decoded;
  149|      2|}
  150|       |}  // namespace base64_encoding
  151|       |}  // namespace ciphers
  152|       |
  153|       |/**
  154|       | * @brief Self test-implementations
  155|       | * @returns void
  156|       | */
  157|      1|static void test() {
  158|       |    // 1st Test
  159|      1|    std::string str =
  160|      1|        "To err is human, but to really foul things up you need a computer.";
  161|      1|    std::string base64_str = ciphers::base64_encoding::base64_encode(str);
  162|      1|    std::string verify =
  163|      1|        "VG8gZXJyIGlzIGh1bWFuLCBidXQgdG8gcmVhbGx5IGZvdWwgdGhpbmdzIHVwIHlvdSBuZW"
  164|      1|        "VkIGEgY29tcHV0ZXIu";
  165|       |    // verify encoding
  166|      1|    assert(base64_str == verify);
  167|      0|    std::string original_str =
  168|      1|        ciphers::base64_encoding::base64_decode(base64_str);
  169|       |    // verify decoding
  170|      1|    assert(original_str == str);
  171|       |
  172|       |    // 2nd Test from [Wikipedia](https://en.wikipedia.org/wiki/Base64)
  173|      0|    str =
  174|      1|        "Man is distinguished, not only by his reason, but by this singular "
  175|      1|        "passion from other animals, which is a lust of the mind, that by a "
  176|      1|        "perseverance of delight in the continued and indefatigable generation "
  177|      1|        "of knowledge, exceeds the short vehemence of any carnal pleasure.";
  178|       |
  179|      1|    base64_str = ciphers::base64_encoding::base64_encode(str);
  180|      1|    verify =
  181|      1|        "TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieS"
  182|      1|        "B0aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBh"
  183|      1|        "IGx1c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodC"
  184|      1|        "BpbiB0aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25v"
  185|      1|        "d2xlZGdlLCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbG"
  186|      1|        "Vhc3VyZS4=";
  187|       |    // verify encoding
  188|      1|    assert(base64_str == verify);
  189|      0|    original_str = ciphers::base64_encoding::base64_decode(base64_str);
  190|       |    // verify decoding
  191|      1|    assert(original_str == str);
  192|      1|}
  193|       |
  194|       |/**
  195|       | * @brief Main function
  196|       | * @returns 0 on exit
  197|       | */
  198|      1|int main() {
  199|      1|    test();  // run self-test implementations
  200|      1|    return 0;
  201|      1|}

