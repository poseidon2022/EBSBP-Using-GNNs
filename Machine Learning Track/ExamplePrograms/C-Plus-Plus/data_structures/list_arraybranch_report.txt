    1|       |/**
    2|       | * @file
    3|       | * @brief [Dynamic Array](https://en.wikipedia.org/wiki/Dynamic_array)
    4|       | *
    5|       | * @details
    6|       | * The list_array is the implementation of list represented using array.
    7|       | * We can perform basic CRUD operations as well as other operations like sorting
    8|       | * etc.
    9|       | *
   10|       | * ### Algorithm
   11|       | * It implements various method like insert, sort, search etc. efficiently.
   12|       | * You can select the operation and methods will do the rest work for you.
   13|       | * You can insert element, sort them in order, search efficiently, delete values
   14|       | * and print the list.
   15|       | */
   16|       |
   17|       |#include <array>     /// for std::array
   18|       |#include <cassert>   /// for assert
   19|       |#include <cstdint>
   20|       |#include <iostream>  /// for io operations
   21|       |
   22|       |/**
   23|       | * @namespace data_structures
   24|       | * @brief Algorithms with data structures
   25|       | */
   26|       |namespace data_structures {
   27|       |/**
   28|       | * @namespace list_array
   29|       | * @brief Functions for [Dynamic
   30|       | * Array](https://en.wikipedia.org/wiki/Dynamic_array) algorithm
   31|       | */
   32|       |namespace list_array {
   33|       |/**
   34|       | * @brief Structure of List with supporting methods.
   35|       | */
   36|       |template <uint64_t N>
   37|       |struct list {
   38|       |    std::array<uint64_t, N> data{};  // Array that implement list
   39|       |    uint64_t top = 0;                // Pointer to the last element
   40|       |    bool isSorted = false;           // indicator whether list is sorted or not
   41|       |    /**
   42|       |     * @brief Search an element in the list using binarySearch.
   43|       |     * @param dataArr list
   44|       |     * @param first pointer to the first element in the remaining list
   45|       |     * @param last pointer to the last element in the remaining list
   46|       |     * @param val element that will be searched
   47|       |     * @return index of element in the list if present else -1
   48|       |     */
   49|       |    uint64_t BinarySearch(const std::array<uint64_t, N> &dataArr,
   50|       |                          const uint64_t &first, const uint64_t &last,
   51|      8|                          const uint64_t &val) {
   52|       |        // If both pointer cross each other means no element present in the list
   53|       |        // which is equal to the val
   54|      8|        if (last < first) {
   55|      1|            return -1;
   56|      1|        }
   57|      7|        uint64_t mid = (first + last) / 2;
   58|       |        // check whether current mid pointer value is equal to element or not
   59|      7|        if (dataArr[mid] == val)
   60|      2|            return mid;
   61|       |        // if current mid value is greater than  element we have to search in
   62|       |        // first half
   63|      5|        else if (val < dataArr[mid])
   64|      1|            return (BinarySearch(dataArr, first, mid - 1, val));
   65|       |        // if current mid value is greater than  element we have to search in
   66|       |        // second half
   67|      4|        else if (val > dataArr[mid])
   68|      4|            return (BinarySearch(dataArr, mid + 1, last, val));
   69|       |
   70|      0|        std::cerr << __func__ << ":" << __LINE__ << ": Undefined condition\n";
   71|      0|        return -1;
   72|      7|    }
   73|       |
   74|       |    /**
   75|       |     * @brief Search an element using linear search
   76|       |     * @param dataArr list
   77|       |     * @param val element that will be searched
   78|       |     * @return index of element in the list if present else -1
   79|       |     */
   80|       |    uint64_t LinearSearch(const std::array<uint64_t, N> &dataArr,
   81|      6|                          const uint64_t &val) const {
   82|       |        // Going through each element in the list
   83|     20|        for (uint64_t i = 0; i < top; i++) {
   84|     18|            if (dataArr[i] == val) {
   85|      4|                return i;  // element found at ith index
   86|      4|            }
   87|     18|        }
   88|       |        // element is not present in the list
   89|      2|        return -1;
   90|      6|    }
   91|       |
   92|       |    /*
   93|       |     * @brief Parent function of binarySearch and linearSearch methods
   94|       |     * @param val element that will be searched
   95|       |     * @return index of element in the list if present else -1
   96|       |     */
   97|      9|    uint64_t search(const uint64_t &val) {
   98|      9|        uint64_t pos;  // pos variable to store index value of element.
   99|       |        // if list is sorted, binary search works efficiently else linear search
  100|       |        // is the only option
  101|      9|        if (isSorted) {
  102|      3|            pos = BinarySearch(data, 0, top - 1, val);
  103|      6|        } else {
  104|      6|            pos = LinearSearch(data, val);
  105|      6|        }
  106|       |        // if index is equal to -1 means element does not present
  107|       |        // else print the index of that element
  108|      9|        if (pos != -1) {
  109|      6|            std::cout << "\nElement found at position : " << pos;
  110|      6|        } else {
  111|      3|            std::cout << "\nElement not found";
  112|      3|        }
  113|       |        // return the index of element or -1.
  114|      9|        return pos;
  115|      9|    }
  116|       |
  117|       |    /**
  118|       |     * @brief Sort the list
  119|       |     * @returns void
  120|       |     */
  121|      1|    void sort() {
  122|       |        // Going through each element in the list
  123|      6|        for (uint64_t i = 0; i < top; i++) {
  124|      5|            uint64_t min_idx = i;  // Initialize the min variable
  125|     15|            for (uint64_t j = i + 1; j < top; j++) {
  126|       |                // check whether any element less than current min value
  127|     10|                if (data[j] < data[min_idx]) {
  128|      2|                    min_idx = j;  // update index accordingly
  129|      2|                }
  130|     10|            }
  131|       |            // swap min value and element at the ith index
  132|      5|            std::swap(data[min_idx], data[i]);
  133|      5|        }
  134|       |        // mark isSorted variable as true
  135|      1|        isSorted = true;
  136|      1|    }
  137|       |
  138|       |    /**
  139|       |     * @brief Insert the new element in the list
  140|       |     * @param val element that will be inserted
  141|       |     * @returns void
  142|       |     */
  143|      7|    void insert(const uint64_t &val) {
  144|       |        // overflow check
  145|      7|        if (top == N) {
  146|      0|            std::cout << "\nOverflow";
  147|      0|            return;
  148|      0|        }
  149|       |        // if list is not sorted, insert at the last
  150|       |        // otherwise place it to correct position
  151|      7|        if (!isSorted) {
  152|      7|            data[top] = val;
  153|      7|            top++;
  154|      7|        } else {
  155|      0|            uint64_t pos = 0;  // Initialize the index variable
  156|       |            // Going through each element and find correct position for element
  157|      0|            for (uint64_t i = 0; i < top - 1; i++) {
  158|       |                // check for the correct position
  159|      0|                if (data[i] <= val && val <= data[i + 1]) {
  160|      0|                    pos = i + 1;  // assign correct pos to the index var
  161|      0|                    break;        // to get out from the loop
  162|      0|                }
  163|      0|            }
  164|       |            // if all elements are smaller than the element
  165|      0|            if (pos == 0) {
  166|      0|                pos = top - 1;
  167|      0|            }
  168|       |            // shift all element to make a room for new element
  169|      0|            for (uint64_t i = top; i > pos; i--) {
  170|      0|                data[i] = data[i - 1];
  171|      0|            }
  172|      0|            top++;  // Increment the value of top.
  173|      0|            data[pos] =
  174|      0|                val;  // Assign the value to the correct index in the array
  175|      0|        }
  176|      7|    }
  177|       |
  178|       |    /**
  179|       |     * @brief To remove the element from the list
  180|       |     * @param val element that will be removed
  181|       |     * @returns void
  182|       |     */
  183|      3|    void remove(const uint64_t &val) {
  184|      3|        uint64_t pos = search(val);  // search the index of the value
  185|       |        // if search returns -1, element does not present in the list
  186|      3|        if (pos == -1) {
  187|      1|            std::cout << "\n Element does not present in the list ";
  188|      1|            return;
  189|      1|        }
  190|      2|        std::cout << "\n"
  191|      2|                  << data[pos] << " deleted";  // print the appropriate message
  192|       |        // shift all the element 1 left to fill vacant space
  193|     13|        for (uint64_t i = pos; i < top; i++) {
  194|     11|            data[i] = data[i + 1];
  195|     11|        }
  196|      2|        top--;  // decrement the top variable to maintain last index
  197|      2|    }
  198|       |
  199|       |    /**
  200|       |     * @brief Utility function to print array
  201|       |     * @returns void
  202|       |     */
  203|      2|    void show() {
  204|       |        // Going through each element in the list
  205|      2|        std::cout << '\n';
  206|     14|        for (uint64_t i = 0; i < top; i++) {
  207|     12|            std::cout << data[i] << " ";  // print the element
  208|     12|        }
  209|      2|    }
  210|       |};  // structure list
  211|       |}  // namespace list_array
  212|       |}  // namespace data_structures
  213|       |
  214|       |/**
  215|       | * @brief Test implementations
  216|       | * @returns void
  217|       | */
  218|      1|static void test() {
  219|      1|    data_structures::list_array::list<50> L;
  220|       |
  221|       |    // Insert testing
  222|      1|    L.insert(11);
  223|      1|    L.insert(12);
  224|      1|    assert(L.top == 2);
  225|      0|    L.insert(15);
  226|      1|    L.insert(10);
  227|      1|    L.insert(12);
  228|      1|    L.insert(20);
  229|      1|    L.insert(18);
  230|      1|    assert(L.top == 7);
  231|      0|    L.show();  // To print the array
  232|       |
  233|       |    // Remove testing
  234|      1|    L.remove(12);  // Remove Duplicate value in the list
  235|      1|    L.remove(15);  // Remove the existing value in the list
  236|      1|    assert(L.top == 5);
  237|      0|    L.remove(50);  // Try to remove the non-existing value in the list
  238|      1|    assert(L.top == 5);
  239|       |
  240|       |    // LinearSearch testing
  241|      0|    assert(L.search(11) == 0);  // search for the existing element
  242|      0|    assert(L.search(12) == 2);
  243|      0|    assert(L.search(50) == -1);  // search for the non-existing element
  244|       |
  245|       |    // Sort testing
  246|      0|    L.sort();
  247|      1|    assert(L.isSorted == true);
  248|      0|    L.show();
  249|       |
  250|       |    // BinarySearch testing
  251|      1|    assert(L.search(11) == 1);  // search for the existing element
  252|      0|    assert(L.search(12) == 2);
  253|      0|    assert(L.search(50) == -1);  // search for the non-existing element
  254|      1|}
  255|       |
  256|       |/**
  257|       | * @brief Main function
  258|       | * @returns 0 on exit
  259|       | */
  260|      1|int main() {
  261|      1|    test();  // Execute the tests
  262|      1|    return 0;
  263|      1|}

