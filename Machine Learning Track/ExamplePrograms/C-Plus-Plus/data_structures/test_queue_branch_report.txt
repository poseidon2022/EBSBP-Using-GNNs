/home/kidus/Desktop/GNNs/ExamplePrograms/C-Plus-Plus/data_structures/node.hpp:
    1|       |/**
    2|       | * @file
    3|       | * @brief  Provides Node class and related utilities
    4|       | **/
    5|       |#ifndef DATA_STRUCTURES_NODE_HPP_
    6|       |#define DATA_STRUCTURES_NODE_HPP_
    7|       |
    8|       |#include <iostream>  /// for std::cout
    9|       |#include <memory>    /// for std::shared_ptr
   10|       |#include <vector>    /// for std::vector
   11|       |
   12|       |/** Definition of the node as a linked-list
   13|       | * \tparam ValueType type of data nodes of the linked list should contain
   14|       | */
   15|       |template <class ValueType>
   16|       |struct Node {
   17|       |    using value_type = ValueType;
   18|       |    ValueType data = {};
   19|       |    std::shared_ptr<Node<ValueType>> next = {};
   20|       |};
   21|       |
   22|       |template <typename Node, typename Action>
   23|     15|void traverse(const Node* const inNode, const Action& action) {
   24|     15|    if (inNode) {
   25|     10|        action(*inNode);
   26|     10|        traverse(inNode->next.get(), action);
   27|     10|    }
   28|     15|}
   29|       |
   30|       |template <typename Node>
   31|       |void display_all(const Node* const inNode) {
   32|       |    traverse(inNode,
   33|       |             [](const Node& curNode) { std::cout << curNode.data << " "; });
   34|       |}
   35|       |
   36|       |template <typename Node>
   37|       |std::vector<typename Node::value_type> push_all_to_vector(
   38|      5|    const Node* const inNode, const std::size_t expected_size = 0) {
   39|      5|    std::vector<typename Node::value_type> res;
   40|      5|    res.reserve(expected_size);
   41|      5|    traverse(inNode,
   42|     10|             [&res](const Node& curNode) { res.push_back(curNode.data); });
   43|      5|    return res;
   44|      5|}
   45|       |
   46|       |#endif  // DATA_STRUCTURES_NODE_HPP_

/home/kidus/Desktop/GNNs/ExamplePrograms/C-Plus-Plus/data_structures/queue.hpp:
    1|       |/* This class specifies the basic operation on a queue as a linked list */
    2|       |#ifndef DATA_STRUCTURES_QUEUE_HPP_
    3|       |#define DATA_STRUCTURES_QUEUE_HPP_
    4|       |
    5|       |#include "node.hpp"
    6|       |
    7|       |/** Definition of the queue class */
    8|       |template <class ValueType>
    9|       |class queue {
   10|       |    using node_type = Node<ValueType>;
   11|       |
   12|       | public:
   13|       |    using value_type = ValueType;
   14|       |    /**
   15|       |     * @brief prints the queue into the std::cout
   16|       |     */
   17|       |    void display() const {
   18|       |        std::cout << "Front --> ";
   19|       |        display_all(this->queueFront.get());
   20|       |        std::cout << '\n';
   21|       |        std::cout << "Size of queue: " << size << '\n';
   22|       |    }
   23|       |
   24|       |    /**
   25|       |     * @brief converts the queue into the std::vector
   26|       |     * @return std::vector containning all of the elements of the queue in the
   27|       |     * same order
   28|       |     */
   29|      5|    std::vector<value_type> toVector() const {
   30|      5|        return push_all_to_vector(this->queueFront.get(), this->size);
   31|      5|    }
   32|       |
   33|       | private:
   34|       |    /**
   35|       |     * @brief throws an exception if queue is empty
   36|       |     * @exception std::invalid_argument if queue is empty
   37|       |     */
   38|      5|    void ensureNotEmpty() const {
   39|      5|        if (isEmptyQueue()) {
   40|      2|            throw std::invalid_argument("Queue is empty.");
   41|      2|        }
   42|      5|    }
   43|       |
   44|       | public:
   45|       |    /**
   46|       |     * @brief checks if the queue has no elements
   47|       |     * @return true if the queue is empty, false otherwise
   48|       |     */
   49|     20|    bool isEmptyQueue() const { return (queueFront == nullptr); }
  ------------------
  | _ZNK5queueIiE12isEmptyQueueEv:
  |   49|     18|    bool isEmptyQueue() const { return (queueFront == nullptr); }
  ------------------
  | _ZNK5queueIdE12isEmptyQueueEv:
  |   49|      1|    bool isEmptyQueue() const { return (queueFront == nullptr); }
  ------------------
  | _ZNK5queueISt6vectorIeSaIeEEE12isEmptyQueueEv:
  |   49|      1|    bool isEmptyQueue() const { return (queueFront == nullptr); }
  ------------------
   50|       |
   51|       |    /**
   52|       |     * @brief inserts a new item into the queue
   53|       |     */
   54|     10|    void enQueue(const value_type& item) {
   55|     10|        auto newNode = std::make_shared<node_type>();
   56|     10|        newNode->data = item;
   57|     10|        newNode->next = nullptr;
   58|     10|        if (isEmptyQueue()) {
   59|      3|            queueFront = newNode;
   60|      3|            queueRear = newNode;
   61|      7|        } else {
   62|      7|            queueRear->next = newNode;
   63|      7|            queueRear = queueRear->next;
   64|      7|        }
   65|     10|        ++size;
   66|     10|    }
   67|       |
   68|       |    /**
   69|       |     * @return the first element of the queue
   70|       |     * @exception std::invalid_argument if queue is empty
   71|       |     */
   72|      1|    value_type front() const {
   73|      1|        ensureNotEmpty();
   74|      1|        return queueFront->data;
   75|      1|    }
   76|       |
   77|       |    /**
   78|       |     * @brief removes the first element from the queue
   79|       |     * @exception std::invalid_argument if queue is empty
   80|       |     */
   81|      4|    void deQueue() {
   82|      4|        ensureNotEmpty();
   83|      4|        queueFront = queueFront->next;
   84|      4|        --size;
   85|      4|    }
   86|       |
   87|       |    /**
   88|       |     * @brief removes all elements from the queue
   89|       |     */
   90|      1|    void clear() {
   91|      1|        queueFront = nullptr;
   92|      1|        queueRear = nullptr;
   93|      1|        size = 0;
   94|      1|    }
   95|       |
   96|       | private:
   97|       |    std::shared_ptr<node_type> queueFront =
   98|       |        {}; /**< Pointer to the front of the queue */
   99|       |    std::shared_ptr<node_type> queueRear =
  100|       |        {}; /**< Pointer to the rear of the queue  */
  101|       |    std::size_t size = 0;
  102|       |};
  103|       |
  104|       |#endif  // DATA_STRUCTURES_QUEUE_HPP_

/home/kidus/Desktop/GNNs/ExamplePrograms/C-Plus-Plus/data_structures/test_queue.cpp:
    1|       |#include <cassert>   /// for assert
    2|       |#include <iostream>  /// for std::cout
    3|       |
    4|       |#include "./queue.hpp"
    5|       |
    6|       |template <typename T>
    7|      3|void testConstructedQueueIsEmpty() {
    8|      3|    const queue<T> curQueue;
    9|      3|    assert(curQueue.isEmptyQueue());
   10|      3|}
  ------------------
  | _Z27testConstructedQueueIsEmptyIiEvv:
  |    7|      1|void testConstructedQueueIsEmpty() {
  |    8|      1|    const queue<T> curQueue;
  |    9|      1|    assert(curQueue.isEmptyQueue());
  |   10|      1|}
  ------------------
  | _Z27testConstructedQueueIsEmptyIdEvv:
  |    7|      1|void testConstructedQueueIsEmpty() {
  |    8|      1|    const queue<T> curQueue;
  |    9|      1|    assert(curQueue.isEmptyQueue());
  |   10|      1|}
  ------------------
  | _Z27testConstructedQueueIsEmptyISt6vectorIeSaIeEEEvv:
  |    7|      1|void testConstructedQueueIsEmpty() {
  |    8|      1|    const queue<T> curQueue;
  |    9|      1|    assert(curQueue.isEmptyQueue());
  |   10|      1|}
  ------------------
   11|       |
   12|      1|void testEnQueue() {
   13|      1|    queue<int> curQueue;
   14|      1|    curQueue.enQueue(10);
   15|      1|    assert(curQueue.toVector() == std::vector<int>({10}));
   16|      0|    curQueue.enQueue(20);
   17|      1|    assert(curQueue.toVector() == std::vector<int>({10, 20}));
   18|      0|    curQueue.enQueue(30);
   19|      1|    curQueue.enQueue(40);
   20|      1|    assert(curQueue.toVector() == std::vector<int>({10, 20, 30, 40}));
   21|      1|}
   22|       |
   23|      1|void testDeQueue() {
   24|      1|    queue<int> curQueue;
   25|      1|    curQueue.enQueue(10);
   26|      1|    curQueue.enQueue(20);
   27|      1|    curQueue.enQueue(30);
   28|       |
   29|      1|    curQueue.deQueue();
   30|      1|    assert(curQueue.toVector() == std::vector<int>({20, 30}));
   31|       |
   32|      0|    curQueue.deQueue();
   33|      1|    assert(curQueue.toVector() == std::vector<int>({30}));
   34|       |
   35|      0|    curQueue.deQueue();
   36|      1|    assert(curQueue.isEmptyQueue());
   37|      1|}
   38|       |
   39|      0|void testFront() {
   40|      0|    queue<int> curQueue;
   41|      0|    curQueue.enQueue(10);
   42|      0|    assert(curQueue.front() == 10);
   43|      0|    curQueue.enQueue(20);
   44|      0|    assert(curQueue.front() == 10);
   45|      0|}
   46|       |
   47|      1|void testQueueAfterClearIsEmpty() {
   48|      1|    queue<int> curQueue;
   49|      1|    curQueue.enQueue(10);
   50|      1|    curQueue.enQueue(20);
   51|      1|    curQueue.enQueue(30);
   52|      1|    curQueue.clear();
   53|      1|    assert(curQueue.isEmptyQueue());
   54|      1|}
   55|       |
   56|      1|void testFrontThrowsAnInvalidArgumentWhenQueueEmpty() {
   57|      1|    const queue<int> curQueue;
   58|      1|    bool wasException = false;
   59|      1|    try {
   60|      1|        curQueue.front();
   61|      1|    } catch (const std::invalid_argument&) {
   62|      1|        wasException = true;
   63|      1|    }
   64|      1|    assert(wasException);
   65|      1|}
   66|       |
   67|      1|void testDeQueueThrowsAnInvalidArgumentWhenQueueEmpty() {
   68|      1|    queue<int> curQueue;
   69|      1|    bool wasException = false;
   70|      1|    try {
   71|      1|        curQueue.deQueue();
   72|      1|    } catch (const std::invalid_argument&) {
   73|      1|        wasException = true;
   74|      1|    }
   75|      1|    assert(wasException);
   76|      1|}
   77|       |
   78|      1|int main() {
   79|      1|    testConstructedQueueIsEmpty<int>();
   80|      1|    testConstructedQueueIsEmpty<double>();
   81|      1|    testConstructedQueueIsEmpty<std::vector<long double>>();
   82|       |
   83|      1|    testEnQueue();
   84|      1|    testDeQueue();
   85|       |
   86|      1|    testQueueAfterClearIsEmpty();
   87|       |
   88|      1|    testFrontThrowsAnInvalidArgumentWhenQueueEmpty();
   89|      1|    testDeQueueThrowsAnInvalidArgumentWhenQueueEmpty();
   90|       |
   91|      1|    std::cout << "All tests pass!\n";
   92|      1|    return 0;
   93|      1|}

