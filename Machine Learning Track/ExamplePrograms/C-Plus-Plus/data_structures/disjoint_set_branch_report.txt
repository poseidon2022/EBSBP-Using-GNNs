    1|       |/**
    2|       | *
    3|       | * \file
    4|       | * \brief [Disjoint Sets Data Structure
    5|       | * (Disjoint Sets)](https://en.wikipedia.org/wiki/Disjoint-set_data_structure)
    6|       | *
    7|       | * \author [leoyang429](https://github.com/leoyang429)
    8|       | *
    9|       | * \details
   10|       | * A disjoint set data structure (also called union find or merge find set)
   11|       | * is a data structure that tracks a set of elements partitioned into a number
   12|       | * of disjoint (non-overlapping) subsets.
   13|       | * Some situations where disjoint sets can be used are-
   14|       | * to find connected components of a graph, kruskal's algorithm for finding
   15|       | * Minimum Spanning Tree etc.
   16|       | * There are two operation which we perform on disjoint sets -
   17|       | * 1) Union
   18|       | * 2) Find
   19|       | *
   20|       | */
   21|       |
   22|       |#include <iostream>
   23|       |#include <vector>
   24|       |
   25|       |using std::cout;
   26|       |using std::endl;
   27|       |using std::vector;
   28|       |
   29|       |vector<int> root, rank;
   30|       |
   31|       |/**
   32|       | *
   33|       | * Function to create a set
   34|       | * @param n number of element
   35|       | *
   36|       | */
   37|      1|void CreateSet(int n) {
   38|      1|    root = vector<int>(n + 1);
   39|      1|    rank = vector<int>(n + 1, 1);
   40|    101|    for (int i = 1; i <= n; ++i) {
   41|    100|        root[i] = i;
   42|    100|    }
   43|      1|}
   44|       |
   45|       |/**
   46|       | *
   47|       | * Find operation takes a number x and returns the set to which this number
   48|       | * belongs to.
   49|       | * @param x element of some set
   50|       | * @return set to which x belongs to
   51|       | *
   52|       | */
   53|      7|int Find(int x) {
   54|      7|    if (root[x] == x) {
   55|      6|        return x;
   56|      6|    }
   57|      1|    return root[x] = Find(root[x]);
   58|      7|}
   59|       |
   60|       |/**
   61|       | *
   62|       | * A utility function to check if x and y are from same set or not
   63|       | * @param x element of some set
   64|       | * @param y element of some set
   65|       | *
   66|       | */
   67|      2|bool InSameUnion(int x, int y) { return Find(x) == Find(y); }
   68|       |
   69|       |/**
   70|       | *
   71|       | * Union operation combines two disjoint sets to make a single set
   72|       | * in this union function we pass two elements and check if they are
   73|       | * from different sets then combine those sets
   74|       | * @param x element of some set
   75|       | * @param y element of some set
   76|       | *
   77|       | */
   78|      1|void Union(int x, int y) {
   79|      1|    int a = Find(x), b = Find(y);
   80|      1|    if (a != b) {
   81|      1|        if (rank[a] < rank[b]) {
   82|      0|            root[a] = b;
   83|      1|        } else if (rank[a] > rank[b]) {
   84|      0|            root[b] = a;
   85|      1|        } else {
   86|      1|            root[a] = b;
   87|      1|            ++rank[b];
   88|      1|        }
   89|      1|    }
   90|      1|}
   91|       |
   92|       |/** Main function */
   93|      1|int main() {
   94|       |    // tests CreateSet & Find
   95|      1|    int n = 100;
   96|      1|    CreateSet(n);
   97|    101|    for (int i = 1; i <= 100; ++i) {
   98|    100|        if (root[i] != i) {
   99|      0|            cout << "Fail" << endl;
  100|      0|            break;
  101|      0|        }
  102|    100|    }
  103|       |    // tests InSameUnion & Union
  104|      1|    cout << "1 and 2 are initially not in the same subset" << endl;
  105|      1|    if (InSameUnion(1, 2)) {
  106|      0|        cout << "Fail" << endl;
  107|      0|    }
  108|      1|    Union(1, 2);
  109|      1|    cout << "1 and 2 are now in the same subset" << endl;
  110|      1|    if (!InSameUnion(1, 2)) {
  111|      0|        cout << "Fail" << endl;
  112|      0|    }
  113|      1|    return 0;
  114|      1|}

