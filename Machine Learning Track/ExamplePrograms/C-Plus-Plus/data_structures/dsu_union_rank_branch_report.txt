    1|       |/**
    2|       | * @file
    3|       | * @brief [DSU (Disjoint
    4|       | * sets)](https://en.wikipedia.org/wiki/Disjoint-set-data_structure)
    5|       | * @details
    6|       | * dsu : It is a very powerful data structure which keeps track of different
    7|       | * clusters(sets) of elements, these sets are disjoint(doesnot have a common
    8|       | * element). Disjoint sets uses cases : for finding connected components in a
    9|       | * graph, used in Kruskal's algorithm for finding Minimum Spanning tree.
   10|       | * Operations that can be performed:
   11|       | * 1) UnionSet(i,j): add(element i and j to the set)
   12|       | * 2) findSet(i): returns the representative of the set to which i belogngs to.
   13|       | * 3) getParents(i): prints the parent of i and so on and so forth.
   14|       | * Below is the class-based approach which uses the heuristic of union-ranks.
   15|       | * Using union-rank in findSet(i),we are able to get to the representative of i
   16|       | * in slightly delayed O(logN) time but it allows us to keep tracks of the
   17|       | * parent of i.
   18|       | * @author [AayushVyasKIIT](https://github.com/AayushVyasKIIT)
   19|       | * @see dsu_path_compression.cpp
   20|       | */
   21|       |
   22|       |#include <cassert>   /// for assert
   23|       |#include <cstdint>
   24|       |#include <iostream>  /// for IO operations
   25|       |#include <vector>    /// for std::vector
   26|       |
   27|       |using std::cout;
   28|       |using std::endl;
   29|       |using std::vector;
   30|       |
   31|       |/**
   32|       | * @brief Disjoint sets union data structure, class based representation.
   33|       | * @param n number of elements
   34|       | */
   35|       |class dsu {
   36|       | private:
   37|       |    vector<uint64_t> p;        ///< keeps track of the parent of ith element
   38|       |    vector<uint64_t> depth;    ///< tracks the depth(rank) of i in the tree
   39|       |    vector<uint64_t> setSize;  ///< size of each chunk(set)
   40|       | public:
   41|       |    /**
   42|       |     * @brief constructor for initialising all data members
   43|       |     * @param n number of elements
   44|       |     */
   45|      2|    explicit dsu(uint64_t n) {
   46|      2|        p.assign(n, 0);
   47|       |        /// initially all of them are their own parents
   48|      2|        depth.assign(n, 0);
   49|      2|        setSize.assign(n, 0);
   50|     24|        for (uint64_t i = 0; i < n; i++) {
   51|     22|            p[i] = i;
   52|     22|            depth[i] = 0;
   53|     22|            setSize[i] = 1;
   54|     22|        }
   55|      2|    }
   56|       |    /**
   57|       |     * @brief Method to find the representative of the set to which i belongs
   58|       |     * to, T(n) = O(logN)
   59|       |     * @param i element of some set
   60|       |     * @returns representative of the set to which i belongs to
   61|       |     */
   62|     64|    uint64_t findSet(uint64_t i) {
   63|       |        /// using union-rank
   64|     68|        while (i != p[i]) {
   65|      4|            i = p[i];
   66|      4|        }
   67|     64|        return i;
   68|     64|    }
   69|       |    /**
   70|       |     * @brief Method that combines two disjoint sets to which i and j belongs to
   71|       |     * and make a single set having a common representative.
   72|       |     * @param i element of some set
   73|       |     * @param j element of some set
   74|       |     * @returns void
   75|       |     */
   76|     16|    void unionSet(uint64_t i, uint64_t j) {
   77|       |        /// checks if both belongs to same set or not
   78|     16|        if (isSame(i, j)) {
   79|      0|            return;
   80|      0|        }
   81|       |        /// we find representative of the i and j
   82|     16|        uint64_t x = findSet(i);
   83|     16|        uint64_t y = findSet(j);
   84|       |
   85|       |        /// always keeping the min as x
   86|       |        /// in order to create a shallow tree
   87|     16|        if (depth[x] > depth[y]) {
   88|      6|            std::swap(x, y);
   89|      6|        }
   90|       |        /// making the shallower tree, root parent of the deeper root
   91|     16|        p[x] = y;
   92|       |
   93|       |        /// if same depth, then increase one's depth
   94|     16|        if (depth[x] == depth[y]) {
   95|      8|            depth[y]++;
   96|      8|        }
   97|       |        /// total size of the resultant set
   98|     16|        setSize[y] += setSize[x];
   99|     16|    }
  100|       |    /**
  101|       |     * @brief A utility function which check whether i and j belongs to same set
  102|       |     * or not
  103|       |     * @param i element of some set
  104|       |     * @param j element of some set
  105|       |     * @returns `true` if element i and j are in same set
  106|       |     * @returns `false` if element i and j are not in same set
  107|       |     */
  108|     16|    bool isSame(uint64_t i, uint64_t j) {
  109|     16|        if (findSet(i) == findSet(j)) {
  110|      0|            return true;
  111|      0|        }
  112|     16|        return false;
  113|     16|    }
  114|       |    /**
  115|       |     * @brief Method to print all the parents of i, or the path from i to
  116|       |     * representative.
  117|       |     * @param i element of some set
  118|       |     * @returns void
  119|       |     */
  120|      5|    vector<uint64_t> getParents(uint64_t i) {
  121|      5|        vector<uint64_t> ans;
  122|     13|        while (p[i] != i) {
  123|      8|            ans.push_back(i);
  124|      8|            i = p[i];
  125|      8|        }
  126|      5|        ans.push_back(i);
  127|      5|        return ans;
  128|      5|    }
  129|       |};
  130|       |/**
  131|       | * @brief Self-implementations, 1st test
  132|       | * @returns void
  133|       | */
  134|      1|static void test1() {
  135|       |    /* checks the parents in the resultant structures */
  136|      1|    uint64_t n = 10;   ///< number of elements
  137|      1|    dsu d(n + 1);      ///< object of class disjoint sets
  138|      1|    d.unionSet(2, 1);  ///< performs union operation on 1 and 2
  139|      1|    d.unionSet(1, 4);
  140|      1|    d.unionSet(8, 1);
  141|      1|    d.unionSet(3, 5);
  142|      1|    d.unionSet(5, 6);
  143|      1|    d.unionSet(5, 7);
  144|      1|    d.unionSet(9, 10);
  145|      1|    d.unionSet(2, 10);
  146|       |    // keeping track of the changes using parent pointers
  147|      1|    vector<uint64_t> ans = {7, 5};
  148|      3|    for (uint64_t i = 0; i < ans.size(); i++) {
  149|      2|        assert(d.getParents(7).at(i) ==
  150|      2|               ans[i]);  // makes sure algorithm works fine
  151|      2|    }
  152|      1|    cout << "1st test passed!" << endl;
  153|      1|}
  154|       |/**
  155|       | * @brief Self-implementations, 2nd test
  156|       | * @returns void
  157|       | */
  158|      1|static void test2() {
  159|       |    // checks the parents in the resultant structures
  160|      1|    uint64_t n = 10;   ///< number of elements
  161|      1|    dsu d(n + 1);      ///< object of class disjoint sets
  162|      1|    d.unionSet(2, 1);  /// performs union operation on 1 and 2
  163|      1|    d.unionSet(1, 4);
  164|      1|    d.unionSet(8, 1);
  165|      1|    d.unionSet(3, 5);
  166|      1|    d.unionSet(5, 6);
  167|      1|    d.unionSet(5, 7);
  168|      1|    d.unionSet(9, 10);
  169|      1|    d.unionSet(2, 10);
  170|       |
  171|       |    /// keeping track of the changes using parent pointers
  172|      1|    vector<uint64_t> ans = {2, 1, 10};
  173|      4|    for (uint64_t i = 0; i < ans.size(); i++) {
  174|      3|        assert(d.getParents(2).at(i) ==
  175|      3|               ans[i]);  /// makes sure algorithm works fine
  176|      3|    }
  177|      1|    cout << "2nd test passed!" << endl;
  178|      1|}
  179|       |/**
  180|       | * @brief Main function
  181|       | * @returns 0 on exit
  182|       | */
  183|      1|int main() {
  184|      1|    test1();  // run 1st test case
  185|      1|    test2();  // run 2nd test case
  186|       |
  187|      1|    return 0;
  188|      1|}

