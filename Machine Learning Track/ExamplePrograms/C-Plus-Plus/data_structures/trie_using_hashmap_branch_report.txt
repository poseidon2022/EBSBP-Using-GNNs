    1|       |/**
    2|       | * @file
    3|       | * @author [Venkata Bharath](https://github.com/bharath000)
    4|       | * @brief Implementation of [Trie](https://en.wikipedia.org/wiki/Trie) data
    5|       | * structure using HashMap for different characters and method for predicting
    6|       | * words based on prefix.
    7|       | * @details The Trie data structure is implemented using unordered map to use
    8|       | * memory optimally, predict_words method is developed to recommend words based
    9|       | * on a given prefix along with other methods insert, delete, search, startwith
   10|       | * in trie.
   11|       | * @see trie_modern.cpp for difference
   12|       | */
   13|       |#include <cassert>        /// for assert
   14|       |#include <iostream>       /// for IO operations
   15|       |#include <memory>         /// for std::shared_ptr
   16|       |#include <stack>          /// for std::stack
   17|       |#include <unordered_map>  /// for std::unordered_map
   18|       |#include <vector>         /// for std::vector
   19|       |
   20|       |/**
   21|       | * @namespace data_structures
   22|       | * @brief Data structures algorithms
   23|       | */
   24|       |namespace data_structures {
   25|       |
   26|       |/**
   27|       | * @namespace trie_using_hashmap
   28|       | * @brief Functions for [Trie](https://en.wikipedia.org/wiki/Trie) data
   29|       | * structure using hashmap implementation
   30|       | */
   31|       |namespace trie_using_hashmap {
   32|       |
   33|       |/**
   34|       | * @brief Trie class, implementation of trie using hashmap in each trie node
   35|       | * for all the characters of char16_t(UTF-16)type with methods to insert,
   36|       | * delete, search, start with and to recommend words based on a given
   37|       | * prefix.
   38|       | */
   39|       |class Trie {
   40|       | private:
   41|       |    /**
   42|       |     * @brief struct representing a trie node.
   43|       |     */
   44|       |    struct Node {
   45|       |        std::unordered_map<char16_t, std::shared_ptr<Node>>
   46|       |            children;  ///< unordered map with key type char16_t and value is a
   47|       |                       ///< shared pointer type of Node
   48|       |        bool word_end = false;  ///< boolean variable to represent the node end
   49|       |    };
   50|       |
   51|       |    std::shared_ptr<Node> root_node =
   52|       |        std::make_shared<Node>();  ///< declaring root node of trie
   53|       |
   54|       | public:
   55|       |    ///< Constructor
   56|      1|    Trie() = default;
   57|       |
   58|       |    /**
   59|       |     * @brief insert the string into the trie
   60|       |     * @param word string to insert in the trie
   61|       |     */
   62|     13|    void insert(const std::string& word) {
   63|     13|        std::shared_ptr<Node> curr = root_node;
   64|     67|        for (char ch : word) {
   65|     67|            if (curr->children.find(ch) == curr->children.end()) {
   66|     45|                curr->children[ch] = std::make_shared<Node>();
   67|     45|            }
   68|     67|            curr = curr->children[ch];
   69|     67|        }
   70|       |
   71|     13|        if (!curr->word_end && curr != root_node) {
   72|     13|            curr->word_end = true;
   73|     13|        }
   74|     13|    }
   75|       |
   76|       |    /**
   77|       |     * @brief search a word/string inside the trie
   78|       |     * @param word string to search for
   79|       |     * @returns `true` if found
   80|       |     * @returns `false` if not found
   81|       |     */
   82|     15|    bool search(const std::string& word) {
   83|     15|        std::shared_ptr<Node> curr = root_node;
   84|     69|        for (char ch : word) {
   85|     69|            if (curr->children.find(ch) == curr->children.end()) {
   86|      2|                return false;
   87|      2|            }
   88|     67|            curr = curr->children[ch];
   89|     67|            if (!curr) {
   90|      0|                return false;
   91|      0|            }
   92|     67|        }
   93|       |
   94|     13|        if (curr->word_end) {
   95|     12|            return true;
   96|     12|        } else {
   97|      1|            return false;
   98|      1|        }
   99|     13|    }
  100|       |
  101|       |    /**
  102|       |     * @brief search a word/string that starts with a given prefix
  103|       |     * @param prefix string to search for
  104|       |     * @returns `true` if found
  105|       |     * @returns `false` if not found
  106|       |     */
  107|     17|    bool startwith(const std::string& prefix) {
  108|     17|        std::shared_ptr<Node> curr = root_node;
  109|     67|        for (char ch : prefix) {
  110|     67|            if (curr->children.find(ch) == curr->children.end()) {
  111|      4|                return false;
  112|      4|            }
  113|     63|            curr = curr->children[ch];
  114|     63|        }
  115|     13|        return true;
  116|     17|    }
  117|       |
  118|       |    /**
  119|       |     * @brief delete a word/string from a trie
  120|       |     * @param word string to delete from trie
  121|       |     */
  122|      1|    void delete_word(std::string word) {
  123|      1|        std::shared_ptr<Node> curr = root_node;
  124|      1|        std::stack<std::shared_ptr<Node>> nodes;
  125|      1|        int cnt = 0;
  126|      3|        for (char ch : word) {
  127|      3|            if (curr->children.find(ch) == curr->children.end()) {
  128|      0|                return;
  129|      0|            }
  130|      3|            if (curr->word_end) {
  131|      0|                cnt++;
  132|      0|            }
  133|       |
  134|      3|            nodes.push(curr->children[ch]);
  135|      3|            curr = curr->children[ch];
  136|      3|        }
  137|       |        // Delete only when it's a word, and it has children after
  138|       |        // or prefix in the line
  139|      1|        if (nodes.top()->word_end) {
  140|      1|            nodes.top()->word_end = false;
  141|      1|        }
  142|       |        // Delete only when it has no children after
  143|       |        // and also no prefix in the line
  144|      1|        while (!(nodes.top()->word_end) && nodes.top()->children.empty()) {
  145|      0|            nodes.pop();
  146|      0|            nodes.top()->children.erase(word.back());
  147|      0|            word.pop_back();
  148|      0|        }
  149|      1|    }
  150|       |
  151|       |    /**
  152|       |     * @brief helper function to predict/recommend words that starts with a
  153|       |     * given prefix from the end of prefix's node iterate through all the child
  154|       |     * nodes by recursively appending all the possible words below the trie
  155|       |     * @param prefix string to recommend the words
  156|       |     * @param element node at the end of the given prefix
  157|       |     * @param results list to store the all possible words
  158|       |     * @returns list of recommended words
  159|       |     */
  160|       |    std::vector<std::string> get_all_words(std::vector<std::string> results,
  161|       |                                           const std::shared_ptr<Node>& element,
  162|     75|                                           std::string prefix) {
  163|     75|        if (element->word_end) {
  164|     28|            results.push_back(prefix);
  165|     28|        }
  166|     75|        if (element->children.empty()) {
  167|     20|            return results;
  168|     20|        }
  169|     69|        for (auto const& x : element->children) {
  170|     69|            std::string key = "";
  171|     69|            key = x.first;
  172|     69|            prefix += key;
  173|       |
  174|     69|            results =
  175|     69|                get_all_words(results, element->children[x.first], prefix);
  176|       |
  177|     69|            prefix.pop_back();
  178|     69|        }
  179|       |
  180|     55|        return results;
  181|     75|    }
  182|       |
  183|       |    /**
  184|       |     * @brief predict/recommend a word that starts with a given prefix
  185|       |     * @param prefix string to search for
  186|       |     * @returns list of recommended words
  187|       |     */
  188|      7|    std::vector<std::string> predict_words(const std::string& prefix) {
  189|      7|        std::vector<std::string> result;
  190|      7|        std::shared_ptr<Node> curr = root_node;
  191|       |        // traversing until the end of the given prefix in trie
  192|       |
  193|     12|        for (char ch : prefix) {
  194|     12|            if (curr->children.find(ch) == curr->children.end()) {
  195|      1|                return result;
  196|      1|            }
  197|       |
  198|     11|            curr = curr->children[ch];
  199|     11|        }
  200|       |
  201|       |        // if the given prefix is the only word without children
  202|      6|        if (curr->word_end && curr->children.empty()) {
  203|      0|            result.push_back(prefix);
  204|      0|            return result;
  205|      0|        }
  206|       |
  207|      6|        result = get_all_words(
  208|      6|            result, curr,
  209|      6|            prefix);  ///< iteratively and recursively get the recommended words
  210|       |
  211|      6|        return result;
  212|      6|    }
  213|       |};
  214|       |}  // namespace trie_using_hashmap
  215|       |}  // namespace data_structures
  216|       |
  217|       |/**
  218|       | * @brief Self-test implementations
  219|       | * @returns void
  220|       | */
  221|      1|static void test() {
  222|      1|    data_structures::trie_using_hashmap::Trie obj;
  223|       |    // Inserting data into trie using the insert
  224|       |    // method and testing it with search method
  225|      1|    obj.insert("app");
  226|      1|    obj.insert("abscond");
  227|      1|    obj.insert("about");
  228|      1|    obj.insert("apps");
  229|      1|    obj.insert("apen");
  230|      1|    obj.insert("apples");
  231|      1|    obj.insert("apple");
  232|      1|    obj.insert("approach");
  233|      1|    obj.insert("bus");
  234|      1|    obj.insert("buses");
  235|      1|    obj.insert("Apple");
  236|      1|    obj.insert("Bounce");
  237|       |
  238|      1|    assert(!obj.search("appy"));
  239|      0|    std::cout << "appy is not a word in trie" << std::endl;
  240|       |
  241|      1|    assert(!obj.search("car"));
  242|      0|    std::cout << "car is not a word in trie" << std::endl;
  243|      1|    assert(obj.search("app"));
  244|      0|    assert(obj.search("apple"));
  245|      0|    assert(obj.search("apples"));
  246|      0|    assert(obj.search("apps"));
  247|      0|    assert(obj.search("apen"));
  248|      0|    assert(obj.search("approach"));
  249|      0|    assert(obj.search("about"));
  250|      0|    assert(obj.search("abscond"));
  251|      0|    assert(obj.search("bus"));
  252|      0|    assert(obj.search("buses"));
  253|      0|    assert(obj.search("Bounce"));
  254|      0|    assert(obj.search("Apple"));
  255|       |
  256|      0|    std::cout << "All the Inserted words are present in the trie" << std::endl;
  257|       |
  258|       |    // test for startwith prefix method
  259|      1|    assert(!obj.startwith("approachs"));
  260|      0|    assert(obj.startwith("approach"));
  261|      0|    assert(obj.startwith("about"));
  262|      0|    assert(!obj.startwith("appy"));
  263|      0|    assert(obj.startwith("abscond"));
  264|      0|    assert(obj.startwith("bus"));
  265|      0|    assert(obj.startwith("buses"));
  266|      0|    assert(obj.startwith("Bounce"));
  267|      0|    assert(obj.startwith("Apple"));
  268|      0|    assert(obj.startwith("abs"));
  269|      0|    assert(obj.startwith("b"));
  270|      0|    assert(obj.startwith("bus"));
  271|      0|    assert(obj.startwith("Bo"));
  272|      0|    assert(obj.startwith("A"));
  273|      0|    assert(!obj.startwith("Ca"));
  274|       |
  275|      0|    assert(!obj.startwith("C"));
  276|       |
  277|      0|    std::cout << "All the tests passed for startwith method" << std::endl;
  278|       |
  279|       |    // test for predict_words/recommendation of words based on a given prefix
  280|       |
  281|      1|    std::vector<std::string> pred_words = obj.predict_words("a");
  282|       |
  283|      8|    for (const std::string& str : obj.predict_words("a")) {
  284|      8|        std::cout << str << std::endl;
  285|      8|    }
  286|      1|    assert(pred_words.size() == 8);
  287|      0|    std::cout << "Returned all words that start with prefix a " << std::endl;
  288|      1|    pred_words = obj.predict_words("app");
  289|       |
  290|      5|    for (const std::string& str : pred_words) {
  291|      5|        std::cout << str << std::endl;
  292|      5|    }
  293|       |
  294|      1|    assert(pred_words.size() == 5);
  295|      0|    std::cout << "Returned all words that start with prefix app " << std::endl;
  296|      1|    pred_words = obj.predict_words("A");
  297|       |
  298|      1|    for (const std::string& str : pred_words) {
  299|      1|        std::cout << str << std::endl;
  300|      1|    }
  301|       |
  302|      1|    assert(pred_words.size() == 1);
  303|      0|    std::cout << "Returned all words that start with prefix A " << std::endl;
  304|      1|    pred_words = obj.predict_words("bu");
  305|       |
  306|      2|    for (const std::string& str : pred_words) {
  307|      2|        std::cout << str << std::endl;
  308|      2|    }
  309|       |
  310|      1|    assert(pred_words.size() == 2);
  311|      0|    std::cout << "Returned all words that start with prefix bu " << std::endl;
  312|       |
  313|       |    // tests for delete method
  314|       |
  315|      1|    obj.delete_word("app");
  316|      1|    assert(!obj.search("app"));
  317|      0|    std::cout << "word app is deleted sucessful" << std::endl;
  318|       |
  319|      1|    pred_words = obj.predict_words("app");
  320|      4|    for (const std::string& str : pred_words) {
  321|      4|        std::cout << str << std::endl;
  322|      4|    }
  323|      1|    assert(pred_words.size() == 4);
  324|      0|    std::cout << "app is deleted sucessful" << std::endl;
  325|       |
  326|       |    // test case for Chinese language
  327|       |
  328|      1|    obj.insert("苹果");
  329|      1|    assert(obj.startwith("苹"));
  330|      0|    pred_words = obj.predict_words("h");
  331|       |
  332|      1|    assert(pred_words.size() == 0);
  333|      0|    std::cout << "No word starts with prefix h in trie" << std::endl;
  334|       |
  335|      1|    std::cout << "All tests passed" << std::endl;
  336|      1|}
  337|       |
  338|       |/**
  339|       | * @brief Main function
  340|       | * @returns 0 on exit
  341|       | */
  342|      1|int main() {
  343|      1|    test();  // run self-test implementaions
  344|      1|    return 0;
  345|      1|}

