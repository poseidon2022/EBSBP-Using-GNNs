    1|       |/**
    2|       | * @brief Stack Data Structure Using the Queue Data Structure
    3|       | * @details
    4|       | * Using 2 Queues inside the Stack class, we can easily implement Stack
    5|       | * data structure with heavy computation in push function.
    6|       | *
    7|       | * References used:
    8|       | * [StudyTonight](https://www.studytonight.com/data-structures/stack-using-queue)
    9|       | * @author [tushar2407](https://github.com/tushar2407)
   10|       | */
   11|       |#include <cassert>   /// for assert
   12|       |#include <cstdint>
   13|       |#include <iostream>  /// for IO operations
   14|       |#include <queue>     /// for queue data structure
   15|       |
   16|       |/**
   17|       | * @namespace data_structures
   18|       | * @brief Data structures algorithms
   19|       | */
   20|       |namespace data_structures {
   21|       |/**
   22|       | * @namespace stack_using_queue
   23|       | * @brief Functions for the [Stack Using
   24|       | * Queue](https://www.studytonight.com/data-structures/stack-using-queue)
   25|       | * implementation
   26|       | */
   27|       |namespace stack_using_queue {
   28|       |/**
   29|       | * @brief Stack Class implementation for basic methods of Stack Data Structure.
   30|       | */
   31|       |struct Stack {
   32|       |    std::queue<int64_t> main_q;       ///< stores the current state of the stack
   33|       |    std::queue<int64_t> auxiliary_q;  ///< used to carry out intermediate
   34|       |                                      ///< operations to implement stack
   35|       |    uint32_t current_size = 0;        ///< stores the current size of the stack
   36|       |
   37|       |    /**
   38|       |     * Returns the top most element of the stack
   39|       |     * @returns top element of the queue
   40|       |     */
   41|      5|    int top() { return main_q.front(); }
   42|       |
   43|       |    /**
   44|       |     * @brief Inserts an element to the top of the stack.
   45|       |     * @param val the element that will be inserted into the stack
   46|       |     * @returns void
   47|       |     */
   48|      4|    void push(int val) {
   49|      4|        auxiliary_q.push(val);
   50|      8|        while (!main_q.empty()) {
   51|      4|            auxiliary_q.push(main_q.front());
   52|      4|            main_q.pop();
   53|      4|        }
   54|      4|        swap(main_q, auxiliary_q);
   55|      4|        current_size++;
   56|      4|    }
   57|       |
   58|       |    /**
   59|       |     * @brief Removes the topmost element from the stack
   60|       |     * @returns void
   61|       |     */
   62|      3|    void pop() {
   63|      3|        if (main_q.empty()) {
   64|      0|            return;
   65|      0|        }
   66|      3|        main_q.pop();
   67|      3|        current_size--;
   68|      3|    }
   69|       |
   70|       |    /**
   71|       |     * @brief Utility function to return the current size of the stack
   72|       |     * @returns current size of stack
   73|       |     */
   74|      2|    int size() { return current_size; }
   75|       |};
   76|       |}  // namespace stack_using_queue
   77|       |}  // namespace data_structures
   78|       |
   79|       |/**
   80|       | * @brief Self-test implementations
   81|       | * @returns void
   82|       | */
   83|      1|static void test() {
   84|      1|    data_structures::stack_using_queue::Stack s;
   85|      1|    s.push(1);  /// insert an element into the stack
   86|      1|    s.push(2);  /// insert an element into the stack
   87|      1|    s.push(3);  /// insert an element into the stack
   88|       |
   89|      1|    assert(s.size() == 3);  /// size should be 3
   90|       |
   91|      0|    assert(s.top() == 3);  /// topmost element in the stack should be 3
   92|       |
   93|      0|    s.pop();               /// remove the topmost element from the stack
   94|      1|    assert(s.top() == 2);  /// topmost element in the stack should now be 2
   95|       |
   96|      0|    s.pop();  /// remove the topmost element from the stack
   97|      1|    assert(s.top() == 1);
   98|       |
   99|      0|    s.push(5);             /// insert an element into the stack
  100|      1|    assert(s.top() == 5);  /// topmost element in the stack should now be 5
  101|       |
  102|      0|    s.pop();               /// remove the topmost element from the stack
  103|      1|    assert(s.top() == 1);  /// topmost element in the stack should now be 1
  104|       |
  105|      0|    assert(s.size() == 1);  /// size should be 1
  106|      1|}
  107|       |
  108|       |/**
  109|       | * @brief Main function
  110|       | * Creates a stack and pushed some value into it.
  111|       | * Through a series of push and pop functions on stack,
  112|       | * it demostrates the functionality of the custom stack
  113|       | * declared above.
  114|       | * @returns 0 on exit
  115|       | */
  116|      1|int main() {
  117|      1|    test();  // run self-test implementations
  118|      1|    return 0;
  119|      1|}

