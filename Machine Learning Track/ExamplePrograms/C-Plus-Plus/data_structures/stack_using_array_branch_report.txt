    1|       |#include <cassert>    /// For std::assert
    2|       |#include <iostream>   /// For std::cout
    3|       |#include <memory>     /// For std::unique_ptr
    4|       |#include <stdexcept>  /// For std::out_of_range
    5|       |
    6|       |/**
    7|       | * @namespace
    8|       | * @brief data_structures
    9|       | */
   10|       |namespace data_structures {
   11|       |/**
   12|       | * @brief Class representation of a stack
   13|       | * @tparam T The type of the elements in the stack
   14|       | */
   15|       |template <typename T>
   16|       |class Stack {
   17|       | private:
   18|       |    std::unique_ptr<T[]> stack;  ///< Smart pointer to the stack array
   19|       |    int stackSize;               ///< Maximum size of the stack
   20|       |    int stackIndex;  ///< Index pointing to the top element of the stack
   21|       |
   22|       | public:
   23|       |    /**
   24|       |     * @brief Constructs a new Stack object
   25|       |     *
   26|       |     * @param size Maximum size of the stack
   27|       |     */
   28|      1|    Stack(int size) : stackSize(size), stackIndex(-1), stack(new T[size]) {}
   29|       |
   30|       |    /**
   31|       |     * @brief Checks if the stack is full
   32|       |     *
   33|       |     * @return true if the stack is full, false otherwise
   34|       |     */
   35|      9|    bool full() const { return stackIndex == stackSize - 1; }
   36|       |
   37|       |    /**
   38|       |     * @brief Checks if the stack is empty
   39|       |     * @return true if the stack is empty, false otherwise
   40|       |     */
   41|     14|    bool empty() const { return stackIndex == -1; }
   42|       |
   43|       |    /**
   44|       |     * @brief Pushes an element onto the stack
   45|       |     *
   46|       |     * @param element Element to push onto the stack
   47|       |     */
   48|      6|    void push(T element) {
   49|      6|        if (full()) {
   50|      1|            throw std::out_of_range("Stack overflow");
   51|      5|        } else {
   52|      5|            stack[++stackIndex] = element;
   53|      5|        }
   54|      6|    }
   55|       |
   56|       |    /**
   57|       |     * @brief Pops an element from the stack
   58|       |     *
   59|       |     * @return The popped element
   60|       |     * @throws std::out_of_range if the stack is empty
   61|       |     */
   62|      6|    T pop() {
   63|      6|        if (empty()) {
   64|      1|            throw std::out_of_range("Stack underflow");
   65|      1|        }
   66|      5|        return stack[stackIndex--];
   67|      6|    }
   68|       |
   69|       |    /**
   70|       |     * @brief Displays all elements in the stack
   71|       |     */
   72|       |    void show() const {
   73|       |        for (int i = 0; i <= stackIndex; i++) {
   74|       |            std::cout << stack[i] << "\n";
   75|       |        }
   76|       |    }
   77|       |
   78|       |    /**
   79|       |     * @brief Displays the topmost element of the stack
   80|       |     *
   81|       |     * @return The topmost element of the stack
   82|       |     * @throws std::out_of_range if the stack is empty
   83|       |     */
   84|      4|    T topmost() const {
   85|      4|        if (empty()) {
   86|      1|            throw std::out_of_range("Stack underflow");
   87|      1|        }
   88|      3|        return stack[stackIndex];
   89|      4|    }
   90|       |
   91|       |    /**
   92|       |     * @brief Displays the bottom element of the stack
   93|       |     *
   94|       |     * @return The bottom element of the stack
   95|       |     * @throws std::out_of_range if the stack is empty
   96|       |     */
   97|      2|    T bottom() const {
   98|      2|        if (empty()) {
   99|      1|            throw std::out_of_range("Stack underflow");
  100|      1|        }
  101|      1|        return stack[0];
  102|      2|    }
  103|       |};
  104|       |}  // namespace data_structures
  105|       |
  106|       |/**
  107|       | * @brief Self-test implementations
  108|       | * @returns void
  109|       | */
  110|      1|static void test() {
  111|      1|    data_structures::Stack<int> stack(5);
  112|       |
  113|       |    // Test empty and full operations
  114|      1|    assert(stack.empty());
  115|      0|    assert(!stack.full());
  116|       |
  117|       |    // Test pushing elements and checking topmost
  118|      0|    stack.push(10);
  119|      1|    assert(stack.topmost() == 10);
  120|       |
  121|      0|    stack.push(20);
  122|      1|    assert(stack.topmost() == 20);
  123|       |
  124|      0|    stack.push(30);
  125|      1|    stack.push(40);
  126|      1|    stack.push(50);
  127|      1|    assert(stack.full());
  128|       |
  129|       |    // Test stack overflow
  130|      1|    try {
  131|      1|        stack.push(60);
  132|      1|    } catch (const std::out_of_range& e) {
  133|      1|        assert(std::string(e.what()) == "Stack overflow");
  134|      1|    }
  135|       |
  136|       |    // Test popping elements
  137|      1|    assert(stack.pop() == 50);
  138|      0|    assert(stack.pop() == 40);
  139|      0|    assert(stack.pop() == 30);
  140|       |
  141|       |    // Check topmost and bottom elements
  142|      0|    assert(stack.topmost() == 20);
  143|      0|    assert(stack.bottom() == 10);
  144|       |
  145|      0|    assert(stack.pop() == 20);
  146|      0|    assert(stack.pop() == 10);
  147|       |
  148|      0|    assert(stack.empty());
  149|      0|    assert(!stack.full());
  150|       |
  151|       |    // Test stack underflow
  152|      1|    try {
  153|      1|        stack.pop();
  154|      1|    } catch (const std::out_of_range& e) {
  155|      1|        assert(std::string(e.what()) == "Stack underflow");
  156|      1|    }
  157|       |
  158|      1|    try {
  159|      1|        stack.topmost();
  160|      1|    } catch (const std::out_of_range& e) {
  161|      1|        assert(std::string(e.what()) == "Stack underflow");
  162|      1|    }
  163|       |
  164|      1|    try {
  165|      1|        stack.bottom();
  166|      1|    } catch (const std::out_of_range& e) {
  167|      1|        assert(std::string(e.what()) == "Stack underflow");
  168|      1|    }
  169|      1|}
  170|       |
  171|       |/**
  172|       | * @brief Main function
  173|       | * @returns 0 on exit
  174|       | */
  175|      1|int main() {
  176|      1|    test();  // run self-test implementations
  177|      1|    std::cout << "All tests passed!" << std::endl;
  178|      1|    return 0;
  179|      1|}

