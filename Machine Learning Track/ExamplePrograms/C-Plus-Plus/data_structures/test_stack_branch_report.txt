/home/kidus/Desktop/GNNs/ExamplePrograms/C-Plus-Plus/data_structures/node.hpp:
    1|       |/**
    2|       | * @file
    3|       | * @brief  Provides Node class and related utilities
    4|       | **/
    5|       |#ifndef DATA_STRUCTURES_NODE_HPP_
    6|       |#define DATA_STRUCTURES_NODE_HPP_
    7|       |
    8|       |#include <iostream>  /// for std::cout
    9|       |#include <memory>    /// for std::shared_ptr
   10|       |#include <vector>    /// for std::vector
   11|       |
   12|       |/** Definition of the node as a linked-list
   13|       | * \tparam ValueType type of data nodes of the linked list should contain
   14|       | */
   15|       |template <class ValueType>
   16|       |struct Node {
   17|       |    using value_type = ValueType;
   18|       |    ValueType data = {};
   19|       |    std::shared_ptr<Node<ValueType>> next = {};
   20|       |};
   21|       |
   22|       |template <typename Node, typename Action>
   23|     60|void traverse(const Node* const inNode, const Action& action) {
   24|     60|    if (inNode) {
   25|     45|        action(*inNode);
   26|     45|        traverse(inNode->next.get(), action);
   27|     45|    }
   28|     60|}
   29|       |
   30|       |template <typename Node>
   31|       |void display_all(const Node* const inNode) {
   32|       |    traverse(inNode,
   33|       |             [](const Node& curNode) { std::cout << curNode.data << " "; });
   34|       |}
   35|       |
   36|       |template <typename Node>
   37|       |std::vector<typename Node::value_type> push_all_to_vector(
   38|     15|    const Node* const inNode, const std::size_t expected_size = 0) {
   39|     15|    std::vector<typename Node::value_type> res;
   40|     15|    res.reserve(expected_size);
   41|     15|    traverse(inNode,
   42|     45|             [&res](const Node& curNode) { res.push_back(curNode.data); });
   43|     15|    return res;
   44|     15|}
   45|       |
   46|       |#endif  // DATA_STRUCTURES_NODE_HPP_

/home/kidus/Desktop/GNNs/ExamplePrograms/C-Plus-Plus/data_structures/stack.hpp:
    1|       |/**
    2|       | * @file
    3|       | * @author danghai
    4|       | * @author [Piotr Idzik](https://github.com/vil02)
    5|       | * @brief  This class specifies the basic operation on a stack as a linked list
    6|       | **/
    7|       |#ifndef DATA_STRUCTURES_STACK_HPP_
    8|       |#define DATA_STRUCTURES_STACK_HPP_
    9|       |
   10|       |#include <stdexcept>  /// for std::invalid_argument
   11|       |
   12|       |#include "node.hpp"  /// for Node
   13|       |
   14|       |/** Definition of the stack class
   15|       | * \tparam value_type type of data nodes of the linked list in the stack should
   16|       | * contain
   17|       | */
   18|       |template <class ValueType>
   19|       |class stack {
   20|       | public:
   21|       |    using value_type = ValueType;
   22|       |
   23|       |    /** Show stack */
   24|       |    void display() const {
   25|       |        std::cout << "Top --> ";
   26|       |        display_all(this->stackTop.get());
   27|       |        std::cout << '\n';
   28|       |        std::cout << "Size of stack: " << size << std::endl;
   29|       |    }
   30|       |
   31|     15|    std::vector<value_type> toVector() const {
   32|     15|        return push_all_to_vector(this->stackTop.get(), this->size);
   33|     15|    }
   34|       |
   35|       | private:
   36|     12|    void ensureNotEmpty() const {
   37|     12|        if (isEmptyStack()) {
   38|      2|            throw std::invalid_argument("Stack is empty.");
   39|      2|        }
   40|     12|    }
  ------------------
  | Unexecuted instantiation: _ZNK5stackIjE14ensureNotEmptyEv
  ------------------
  | _ZNK5stackIiE14ensureNotEmptyEv:
  |   36|     10|    void ensureNotEmpty() const {
  |   37|     10|        if (isEmptyStack()) {
  |   38|      0|            throw std::invalid_argument("Stack is empty.");
  |   39|      0|        }
  |   40|     10|    }
  ------------------
  | _ZNK5stackIeE14ensureNotEmptyEv:
  |   36|      1|    void ensureNotEmpty() const {
  |   37|      1|        if (isEmptyStack()) {
  |   38|      1|            throw std::invalid_argument("Stack is empty.");
  |   39|      1|        }
  |   40|      1|    }
  ------------------
  | _ZNK5stackIbE14ensureNotEmptyEv:
  |   36|      1|    void ensureNotEmpty() const {
  |   37|      1|        if (isEmptyStack()) {
  |   38|      1|            throw std::invalid_argument("Stack is empty.");
  |   39|      1|        }
  |   40|      1|    }
  ------------------
   41|       |
   42|       | public:
   43|       |    /** Determine whether the stack is empty */
   44|     16|    bool isEmptyStack() const { return (stackTop == nullptr); }
  ------------------
  | Unexecuted instantiation: _ZNK5stackIjE12isEmptyStackEv
  ------------------
  | _ZNK5stackIiE12isEmptyStackEv:
  |   44|     13|    bool isEmptyStack() const { return (stackTop == nullptr); }
  ------------------
  | _ZNK5stackIeE12isEmptyStackEv:
  |   44|      1|    bool isEmptyStack() const { return (stackTop == nullptr); }
  ------------------
  | _ZNK5stackIbE12isEmptyStackEv:
  |   44|      1|    bool isEmptyStack() const { return (stackTop == nullptr); }
  ------------------
  | _ZNK5stackIcE12isEmptyStackEv:
  |   44|      1|    bool isEmptyStack() const { return (stackTop == nullptr); }
  ------------------
   45|       |
   46|       |    /** Add new item to the stack */
   47|     32|    void push(const value_type& item) {
   48|     32|        auto newNode = std::make_shared<Node<value_type>>();
   49|     32|        newNode->data = item;
   50|     32|        newNode->next = stackTop;
   51|     32|        stackTop = newNode;
   52|     32|        size++;
   53|     32|    }
  ------------------
  | _ZN5stackIiE4pushERKi:
  |   47|     32|    void push(const value_type& item) {
  |   48|     32|        auto newNode = std::make_shared<Node<value_type>>();
  |   49|     32|        newNode->data = item;
  |   50|     32|        newNode->next = stackTop;
  |   51|     32|        stackTop = newNode;
  |   52|     32|        size++;
  |   53|     32|    }
  ------------------
  | Unexecuted instantiation: _ZN5stackIjE4pushERKj
  ------------------
   54|       |
   55|       |    /** Return the top element of the stack */
   56|      4|    value_type top() const {
   57|      4|        ensureNotEmpty();
   58|      4|        return stackTop->data;
   59|      4|    }
  ------------------
  | Unexecuted instantiation: _ZNK5stackIjE3topEv
  ------------------
  | _ZNK5stackIiE3topEv:
  |   56|      3|    value_type top() const {
  |   57|      3|        ensureNotEmpty();
  |   58|      3|        return stackTop->data;
  |   59|      3|    }
  ------------------
  | _ZNK5stackIeE3topEv:
  |   56|      1|    value_type top() const {
  |   57|      1|        ensureNotEmpty();
  |   58|      1|        return stackTop->data;
  |   59|      1|    }
  ------------------
   60|       |
   61|       |    /** Remove the top element of the stack */
   62|      8|    void pop() {
   63|      8|        ensureNotEmpty();
   64|      8|        stackTop = stackTop->next;
   65|      8|        size--;
   66|      8|    }
  ------------------
  | _ZN5stackIiE3popEv:
  |   62|      7|    void pop() {
  |   63|      7|        ensureNotEmpty();
  |   64|      7|        stackTop = stackTop->next;
  |   65|      7|        size--;
  |   66|      7|    }
  ------------------
  | _ZN5stackIbE3popEv:
  |   62|      1|    void pop() {
  |   63|      1|        ensureNotEmpty();
  |   64|      1|        stackTop = stackTop->next;
  |   65|      1|        size--;
  |   66|      1|    }
  ------------------
   67|       |
   68|       |    /** Clear stack */
   69|      1|    void clear() {
   70|      1|        stackTop = nullptr;
   71|      1|        size = 0;
   72|      1|    }
   73|       |
   74|       | private:
   75|       |    std::shared_ptr<Node<value_type>> stackTop =
   76|       |        {};                /**< Pointer to the stack */
   77|       |    std::size_t size = 0;  ///< size of stack
   78|       |};
   79|       |
   80|       |#endif  // DATA_STRUCTURES_STACK_HPP_

/home/kidus/Desktop/GNNs/ExamplePrograms/C-Plus-Plus/data_structures/test_stack.cpp:
    1|       |#include <cassert>    /// for assert
    2|       |#include <iostream>   /// for std::cout
    3|       |#include <stdexcept>  /// std::invalid_argument
    4|       |#include <vector>     /// for std::vector
    5|       |
    6|       |#include "./stack.hpp"
    7|       |
    8|       |template <typename T>
    9|      2|void testConstructedStackIsEmpty() {
   10|      2|    const stack<T> curStack;
   11|      2|    assert(curStack.isEmptyStack());
   12|      2|}
  ------------------
  | _Z27testConstructedStackIsEmptyIiEvv:
  |    9|      1|void testConstructedStackIsEmpty() {
  |   10|      1|    const stack<T> curStack;
  |   11|      1|    assert(curStack.isEmptyStack());
  |   12|      1|}
  ------------------
  | _Z27testConstructedStackIsEmptyIcEvv:
  |    9|      1|void testConstructedStackIsEmpty() {
  |   10|      1|    const stack<T> curStack;
  |   11|      1|    assert(curStack.isEmptyStack());
  |   12|      1|}
  ------------------
   13|       |
   14|      1|void testPush() {
   15|      1|    using valueType = int;
   16|      1|    stack<valueType> curStack;
   17|      1|    curStack.push(10);
   18|      1|    curStack.push(20);
   19|      1|    curStack.push(30);
   20|      1|    curStack.push(40);
   21|      1|    const auto expectedData = std::vector<valueType>({40, 30, 20, 10});
   22|      1|    assert(curStack.toVector() == expectedData);
   23|      1|}
   24|       |
   25|      0|void testTop() {
   26|      0|    using valueType = unsigned;
   27|      0|    stack<valueType> curStack;
   28|      0|    curStack.push(1);
   29|      0|    curStack.push(2);
   30|      0|    curStack.push(3);
   31|      0|    curStack.push(4);
   32|      0|    assert(curStack.top() == static_cast<valueType>(4));
   33|      0|}
   34|       |
   35|      1|void testPop() {
   36|      1|    using valueType = int;
   37|      1|    stack<valueType> curStack;
   38|      1|    curStack.push(100);
   39|      1|    curStack.push(200);
   40|      1|    curStack.push(300);
   41|       |
   42|      1|    assert(curStack.top() == static_cast<valueType>(300));
   43|      0|    curStack.pop();
   44|      1|    assert(curStack.top() == static_cast<valueType>(200));
   45|      0|    curStack.pop();
   46|      1|    assert(curStack.top() == static_cast<valueType>(100));
   47|      0|    curStack.pop();
   48|      1|    assert(curStack.isEmptyStack());
   49|      1|}
   50|       |
   51|      1|void testClear() {
   52|      1|    stack<int> curStack;
   53|      1|    curStack.push(1000);
   54|      1|    curStack.push(2000);
   55|      1|    curStack.clear();
   56|      1|    assert(curStack.isEmptyStack());
   57|      1|}
   58|       |
   59|      1|void testCopyOfStackHasSameData() {
   60|      1|    stack<int> stackA;
   61|      1|    stackA.push(10);
   62|      1|    stackA.push(200);
   63|      1|    stackA.push(3000);
   64|      1|    const auto stackB(stackA);
   65|      1|    assert(stackA.toVector() == stackB.toVector());
   66|      1|}
   67|       |
   68|      1|void testPushingToCopyDoesNotChangeOriginal() {
   69|      1|    using valueType = int;
   70|      1|    stack<valueType> stackA;
   71|      1|    stackA.push(10);
   72|      1|    stackA.push(20);
   73|      1|    stackA.push(30);
   74|      1|    auto stackB(stackA);
   75|      1|    stackB.push(40);
   76|       |
   77|      1|    const auto expectedDataA = std::vector<valueType>({30, 20, 10});
   78|      1|    const auto expectedDataB = std::vector<valueType>({40, 30, 20, 10});
   79|       |
   80|      1|    assert(stackA.toVector() == expectedDataA);
   81|      0|    assert(stackB.toVector() == expectedDataB);
   82|      1|}
   83|       |
   84|      1|void testPoppingFromCopyDoesNotChangeOriginal() {
   85|      1|    using valueType = int;
   86|      1|    stack<valueType> stackA;
   87|      1|    stackA.push(10);
   88|      1|    stackA.push(20);
   89|      1|    stackA.push(30);
   90|      1|    auto stackB(stackA);
   91|      1|    stackB.pop();
   92|       |
   93|      1|    const auto expectedDataA = std::vector<valueType>({30, 20, 10});
   94|      1|    const auto expectedDataB = std::vector<valueType>({20, 10});
   95|       |
   96|      1|    assert(stackA.toVector() == expectedDataA);
   97|      0|    assert(stackB.toVector() == expectedDataB);
   98|      1|}
   99|       |
  100|      1|void testPushingToOrginalDoesNotChangeCopy() {
  101|      1|    using valueType = int;
  102|      1|    stack<valueType> stackA;
  103|      1|    stackA.push(10);
  104|      1|    stackA.push(20);
  105|      1|    stackA.push(30);
  106|      1|    const auto stackB(stackA);
  107|      1|    stackA.push(40);
  108|       |
  109|      1|    const auto expectedDataA = std::vector<valueType>({40, 30, 20, 10});
  110|      1|    const auto expectedDataB = std::vector<valueType>({30, 20, 10});
  111|       |
  112|      1|    assert(stackA.toVector() == expectedDataA);
  113|      0|    assert(stackB.toVector() == expectedDataB);
  114|      1|}
  115|       |
  116|      1|void testPoppingFromOrginalDoesNotChangeCopy() {
  117|      1|    using valueType = int;
  118|      1|    stack<valueType> stackA;
  119|      1|    stackA.push(10);
  120|      1|    stackA.push(20);
  121|      1|    stackA.push(30);
  122|      1|    const auto stackB(stackA);
  123|      1|    stackA.pop();
  124|       |
  125|      1|    const auto expectedDataA = std::vector<valueType>({20, 10});
  126|      1|    const auto expectedDataB = std::vector<valueType>({30, 20, 10});
  127|       |
  128|      1|    assert(stackA.toVector() == expectedDataA);
  129|      0|    assert(stackB.toVector() == expectedDataB);
  130|      1|}
  131|       |
  132|      1|void testAssign() {
  133|      1|    using valueType = int;
  134|      1|    stack<valueType> stackA;
  135|      1|    stackA.push(10);
  136|      1|    stackA.push(20);
  137|      1|    stackA.push(30);
  138|      1|    stack<valueType> stackB = stackA;
  139|      1|    stackA.pop();
  140|      1|    stackB.push(40);
  141|       |
  142|      1|    const auto expectedDataA = std::vector<valueType>({20, 10});
  143|      1|    const auto expectedDataB = std::vector<valueType>({40, 30, 20, 10});
  144|       |
  145|      1|    assert(stackA.toVector() == expectedDataA);
  146|      0|    assert(stackB.toVector() == expectedDataB);
  147|       |
  148|      0|    stackB = stackA;
  149|      1|    stackA.pop();
  150|      1|    stackB.push(5);
  151|      1|    stackB.push(6);
  152|       |
  153|      1|    const auto otherExpectedDataA = std::vector<valueType>({10});
  154|      1|    const auto otherExpectedDataB = std::vector<valueType>({6, 5, 20, 10});
  155|       |
  156|      1|    assert(stackA.toVector() == otherExpectedDataA);
  157|      0|    assert(stackB.toVector() == otherExpectedDataB);
  158|      1|}
  159|       |
  160|      1|void testTopThrowsAnInvalidArgumentWhenStackEmpty() {
  161|      1|    const stack<long double> curStack;
  162|      1|    bool wasException = false;
  163|      1|    try {
  164|      1|        curStack.top();
  165|      1|    } catch (const std::invalid_argument&) {
  166|      1|        wasException = true;
  167|      1|    }
  168|      1|    assert(wasException);
  169|      1|}
  170|       |
  171|      1|void testPopThrowsAnInvalidArgumentWhenStackEmpty() {
  172|      1|    stack<bool> curStack;
  173|      1|    bool wasException = false;
  174|      1|    try {
  175|      1|        curStack.pop();
  176|      1|    } catch (const std::invalid_argument&) {
  177|      1|        wasException = true;
  178|      1|    }
  179|      1|    assert(wasException);
  180|      1|}
  181|       |
  182|      1|int main() {
  183|      1|    testConstructedStackIsEmpty<int>();
  184|      1|    testConstructedStackIsEmpty<char>();
  185|       |
  186|      1|    testPush();
  187|      1|    testPop();
  188|      1|    testClear();
  189|       |
  190|      1|    testCopyOfStackHasSameData();
  191|      1|    testPushingToCopyDoesNotChangeOriginal();
  192|      1|    testPoppingFromCopyDoesNotChangeOriginal();
  193|      1|    testPushingToOrginalDoesNotChangeCopy();
  194|      1|    testPoppingFromOrginalDoesNotChangeCopy();
  195|       |
  196|      1|    testAssign();
  197|       |
  198|      1|    testTopThrowsAnInvalidArgumentWhenStackEmpty();
  199|      1|    testPopThrowsAnInvalidArgumentWhenStackEmpty();
  200|       |
  201|      1|    std::cout << "All tests pass!\n";
  202|      1|    return 0;
  203|      1|}

