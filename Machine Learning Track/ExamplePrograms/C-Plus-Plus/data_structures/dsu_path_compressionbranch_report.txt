    1|       |/**
    2|       | * @file
    3|       | * @brief [DSU (Disjoint
    4|       | * sets)](https://en.wikipedia.org/wiki/Disjoint-set-data_structure)
    5|       | * @details
    6|       | * It is a very powerful data structure that keeps track of different
    7|       | * clusters(sets) of elements, these sets are disjoint(doesnot have a common
    8|       | * element). Disjoint sets uses cases : for finding connected components in a
    9|       | * graph, used in Kruskal's algorithm for finding Minimum Spanning tree.
   10|       | * Operations that can be performed:
   11|       | * 1) UnionSet(i,j): add(element i and j to the set)
   12|       | * 2) findSet(i): returns the representative of the set to which i belogngs to.
   13|       | * 3) get_max(i),get_min(i) : returns the maximum and minimum
   14|       | * Below is the class-based approach which uses the heuristic of path
   15|       | * compression. Using path compression in findSet(i),we are able to get to the
   16|       | * representative of i in O(1) time.
   17|       | * @author [AayushVyasKIIT](https://github.com/AayushVyasKIIT)
   18|       | * @see dsu_union_rank.cpp
   19|       | */
   20|       |
   21|       |#include <cassert>   /// for assert
   22|       |#include <cstdint>
   23|       |#include <iostream>  /// for IO operations
   24|       |#include <vector>    /// for std::vector
   25|       |
   26|       |using std::cout;
   27|       |using std::endl;
   28|       |using std::vector;
   29|       |
   30|       |/**
   31|       | * @brief Disjoint sets union data structure, class based representation.
   32|       | * @param n number of elements
   33|       | */
   34|       |class dsu {
   35|       | private:
   36|       |    vector<uint64_t> p;           ///< keeps track of the parent of ith element
   37|       |    vector<uint64_t> depth;       ///< tracks the depth(rank) of i in the tree
   38|       |    vector<uint64_t> setSize;     ///< size of each chunk(set)
   39|       |    vector<uint64_t> maxElement;  ///< maximum of each set to which i belongs to
   40|       |    vector<uint64_t> minElement;  ///< minimum of each set to which i belongs to
   41|       | public:
   42|       |    /**
   43|       |     * @brief contructor for initialising all data members.
   44|       |     * @param n number of elements
   45|       |     */
   46|      3|    explicit dsu(uint64_t n) {
   47|      3|        p.assign(n, 0);
   48|       |        /// initially, all of them are their own parents
   49|     36|        for (uint64_t i = 0; i < n; i++) {
   50|     33|            p[i] = i;
   51|     33|        }
   52|       |        /// initially all have depth are equals to zero
   53|      3|        depth.assign(n, 0);
   54|      3|        maxElement.assign(n, 0);
   55|      3|        minElement.assign(n, 0);
   56|     36|        for (uint64_t i = 0; i < n; i++) {
   57|     33|            depth[i] = 0;
   58|     33|            maxElement[i] = i;
   59|     33|            minElement[i] = i;
   60|     33|        }
   61|      3|        setSize.assign(n, 0);
   62|       |        /// initially set size will be equals to one
   63|     36|        for (uint64_t i = 0; i < n; i++) {
   64|     33|            setSize[i] = 1;
   65|     33|        }
   66|      3|    }
   67|       |
   68|       |    /**
   69|       |     * @brief Method to find the representative of the set to which i belongs
   70|       |     * to, T(n) = O(1)
   71|       |     * @param i element of some set
   72|       |     * @returns representative of the set to which i belongs to.
   73|       |     */
   74|     58|    uint64_t findSet(uint64_t i) {
   75|       |        /// using path compression
   76|     58|        if (p[i] == i) {
   77|     38|            return i;
   78|     38|        }
   79|     20|        return (p[i] = findSet(p[i]));
   80|     58|    }
   81|       |    /**
   82|       |     * @brief Method that combines two disjoint sets to which i and j belongs to
   83|       |     * and make a single set having a common representative.
   84|       |     * @param i element of some set
   85|       |     * @param j element of some set
   86|       |     * @returns void
   87|       |     */
   88|      5|    void UnionSet(uint64_t i, uint64_t j) {
   89|       |        /// check if both belongs to the same set or not
   90|      5|        if (isSame(i, j)) {
   91|      0|            return;
   92|      0|        }
   93|       |
   94|       |        // we find the representative of the i and j
   95|      5|        uint64_t x = findSet(i);
   96|      5|        uint64_t y = findSet(j);
   97|       |
   98|       |        /// always keeping the min as x
   99|       |        /// shallow tree
  100|      5|        if (depth[x] > depth[y]) {
  101|      3|            std::swap(x, y);
  102|      3|        }
  103|       |        /// making the shallower root's parent the deeper root
  104|      5|        p[x] = y;
  105|       |
  106|       |        /// if same depth, then increase one's depth
  107|      5|        if (depth[x] == depth[y]) {
  108|      2|            depth[y]++;
  109|      2|        }
  110|       |        /// total size of the resultant set
  111|      5|        setSize[y] += setSize[x];
  112|       |        /// changing the maximum elements
  113|      5|        maxElement[y] = std::max(maxElement[x], maxElement[y]);
  114|      5|        minElement[y] = std::min(minElement[x], minElement[y]);
  115|      5|    }
  116|       |    /**
  117|       |     * @brief A utility function which check whether i and j belongs to
  118|       |     * same set or not
  119|       |     * @param i element of some set
  120|       |     * @param j element of some set
  121|       |     * @returns `true` if element `i` and `j` ARE in the same set
  122|       |     * @returns `false` if element `i` and `j` are NOT in same set
  123|       |     */
  124|      5|    bool isSame(uint64_t i, uint64_t j) {
  125|      5|        if (findSet(i) == findSet(j)) {
  126|      0|            return true;
  127|      0|        }
  128|      5|        return false;
  129|      5|    }
  130|       |    /**
  131|       |     * @brief prints the minimum, maximum and size of the set to which i belongs
  132|       |     * to
  133|       |     * @param i element of some set
  134|       |     * @returns void
  135|       |     */
  136|      6|    vector<uint64_t> get(uint64_t i) {
  137|      6|        vector<uint64_t> ans;
  138|      6|        ans.push_back(get_min(i));
  139|      6|        ans.push_back(get_max(i));
  140|      6|        ans.push_back(size(i));
  141|      6|        return ans;
  142|      6|    }
  143|       |    /**
  144|       |     * @brief A utility function that returns the size of the set to which i
  145|       |     * belongs to
  146|       |     * @param i element of some set
  147|       |     * @returns size of the set to which i belongs to
  148|       |     */
  149|      6|    uint64_t size(uint64_t i) { return setSize[findSet(i)]; }
  150|       |    /**
  151|       |     * @brief A utility function that returns the max element of the set to
  152|       |     * which i belongs to
  153|       |     * @param i element of some set
  154|       |     * @returns maximum of the set to which i belongs to
  155|       |     */
  156|      6|    uint64_t get_max(uint64_t i) { return maxElement[findSet(i)]; }
  157|       |    /**
  158|       |     * @brief A utility function that returns the min element of the set to
  159|       |     * which i belongs to
  160|       |     * @param i element of some set
  161|       |     * @returns minimum of the set to which i belongs to
  162|       |     */
  163|      6|    uint64_t get_min(uint64_t i) { return minElement[findSet(i)]; }
  164|       |};
  165|       |
  166|       |/**
  167|       | * @brief Self-test implementations, 1st test
  168|       | * @returns void
  169|       | */
  170|      1|static void test1() {
  171|       |    // the minimum, maximum, and size of the set
  172|      1|    uint64_t n = 10;  ///< number of items
  173|      1|    dsu d(n + 1);     ///< object of class disjoint sets
  174|       |    // set 1
  175|      1|    d.UnionSet(1, 2);  // performs union operation on 1 and 2
  176|      1|    d.UnionSet(1, 4);  // performs union operation on 1 and 4
  177|      1|    vector<uint64_t> ans = {1, 4, 3};
  178|      4|    for (uint64_t i = 0; i < ans.size(); i++) {
  179|      3|        assert(d.get(4).at(i) == ans[i]);  // makes sure algorithm works fine
  180|      3|    }
  181|      1|    cout << "1st test passed!" << endl;
  182|      1|}
  183|       |/**
  184|       | * @brief Self-implementations, 2nd test
  185|       | * @returns void
  186|       | */
  187|      1|static void test2() {
  188|       |    // the minimum, maximum, and size of the set
  189|      1|    uint64_t n = 10;  ///< number of items
  190|      1|    dsu d(n + 1);     ///< object of class disjoint sets
  191|       |    // set 1
  192|      1|    d.UnionSet(3, 5);
  193|      1|    d.UnionSet(5, 6);
  194|      1|    d.UnionSet(5, 7);
  195|      1|    vector<uint64_t> ans = {3, 7, 4};
  196|      4|    for (uint64_t i = 0; i < ans.size(); i++) {
  197|      3|        assert(d.get(3).at(i) == ans[i]);  // makes sure algorithm works fine
  198|      3|    }
  199|      1|    cout << "2nd test passed!" << endl;
  200|      1|}
  201|       |
  202|       |/**
  203|       | * @brief Main function
  204|       | * @returns 0 on exit
  205|       | * */
  206|      1|int main() {
  207|      1|    uint64_t n = 10;  ///< number of items
  208|      1|    dsu d(n + 1);     ///< object of class disjoint sets
  209|       |
  210|      1|    test1();  // run 1st test case
  211|      1|    test2();  // run 2nd test case
  212|       |
  213|      1|    return 0;
  214|      1|}

