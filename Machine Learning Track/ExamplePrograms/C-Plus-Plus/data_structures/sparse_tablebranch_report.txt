    1|       |/**
    2|       | * @file
    3|       | * @brief Implementation of [Sparse
    4|       | * Table](https://brilliant.org/wiki/sparse-table/) for `min()` function.
    5|       | * @author [Mann Patel](https://github.com/manncodes)
    6|       | * @details
    7|       | * Sparse Table is a data structure, that allows answering range queries.
    8|       | * It can answer most range queries in O(logn), but its true power is answering
    9|       | * range minimum queries (or equivalent range maximum queries). For those
   10|       | * queries it can compute the answer in O(1) time. The only drawback of this
   11|       | * data structure is, that it can only be used on immutable arrays. This means,
   12|       | * that the array cannot be changed between two queries.
   13|       | *
   14|       | * If any element in the array changes, the complete data structure has to be
   15|       | * recomputed.
   16|       | *
   17|       | * @todo make stress tests.
   18|       | *
   19|       | * @warning
   20|       | * This sparse table is made for `min(a1,a2,...an)` duplicate invariant
   21|       | * function. This implementation can be changed to other functions like
   22|       | * `gcd()`, `lcm()`, and `max()` by changing a few lines of code.
   23|       | */
   24|       |
   25|       |#include <array>     /// for std::array
   26|       |#include <cassert>   /// for assert
   27|       |#include <cstdint>
   28|       |#include <iostream>  /// for IO operations
   29|       |
   30|       |/**
   31|       | * @namespace data_structures
   32|       | * @brief Data Structures algorithms
   33|       | */
   34|       |namespace data_structures {
   35|       |
   36|       |/**
   37|       | * @namespace sparse_table
   38|       | * @brief Functions for Implementation of [Sparse
   39|       | * Table](https://brilliant.org/wiki/sparse-table/)
   40|       | */
   41|       |namespace sparse_table {
   42|       |
   43|       |/**
   44|       | * @brief A struct to represent sparse table for `min()` as their invariant
   45|       | * function, for the given array `A`. The answer to queries are stored in the
   46|       | * array ST.
   47|       | */
   48|       |constexpr uint32_t N = 12345;  ///< the maximum size of the array.
   49|       |constexpr uint8_t M = 14;      ///< ceil(log2(N)).
   50|       |
   51|       |struct Sparse_table {
   52|       |    size_t n = 0;  ///< size of input array.
   53|       |
   54|       |    /** @warning check if `N` is not less than `n`. if so, manually increase the
   55|       |     * value of N */
   56|       |
   57|       |    std::array<int64_t, N> A = {};  ///< input array to perform RMQ.
   58|       |    std::array<std::array<int64_t, N>, M>
   59|       |        ST{};  ///< the sparse table storing `min()` values for given interval.
   60|       |    std::array<int64_t, N> LOG = {};  ///< where floor(log2(i)) are precomputed.
   61|       |
   62|       |    /**
   63|       |     * @brief Builds the sparse table for computing min/max/gcd/lcm/...etc
   64|       |     * for any contiguous sub-segment of the array.This is an example of
   65|       |     * computing the index of the minimum value.
   66|       |     * @return void
   67|       |     * @complexity: O(n.log(n))
   68|       |     */
   69|      1|    void buildST() {
   70|      1|        LOG[0] = -1;
   71|       |
   72|     11|        for (size_t i = 0; i < n; ++i) {
   73|     10|            ST[0][i] = static_cast<int64_t>(i);
   74|     10|            LOG[i + 1] = LOG[i] + !(i & (i + 1));  ///< precomputing `log2(i+1)`
   75|     10|        }
   76|       |
   77|      4|        for (size_t j = 1; static_cast<size_t>(1 << j) <= n; ++j) {
   78|     22|            for (size_t i = 0; static_cast<size_t>(i + (1 << j)) <= n; ++i) {
   79|       |                /**
   80|       |                 * @note notice how we deal with the range of length `pow(2,i)`,
   81|       |                 * and we can reuse the computation that we did for the range of
   82|       |                 * length `pow(2,i-1)`.
   83|       |                 *
   84|       |                 * So, ST[j][i] = min( ST[j-1][i], ST[j-1][i + pow(2,j-1)]).
   85|       |                 * @example ST[2][3] = min(ST[1][3], ST[1][5])
   86|       |                 */
   87|       |
   88|     19|                int64_t x = ST[j - 1][i];  ///< represents minimum value over
   89|       |                                           ///< the range [j,i]
   90|     19|                int64_t y =
   91|     19|                    ST[j - 1]
   92|     19|                      [i + (1 << (j - 1))];  ///< represents minimum value over
   93|       |                                             ///< the range [j,i + pow(2,j-1)]
   94|       |
   95|     19|                ST[j][i] =
   96|     19|                    (A[x] <= A[y] ? x : y);  ///< represents minimum value over
   97|       |                                             ///< the range [j,i]
   98|     19|            }
   99|      3|        }
  100|      1|    }
  101|       |
  102|       |    /**
  103|       |     * @brief Queries the sparse table for the value of the interval [l, r]
  104|       |     * (i.e. from l to r inclusive).
  105|       |     * @param l the left index of the range (inclusive).
  106|       |     * @param r the right index of the range (inclusive).
  107|       |     * @return the computed value of the given interval.
  108|       |     * @complexity: O(1)
  109|       |     */
  110|      3|    int64_t query(int64_t l, int64_t r) {
  111|      3|        int64_t g = LOG[r - l + 1];  ///< smallest power of 2 covering [l,r]
  112|      3|        int64_t x = ST[g][l];  ///< represents minimum value over the range
  113|       |                               ///< [g,l]
  114|      3|        int64_t y =
  115|      3|            ST[g][r - (1 << g) + 1];  ///< represents minimum value over the
  116|       |                                      ///< range [g, r - pow(2,g) + 1]
  117|       |
  118|      3|        return (A[x] <= A[y] ? x : y);  ///< represents minimum value over
  119|       |                                        ///< the whole range [l,r]
  120|      3|    }
  121|       |};
  122|       |}  // namespace sparse_table
  123|       |}  // namespace data_structures
  124|       |
  125|       |/**
  126|       | * @brief Self-test implementations
  127|       | * @returns void
  128|       | */
  129|      1|static void test() {
  130|       |    /* We take an array as an input on which we need to perform the ranged
  131|       |     * minimum queries[RMQ](https://en.wikipedia.org/wiki/Range_minimum_query).
  132|       |     */
  133|      1|    std::array<int64_t, 10> testcase = {
  134|      1|        1, 2, 3, 4, 5,
  135|      1|        6, 7, 8, 9, 10};  ///< array on which RMQ will be performed.
  136|      1|    size_t testcase_size =
  137|      1|        sizeof(testcase) / sizeof(testcase[0]);  ///< size of self test's array
  138|       |
  139|      1|    data_structures::sparse_table::Sparse_table
  140|      1|        st{};  ///< declaring sparse tree
  141|       |
  142|      1|    std::copy(std::begin(testcase), std::end(testcase),
  143|      1|              std::begin(st.A));  ///< copying array to the struct
  144|      1|    st.n = testcase_size;         ///< passing the array's size to the struct
  145|       |
  146|      1|    st.buildST();  ///< precomputing sparse tree
  147|       |
  148|       |    // pass queries of the form: [l,r]
  149|      1|    assert(st.query(1, 9) == 1);  ///< as 1 is smallest from 1..9
  150|      0|    assert(st.query(2, 6) == 2);  ///< as 2 is smallest from 2..6
  151|      0|    assert(st.query(3, 8) == 3);  ///< as 3 is smallest from 3..8
  152|       |
  153|      0|    std::cout << "Self-test implementations passed!" << std::endl;
  154|      1|}
  155|       |
  156|       |/**
  157|       | * @brief Main function
  158|       | * @param argc commandline argument count (ignored)
  159|       | * @param argv commandline array of arguments (ignored)
  160|       | * @returns 0 on exit
  161|       | */
  162|      1|int main(int argc, char *argv[]) {
  163|      1|    test();  // run self-test implementations
  164|      1|    return 0;
  165|      1|}

