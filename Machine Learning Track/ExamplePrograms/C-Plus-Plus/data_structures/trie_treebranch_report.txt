    1|       |/**
    2|       | * @file
    3|       | * @author [@Arctic2333](https://github.com/Arctic2333)
    4|       | * @author [Krishna Vedala](https://github.com/kvedala)
    5|       | * @brief Implementation of [Trie](https://en.wikipedia.org/wiki/Trie) data
    6|       | * structure for English alphabets in small characters.
    7|       | * @note the function ::data_structure::trie::deleteString might be erroneous
    8|       | * @see trie_modern.cpp
    9|       | */
   10|       |#include <array>
   11|       |#include <cassert>
   12|       |#include <iostream>
   13|       |#include <memory>
   14|       |#include <string>
   15|       |#include <vector>
   16|       |
   17|       |/** \namespace data_structures
   18|       | * \brief Data-structure algorithms
   19|       | */
   20|       |namespace data_structures {
   21|       |/**
   22|       | * @brief [Trie](https://en.wikipedia.org/wiki/Trie) implementation for
   23|       | * small-case English alphabets `a-z`
   24|       | */
   25|       |class trie {
   26|       | private:
   27|       |    static constexpr uint8_t NUM_CHARS = 26;  ///< Number of alphabets
   28|       |    /** @brief Recursive tree nodes as an array of shared-pointers */
   29|       |    std::array<std::shared_ptr<trie>, NUM_CHARS << 1> arr;
   30|       |    bool isEndofWord = false;  ///< identifier if a node is terminal node
   31|       |
   32|       |    /**
   33|       |     * @brief Convert a character to integer for indexing
   34|       |     *
   35|       |     * @param ch character to index
   36|       |     * @return unsigned integer index
   37|       |     */
   38|     40|    uint8_t char_to_int(const char& ch) const {
   39|     40|        if (ch >= 'A' && ch <= 'Z') {
   40|      8|            return ch - 'A';
   41|     32|        } else if (ch >= 'a' && ch <= 'z') {
   42|     32|            return ch - 'a' + NUM_CHARS;
   43|     32|        }
   44|       |
   45|      0|        std::cerr << "Invalid character present. Exiting...";
   46|      0|        std::exit(EXIT_FAILURE);
   47|      0|        return 0;
   48|     40|    }
   49|       |
   50|       |    /** search a string exists inside a given root trie
   51|       |     * @param str string to search for
   52|       |     * @param index start index to search from
   53|       |     * @returns `true` if found
   54|       |     * @returns `false` if not found
   55|       |     */
   56|       |    bool search(const std::shared_ptr<trie>& root, const std::string& str,
   57|     26|                int index) {
   58|     26|        if (index == str.length()) {
   59|      4|            if (!root->isEndofWord) {
   60|      0|                return false;
   61|      0|            }
   62|      4|            return true;
   63|      4|        }
   64|     22|        int j = char_to_int(str[index]);
   65|     22|        if (!root->arr[j]) {
   66|      2|            return false;
   67|      2|        }
   68|     20|        return search(root->arr[j], str, index + 1);
   69|     22|    }
   70|       |
   71|       | public:
   72|     11|    trie() = default;  ///< Class default constructor
   73|       |
   74|       |    /** insert string into the trie
   75|       |     * @param str String to insert in the tree
   76|       |     */
   77|      2|    void insert(const std::string& str) {
   78|      2|        std::shared_ptr<trie> root(nullptr);
   79|       |
   80|     10|        for (const char& ch : str) {
   81|     10|            int j = char_to_int(ch);
   82|     10|            if (root) {
   83|      8|                if (root->arr[j]) {
   84|      0|                    root = root->arr[j];
   85|      8|                } else {
   86|      8|                    std::shared_ptr<trie> temp(new trie());
   87|      8|                    root->arr[j] = temp;
   88|      8|                    root = temp;
   89|      8|                }
   90|      8|            } else if (arr[j]) {
   91|      0|                root = arr[j];
   92|      2|            } else {
   93|      2|                std::shared_ptr<trie> temp(new trie());
   94|      2|                arr[j] = temp;
   95|      2|                root = temp;
   96|      2|            }
   97|     10|        }
   98|      2|        root->isEndofWord = true;
   99|      2|    }
  100|       |
  101|       |    /** search a string exists inside the trie
  102|       |     * @param str string to search for
  103|       |     * @param index start index to search from
  104|       |     * @returns `true` if found
  105|       |     * @returns `false` if not found
  106|       |     */
  107|      8|    bool search(const std::string& str, int index) {
  108|      8|        if (index == str.length()) {
  109|      0|            if (!isEndofWord) {
  110|      0|                return false;
  111|      0|            }
  112|      0|            return true;
  113|      0|        }
  114|      8|        int j = char_to_int(str[index]);
  115|      8|        if (!arr[j]) {
  116|      2|            return false;
  117|      2|        }
  118|      6|        return search(arr[j], str, index + 1);
  119|      8|    }
  120|       |
  121|       |    /**
  122|       |     * removes the string if it is not a prefix of any  other
  123|       |     * string, if it is then just sets the ::data_structure::trie::isEndofWord
  124|       |     * to false, else removes the given string
  125|       |     * @note the function ::data_structure::trie::deleteString might be
  126|       |     * erroneous
  127|       |     * @todo review the function ::data_structure::trie::deleteString and the
  128|       |     * commented lines
  129|       |     * @param str string to remove
  130|       |     * @param index index to remove from
  131|       |     * @returns `true` if successful
  132|       |     * @returns `false` if unsuccessful
  133|       |     */
  134|      0|    bool deleteString(const std::string& str, int index) {
  135|      0|        if (index == str.length()) {
  136|      0|            if (!isEndofWord) {
  137|      0|                return false;
  138|      0|            }
  139|      0|            isEndofWord = false;
  140|      0|            // following lines - possible source of error?
  141|      0|            // for (int i = 0; i < NUM_CHARS; i++)
  142|      0|            //     if (!arr[i])
  143|      0|            //         return false;
  144|      0|            return true;
  145|      0|        }
  146|      0|        int j = char_to_int(str[index]);
  147|      0|        if (!arr[j]) {
  148|      0|            return false;
  149|      0|        }
  150|      0|        bool var = deleteString(str, index + 1);
  151|      0|        if (var) {
  152|      0|            arr[j].reset();
  153|      0|            if (isEndofWord) {
  154|      0|                return false;
  155|      0|            } else {
  156|      0|                int i = 0;
  157|      0|                for (i = 0; i < NUM_CHARS; i++) {
  158|      0|                    if (arr[i]) {
  159|      0|                        return false;
  160|      0|                    }
  161|      0|                }
  162|      0|                return true;
  163|      0|            }
  164|      0|        }
  165|      0|
  166|      0|        /* should not return here */
  167|      0|        std::cout << __func__ << ":" << __LINE__
  168|      0|                  << "Should not reach this line\n";
  169|      0|        return false;
  170|      0|    }
  171|       |};
  172|       |}  // namespace data_structures
  173|       |
  174|       |/**
  175|       | * @brief Testing function
  176|       | * @returns void
  177|       | */
  178|      1|static void test() {
  179|      1|    data_structures::trie root;
  180|      1|    root.insert("Hello");
  181|      1|    root.insert("World");
  182|       |
  183|      1|    assert(!root.search("hello", 0));
  184|      0|    std::cout << "hello - " << root.search("hello", 0) << "\n";
  185|       |
  186|      1|    assert(root.search("Hello", 0));
  187|      0|    std::cout << "Hello - " << root.search("Hello", 0) << "\n";
  188|       |
  189|      1|    assert(!root.search("Word", 0));
  190|      0|    std::cout << "Word - " << root.search("Word", 0) << "\n";
  191|       |
  192|      1|    assert(root.search("World", 0));
  193|      0|    std::cout << "World - " << root.search("World", 0) << "\n";
  194|       |
  195|       |    // Following lines of code give erroneous output
  196|       |    // root.deleteString("hello", 0);
  197|       |    // assert(!root.search("hello", 0));
  198|       |    // std::cout << "hello - " << root.search("world", 0) << "\n";
  199|      1|}
  200|       |
  201|       |/**
  202|       | * @brief Main function
  203|       | * @return 0 on exit
  204|       | */
  205|      1|int main() {
  206|      1|    test();
  207|       |
  208|      1|    return 0;
  209|      1|}

