    1|       |/**
    2|       | * @file
    3|       | * @author [Krishna Vedala](https://github.com/kvedala)
    4|       | * @brief Implementation of
    5|       | * [Spirograph](https://en.wikipedia.org/wiki/Spirograph)
    6|       | *
    7|       | * @details
    8|       | * Implementation of the program is based on the geometry shown in the figure
    9|       | * below:
   10|       | *
   11|       | * <a
   12|       | * href="https://commons.wikimedia.org/wiki/File:Resonance_Cascade.svg"><img
   13|       | * src="https://upload.wikimedia.org/wikipedia/commons/3/39/Resonance_Cascade.svg"
   14|       | * alt="Spirograph geometry from Wikipedia" style="width: 250px"/></a>
   15|       | */
   16|       |#ifdef USE_GLUT
   17|       |#ifdef __APPLE__
   18|       |#include <GLUT/glut.h>  // include path on Macs is different
   19|       |#else
   20|       |#include <GL/glut.h>
   21|       |#endif  // __APPLE__
   22|       |#endif
   23|       |#define _USE_MATH_DEFINES /**< required for MSVC compiler */
   24|       |#include <array>
   25|       |#include <cmath>
   26|       |#include <cstdlib>
   27|       |#include <ctime>
   28|       |#include <fstream>
   29|       |#include <iomanip>
   30|       |#include <iostream>
   31|       |#include <sstream>
   32|       |#ifdef _OPENMP
   33|       |#include <omp.h>
   34|       |#endif
   35|       |
   36|       |/**
   37|       | * @namespace spirograph Functions related to spirograph.cpp
   38|       | */
   39|       |namespace spirograph {
   40|       |/** Generate spirograph curve into arrays `x` and `y` such that the i^th point
   41|       | * in 2D is represented by `(x[i],y[i])`. The generating function is given by:
   42|       | * \f{eqnarray*}{
   43|       | * x &=& R\left[ (1-k) \cos (t) + l\cdot k\cdot\cos \left(\frac{1-k}{k}t\right)
   44|       | * \right]\\
   45|       | * y &=& R\left[ (1-k) \sin (t) - l\cdot k\cdot\sin \left(\frac{1-k}{k}t\right)
   46|       | * \right] \f}
   47|       | * where
   48|       | * * \f$R\f$ is the scaling parameter that we will consider \f$=1\f$
   49|       | * * \f$l=\frac{\rho}{r}\f$ is the relative distance of marker from the centre
   50|       | * of inner circle and \f$0\le l\le1\f$
   51|       | * * \f$\rho\f$ is physical distance of marker from centre of inner circle
   52|       | * * \f$r\f$ is the radius of inner circle
   53|       | * * \f$k=\frac{r}{R}\f$ is the ratio of radius of inner circle to outer circle
   54|       | * and \f$0<k<1\f$
   55|       | * * \f$R\f$ is the radius of outer circle
   56|       | * * \f$t\f$ is the angle of rotation of the point i.e., represents the time
   57|       | * parameter
   58|       | *
   59|       | * Since we are considering ratios, the actual values of \f$r\f$ and
   60|       | * \f$R\f$ are immaterial.
   61|       | *
   62|       | * @tparam N number of points = size of array
   63|       | * @param [out] points Array of 2D points represented as std::pair
   64|       | * @param l the relative distance of marker from the centre of
   65|       | * inner circle and \f$0\le l\le1\f$
   66|       | * @param k the ratio of radius of inner circle to outer circle and \f$0<k<1\f$
   67|       | * @param rot the number of rotations to perform (can be fractional value)
   68|       | */
   69|       |template <std::size_t N>
   70|       |void spirograph(std::array<std::pair<double, double>, N> *points, double l,
   71|      1|                double k, double rot) {
   72|      1|    double dt = rot * 2.f * M_PI / N;
   73|      1|    double R = 1.f;
   74|      1|    const double k1 = 1.f - k;
   75|      1|    int32_t step = 0;
   76|       |
   77|       |#ifdef _OPENMP
   78|       |#pragma omp for
   79|       |#endif
   80|    501|    for (step = 0; step < N; step++) {
   81|    500|        double t = dt * step;
   82|    500|        double first = R * (k1 * std::cos(t) + l * k * std::cos(k1 * t / k));
   83|    500|        double second = R * (k1 * std::sin(t) - l * k * std::sin(k1 * t / k));
   84|    500|        points[0][step].first = first;
   85|    500|        points[0][step].second = second;
   86|    500|    }
   87|      1|}
   88|       |
   89|       |/**
   90|       | * @brief Test function to save resulting points to a CSV file.
   91|       | *
   92|       | */
   93|      1|void test() {
   94|      1|    const size_t N = 500;
   95|      1|    double l = 0.3, k = 0.75, rot = 10.;
   96|      1|    std::stringstream fname;
   97|      1|    fname << std::setw(3) << "spirograph_" << l << "_" << k << "_" << rot
   98|      1|          << ".csv";
   99|      1|    std::ofstream fp(fname.str());
  100|      1|    if (!fp.is_open()) {
  101|      0|        perror(fname.str().c_str());
  102|      0|        exit(EXIT_FAILURE);
  103|      0|    }
  104|       |
  105|      1|    std::array<std::pair<double, double>, N> points;
  106|       |
  107|      1|    spirograph(&points, l, k, rot);
  108|       |
  109|    501|    for (size_t i = 0; i < N; i++) {
  110|    500|        fp << points[i].first << "," << points[i].first;
  111|    500|        if (i < N - 1) {
  112|    499|            fp << '\n';
  113|    499|        }
  114|    500|    }
  115|       |
  116|      1|    fp.close();
  117|      1|}
  118|       |
  119|       |#ifdef USE_GLUT
  120|       |static bool paused = 0; /**< flag to set pause/unpause animation */
  121|       |static const int animation_speed = 25; /**< animation delate in ms */
  122|       |
  123|       |static const double step = 0.01;   /**< animation step size */
  124|       |static double l_ratio = step * 10; /**< the l-ratio defined in docs */
  125|       |static double k_ratio = step;      /**< the k-ratio defined in docs */
  126|       |static const double num_rot = 20.; /**< number of rotations to simulate */
  127|       |
  128|       |/** A wrapper that is not available in all GLUT implementations.
  129|       | */
  130|       |static inline void glutBitmapString(void *font, char *message) {
  131|       |    for (char *ch = message; *ch != '\0'; ch++) glutBitmapCharacter(font, *ch);
  132|       |}
  133|       |
  134|       |/**
  135|       | * @brief Function to graph (x,y) points on the OpenGL graphics window.
  136|       | *
  137|       | * @tparam N number of points = size of array
  138|       | * @param [in] points Array of 2D points represented as std::pair
  139|       | * @param l the relative distance of marker from the centre of
  140|       | * inner circle and \f$0\le l\le1\f$ to display info
  141|       | * @param k the ratio of radius of inner circle to outer circle and \f$0<k<1\f$
  142|       | * to display info
  143|       | */
  144|       |template <size_t N>
  145|       |void display_graph(const std::array<std::pair<double, double>, N> &points,
  146|       |                   double l, double k) {
  147|       |    glClearColor(1.0f, 1.0f, 1.0f,
  148|       |                 0.0f);            // Set background color to white and opaque
  149|       |    glClear(GL_COLOR_BUFFER_BIT);  // Clear the color buffer (background)
  150|       |
  151|       |    glBegin(GL_LINES);         // draw line segments
  152|       |    glColor3f(0.f, 0.f, 1.f);  // blue
  153|       |    glPointSize(2.f);          // point size in pixels
  154|       |
  155|       |    for (size_t i = 1; i < N; i++) {
  156|       |        glVertex2f(points[i - 1].first, points[i - 1].second);  // line from
  157|       |        glVertex2f(points[i].first, points[i].second);          // line to
  158|       |    }
  159|       |    glEnd();
  160|       |
  161|       |    glColor3f(0.f, 0.f, 0.f);
  162|       |    std::stringstream buffer;
  163|       |    buffer << std::setw(3) << "l = " << l;
  164|       |    glRasterPos2f(-.85, .85);
  165|       |    glutBitmapString(GLUT_BITMAP_TIMES_ROMAN_24,
  166|       |                     const_cast<char *>(buffer.str().c_str()));
  167|       |    buffer.str("");
  168|       |    buffer.clear();
  169|       |    buffer << std::setw(3) << "k = " << k;
  170|       |    glRasterPos2f(-.85, .70);
  171|       |    glutBitmapString(GLUT_BITMAP_TIMES_ROMAN_24,
  172|       |                     const_cast<char *>(buffer.str().c_str()));
  173|       |
  174|       |    glutSwapBuffers();
  175|       |}
  176|       |
  177|       |/**
  178|       | * @brief Test function with animation
  179|       | *
  180|       | */
  181|       |void test2() {
  182|       |    const size_t N = 5000;  // number of samples
  183|       |
  184|       |    static bool direction1 = true;  // increment if true, otherwise decrement
  185|       |    static bool direction2 = true;  // increment if true, otherwise decrement
  186|       |
  187|       |    std::array<std::pair<double, double>, N> points;
  188|       |
  189|       |    spirograph(&points, l_ratio, k_ratio, num_rot);
  190|       |    display_graph(points, l_ratio, k_ratio);
  191|       |
  192|       |    if (paused)
  193|       |        // if paused, do not update l_ratio and k_ratio
  194|       |        return;
  195|       |
  196|       |    if (direction1) {                 // increment k_ratio
  197|       |        if (k_ratio >= (1.f - step))  // maximum limit
  198|       |            direction1 = false;       // reverse direction of k_ratio
  199|       |        else
  200|       |            k_ratio += step;
  201|       |    } else {                    // decrement k_ratio
  202|       |        if (k_ratio <= step) {  // minimum limit
  203|       |            direction1 = true;  // reverse direction of k_ratio
  204|       |
  205|       |            if (direction2) {                 // increment l_ratio
  206|       |                if (l_ratio >= (1.f - step))  // max limit of l_ratio
  207|       |                    direction2 = false;       // reverse direction of l_ratio
  208|       |                else
  209|       |                    l_ratio += step;
  210|       |            } else {                    // decrement l_ratio
  211|       |                if (l_ratio <= step)    // minimum limit of l_ratio
  212|       |                    direction2 = true;  // reverse direction of l_ratio
  213|       |                else
  214|       |                    l_ratio -= step;
  215|       |            }
  216|       |        } else {  // no min limit of k_ratio
  217|       |            k_ratio -= step;
  218|       |        }
  219|       |    }
  220|       |}
  221|       |
  222|       |/**
  223|       | * @brief GLUT timer callback function to add animation delay.
  224|       | */
  225|       |void timer_cb(int t) {
  226|       |    glutTimerFunc(animation_speed, timer_cb, 0);
  227|       |    glutPostRedisplay();
  228|       |}
  229|       |
  230|       |/**
  231|       | * @brief Keypress event call back function.
  232|       | *
  233|       | * @param key ID of the key pressed
  234|       | * @param x mouse pointer position at event
  235|       | * @param y mouse pointer position at event
  236|       | */
  237|       |void keyboard_cb(unsigned char key, int x, int y) {
  238|       |    switch (key) {
  239|       |        case ' ':              // spacebar toggles pause
  240|       |            paused = !paused;  // toggle
  241|       |            break;
  242|       |        case GLUT_KEY_UP:
  243|       |        case '+':  // up arrow key
  244|       |            k_ratio += step;
  245|       |            break;
  246|       |        case GLUT_KEY_DOWN:
  247|       |        case '_':  // down arrow key
  248|       |            k_ratio -= step;
  249|       |            break;
  250|       |        case GLUT_KEY_RIGHT:
  251|       |        case '=':  // left arrow key
  252|       |            l_ratio += step;
  253|       |            break;
  254|       |        case GLUT_KEY_LEFT:
  255|       |        case '-':  // right arrow key
  256|       |            l_ratio -= step;
  257|       |            break;
  258|       |        case 0x1B:  // escape key exits
  259|       |            exit(EXIT_SUCCESS);
  260|       |        default:
  261|       |            return;
  262|       |    }
  263|       |}
  264|       |#endif
  265|       |}  // namespace spirograph
  266|       |
  267|       |/** Main function */
  268|      1|int main(int argc, char **argv) {
  269|      1|    spirograph::test();
  270|       |
  271|       |#ifdef USE_GLUT
  272|       |    glutInit(&argc, argv);
  273|       |    glutInitDisplayMode(GLUT_RGB | GLUT_DOUBLE);
  274|       |    glutCreateWindow("Spirograph");
  275|       |    glutInitWindowSize(400, 400);
  276|       |    // glutIdleFunc(glutPostRedisplay);
  277|       |    glutTimerFunc(spirograph::animation_speed, spirograph::timer_cb, 0);
  278|       |    glutKeyboardFunc(spirograph::keyboard_cb);
  279|       |    glutDisplayFunc(spirograph::test2);
  280|       |    glutMainLoop();
  281|       |#endif
  282|       |
  283|      1|    return 0;
  284|      1|}

