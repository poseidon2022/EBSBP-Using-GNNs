    1|       |/**
    2|       | * @brief [Strassen's
    3|       | * algorithm](https://en.wikipedia.org/wiki/Strassen_algorithm) is one of the
    4|       | * methods for multiplying two matrices. It is one of the faster algorithms for
    5|       | * larger matrices than naive multiplication method.
    6|       | *
    7|       | * It involves dividing each matrices into 4 blocks, given they are evenly
    8|       | * divisible, and are combined with new defined matrices involving 7 matrix
    9|       | * multiplications instead of eight, yielding O(n^2.8073) complexity.
   10|       | *
   11|       | * @author [AshishYUO](https://github.com/AshishYUO)
   12|       | */
   13|       |#include <cassert>   /// For assert operation
   14|       |#include <chrono>    /// For std::chrono; time measurement
   15|       |#include <iostream>  /// For I/O operations
   16|       |#include <tuple>     /// For std::tuple
   17|       |#include <vector>    /// For creating dynamic arrays
   18|       |
   19|       |/**
   20|       | * @namespace divide_and_conquer
   21|       | * @brief Divide and Conquer algorithms
   22|       | */
   23|       |namespace divide_and_conquer {
   24|       |
   25|       |/**
   26|       | * @namespace strassens_multiplication
   27|       | * @brief Namespace for performing strassen's multiplication
   28|       | */
   29|       |namespace strassens_multiplication {
   30|       |
   31|       |/// Complement of 0 is a max integer.
   32|       |constexpr size_t MAX_SIZE = ~0ULL;
   33|       |/**
   34|       | * @brief Matrix class.
   35|       | */
   36|       |template <typename T,
   37|       |          typename = typename std::enable_if<
   38|       |              std::is_integral<T>::value || std::is_floating_point<T>::value,
   39|       |              bool>::type>
   40|       |class Matrix {
   41|       |    std::vector<std::vector<T>> _mat;
   42|       |
   43|       | public:
   44|       |    /**
   45|       |     * @brief Constructor
   46|       |     * @tparam Integer ensuring integers are being evaluated and not other
   47|       |     * data types.
   48|       |     * @param size denoting the size of Matrix as size x size
   49|       |     */
   50|       |    template <typename Integer,
   51|       |              typename = typename std::enable_if<
   52|       |                  std::is_integral<Integer>::value, Integer>::type>
   53|       |    explicit Matrix(const Integer size) {
   54|       |        for (size_t i = 0; i < size; ++i) {
   55|       |            _mat.emplace_back(std::vector<T>(size, 0));
   56|       |        }
   57|       |    }
   58|       |
   59|       |    /**
   60|       |     * @brief Constructor
   61|       |     * @tparam Integer ensuring integers are being evaluated and not other
   62|       |     * data types.
   63|       |     * @param rows denoting the total rows of Matrix
   64|       |     * @param cols denoting the total elements in each row of Matrix
   65|       |     */
   66|       |    template <typename Integer,
   67|       |              typename = typename std::enable_if<
   68|       |                  std::is_integral<Integer>::value, Integer>::type>
   69|  1.82k|    Matrix(const Integer rows, const Integer cols) {
   70|   136k|        for (size_t i = 0; i < rows; ++i) {
   71|   134k|            _mat.emplace_back(std::vector<T>(cols, 0));
   72|   134k|        }
   73|  1.82k|    }
   74|       |
   75|       |    /**
   76|       |     * @brief Get the matrix shape
   77|       |     * @returns pair of integer denoting total rows and columns
   78|       |     */
   79|  2.05k|    inline std::pair<size_t, size_t> size() const {
   80|  2.05k|        return {_mat.size(), _mat[0].size()};
   81|  2.05k|    }
   82|       |
   83|       |    /**
   84|       |     * @brief returns the address of the element at ith place
   85|       |     * (here ith row of the matrix)
   86|       |     * @tparam Integer any valid integer
   87|       |     * @param index index which is requested
   88|       |     * @returns the address of the element (here ith row or array)
   89|       |     */
   90|       |    template <typename Integer,
   91|       |              typename = typename std::enable_if<
   92|       |                  std::is_integral<Integer>::value, Integer>::type>
   93|   524k|    inline std::vector<T> &operator[](const Integer index) {
   94|   524k|        return _mat[index];
   95|   524k|    }
   96|       |
   97|       |    /**
   98|       |     * @brief Creates a new matrix and returns a part of it.
   99|       |     * @param row_start start of the row
  100|       |     * @param row_end end of the row
  101|       |     * @param col_start start of the col
  102|       |     * @param col_end end of the column
  103|       |     * @returns A slice of (row_end - row_start) x (col_end - col_start) size of
  104|       |     * array starting from row_start row and col_start column
  105|       |     */
  106|       |    Matrix slice(const size_t row_start, const size_t row_end = MAX_SIZE,
  107|       |                 const size_t col_start = MAX_SIZE,
  108|    456|                 const size_t col_end = MAX_SIZE) const {
  109|    456|        const size_t h_size =
  110|    456|            (row_end != MAX_SIZE ? row_end : _mat.size()) - row_start;
  111|    456|        const size_t v_size = (col_end != MAX_SIZE ? col_end : _mat[0].size()) -
  112|    456|                              (col_start != MAX_SIZE ? col_start : 0);
  113|    456|        Matrix result = Matrix<T>(h_size, v_size);
  114|       |
  115|    456|        const size_t v_start = (col_start != MAX_SIZE ? col_start : 0);
  116|  34.7k|        for (size_t i = 0; i < h_size; ++i) {
  117|  3.08M|            for (size_t j = 0; j < v_size; ++j) {
  118|  3.04M|                result._mat[i][j] = _mat[i + row_start][j + v_start];
  119|  3.04M|            }
  120|  34.3k|        }
  121|    456|        return result;
  122|    456|    }
  123|       |
  124|       |    /**
  125|       |     * @brief Horizontally stack the matrix (one after the other)
  126|       |     * @tparam Number any type of number
  127|       |     * @param other the other matrix: note that this array is not modified
  128|       |     * @returns void, but modifies the current array
  129|       |     */
  130|       |    template <typename Number, typename = typename std::enable_if<
  131|       |                                   std::is_integral<Number>::value ||
  132|       |                                       std::is_floating_point<Number>::value,
  133|       |                                   Number>::type>
  134|    114|    void h_stack(const Matrix<Number> &other) {
  135|    114|        assert(_mat.size() == other._mat.size());
  136|  8.69k|        for (size_t i = 0; i < other._mat.size(); ++i) {
  137|   770k|            for (size_t j = 0; j < other._mat[i].size(); ++j) {
  138|   761k|                _mat[i].push_back(other._mat[i][j]);
  139|   761k|            }
  140|  8.57k|        }
  141|    114|    }
  142|       |
  143|       |    /**
  144|       |     * @brief Horizontally stack the matrix (current matrix above the other)
  145|       |     * @tparam Number any type of number (Integer or floating point)
  146|       |     * @param other the other matrix: note that this array is not modified
  147|       |     * @returns void, but modifies the current array
  148|       |     */
  149|       |    template <typename Number, typename = typename std::enable_if<
  150|       |                                   std::is_integral<Number>::value ||
  151|       |                                       std::is_floating_point<Number>::value,
  152|       |                                   Number>::type>
  153|     57|    void v_stack(const Matrix<Number> &other) {
  154|     57|        assert(_mat[0].size() == other._mat[0].size());
  155|  4.34k|        for (size_t i = 0; i < other._mat.size(); ++i) {
  156|  4.28k|            _mat.emplace_back(std::vector<T>(other._mat[i].size()));
  157|   766k|            for (size_t j = 0; j < other._mat[i].size(); ++j) {
  158|   761k|                _mat.back()[j] = other._mat[i][j];
  159|   761k|            }
  160|  4.28k|        }
  161|     57|    }
  162|       |
  163|       |    /**
  164|       |     * @brief Add two matrices and returns a new matrix
  165|       |     * @tparam Number any real value to add
  166|       |     * @param other Other matrix to add to this
  167|       |     * @returns new matrix
  168|       |     */
  169|       |    template <typename Number, typename = typename std::enable_if<
  170|       |                                   std::is_integral<Number>::value ||
  171|       |                                       std::is_floating_point<Number>::value,
  172|       |                                   bool>::type>
  173|    627|    Matrix operator+(const Matrix<Number> &other) const {
  174|    627|        assert(this->size() == other.size());
  175|      0|        Matrix C = Matrix<Number>(_mat.size(), _mat[0].size());
  176|  47.7k|        for (size_t i = 0; i < _mat.size(); ++i) {
  177|  4.23M|            for (size_t j = 0; j < _mat[i].size(); ++j) {
  178|  4.19M|                C._mat[i][j] = _mat[i][j] + other._mat[i][j];
  179|  4.19M|            }
  180|  47.1k|        }
  181|    627|        return C;
  182|    627|    }
  183|       |
  184|       |    /**
  185|       |     * @brief Add another matrices to current matrix
  186|       |     * @tparam Number any real value to add
  187|       |     * @param other Other matrix to add to this
  188|       |     * @returns reference of current matrix
  189|       |     */
  190|       |    template <typename Number, typename = typename std::enable_if<
  191|       |                                   std::is_integral<Number>::value ||
  192|       |                                       std::is_floating_point<Number>::value,
  193|       |                                   bool>::type>
  194|       |    Matrix &operator+=(const Matrix<Number> &other) const {
  195|       |        assert(this->size() == other.size());
  196|       |        for (size_t i = 0; i < _mat.size(); ++i) {
  197|       |            for (size_t j = 0; j < _mat[i].size(); ++j) {
  198|       |                _mat[i][j] += other._mat[i][j];
  199|       |            }
  200|       |        }
  201|       |        return this;
  202|       |    }
  203|       |
  204|       |    /**
  205|       |     * @brief Subtract two matrices and returns a new matrix
  206|       |     * @tparam Number any real value to multiply
  207|       |     * @param other Other matrix to subtract to this
  208|       |     * @returns new matrix
  209|       |     */
  210|       |    template <typename Number, typename = typename std::enable_if<
  211|       |                                   std::is_integral<Number>::value ||
  212|       |                                       std::is_floating_point<Number>::value,
  213|       |                                   bool>::type>
  214|    399|    Matrix operator-(const Matrix<Number> &other) const {
  215|    399|        assert(this->size() == other.size());
  216|      0|        Matrix C = Matrix<Number>(_mat.size(), _mat[0].size());
  217|  30.4k|        for (size_t i = 0; i < _mat.size(); ++i) {
  218|  2.69M|            for (size_t j = 0; j < _mat[i].size(); ++j) {
  219|  2.66M|                C._mat[i][j] = _mat[i][j] - other._mat[i][j];
  220|  2.66M|            }
  221|  30.0k|        }
  222|    399|        return C;
  223|    399|    }
  224|       |
  225|       |    /**
  226|       |     * @brief Subtract another matrices to current matrix
  227|       |     * @tparam Number any real value to Subtract
  228|       |     * @param other Other matrix to Subtract to this
  229|       |     * @returns reference of current matrix
  230|       |     */
  231|       |    template <typename Number, typename = typename std::enable_if<
  232|       |                                   std::is_integral<Number>::value ||
  233|       |                                       std::is_floating_point<Number>::value,
  234|       |                                   bool>::type>
  235|       |    Matrix &operator-=(const Matrix<Number> &other) const {
  236|       |        assert(this->size() == other.size());
  237|       |        for (size_t i = 0; i < _mat.size(); ++i) {
  238|       |            for (size_t j = 0; j < _mat[i].size(); ++j) {
  239|       |                _mat[i][j] -= other._mat[i][j];
  240|       |            }
  241|       |        }
  242|       |        return this;
  243|       |    }
  244|       |
  245|       |    /**
  246|       |     * @brief Multiply two matrices and returns a new matrix
  247|       |     * @tparam Number any real value to multiply
  248|       |     * @param other Other matrix to multiply to this
  249|       |     * @returns new matrix
  250|       |     */
  251|       |    template <typename Number, typename = typename std::enable_if<
  252|       |                                   std::is_integral<Number>::value ||
  253|       |                                       std::is_floating_point<Number>::value,
  254|       |                                   bool>::type>
  255|      1|    inline Matrix operator*(const Matrix<Number> &other) const {
  256|      1|        assert(_mat[0].size() == other._mat.size());
  257|      0|        auto size = this->size();
  258|      1|        const size_t row = size.first, col = size.second;
  259|       |        // Main condition for applying strassen's method:
  260|       |        // 1: matrix should be a square matrix
  261|       |        // 2: matrix should be of even size (mat.size() % 2 == 0)
  262|      1|        return (row == col && (row & 1) == 0)
  263|      1|                   ? this->strassens_multiplication(other)
  264|      1|                   : this->naive_multiplication(other);
  265|      1|    }
  266|       |
  267|       |    /**
  268|       |     * @brief Multiply matrix with a number and returns a new matrix
  269|       |     * @tparam Number any real value to multiply
  270|       |     * @param other Other real number to multiply to current matrix
  271|       |     * @returns new matrix
  272|       |     */
  273|       |    template <typename Number, typename = typename std::enable_if<
  274|       |                                   std::is_integral<Number>::value ||
  275|       |                                       std::is_floating_point<Number>::value,
  276|       |                                   bool>::type>
  277|       |    inline Matrix operator*(const Number other) const {
  278|       |        Matrix C = Matrix<Number>(_mat.size(), _mat[0].size());
  279|       |        for (size_t i = 0; i < _mat.size(); ++i) {
  280|       |            for (size_t j = 0; j < _mat[i].size(); ++j) {
  281|       |                C._mat[i][j] = _mat[i][j] * other;
  282|       |            }
  283|       |        }
  284|       |        return C;
  285|       |    }
  286|       |
  287|       |    /**
  288|       |     * @brief Multiply a number to current matrix
  289|       |     * @tparam Number any real value to multiply
  290|       |     * @param other Other matrix to multiply to this
  291|       |     * @returns reference of current matrix
  292|       |     */
  293|       |    template <typename Number, typename = typename std::enable_if<
  294|       |                                   std::is_integral<Number>::value ||
  295|       |                                       std::is_floating_point<Number>::value,
  296|       |                                   bool>::type>
  297|       |    Matrix &operator*=(const Number other) const {
  298|       |        for (size_t i = 0; i < _mat.size(); ++i) {
  299|       |            for (size_t j = 0; j < _mat[i].size(); ++j) {
  300|       |                _mat[i][j] *= other;
  301|       |            }
  302|       |        }
  303|       |        return this;
  304|       |    }
  305|       |
  306|       |    /**
  307|       |     * @brief Naive multiplication performed on this
  308|       |     * @tparam Number any real value to multiply
  309|       |     * @param other Other matrix to multiply to this
  310|       |     * @returns new matrix
  311|       |     */
  312|       |    template <typename Number, typename = typename std::enable_if<
  313|       |                                   std::is_integral<Number>::value ||
  314|       |                                       std::is_floating_point<Number>::value,
  315|       |                                   bool>::type>
  316|    344|    Matrix naive_multiplication(const Matrix<Number> &other) const {
  317|    344|        Matrix C = Matrix<Number>(_mat.size(), other._mat[0].size());
  318|       |
  319|  22.8k|        for (size_t i = 0; i < _mat.size(); ++i) {
  320|  1.68M|            for (size_t k = 0; k < _mat[0].size(); ++k) {
  321|   225M|                for (size_t j = 0; j < other._mat[0].size(); ++j) {
  322|   224M|                    C._mat[i][j] += _mat[i][k] * other._mat[k][j];
  323|   224M|                }
  324|  1.66M|            }
  325|  22.4k|        }
  326|    344|        return C;
  327|    344|    }
  328|       |
  329|       |    /**
  330|       |     * @brief Strassens method of multiplying two matrices
  331|       |     * References: https://en.wikipedia.org/wiki/Strassen_algorithm
  332|       |     * @tparam Number any real value to multiply
  333|       |     * @param other Other matrix to multiply to this
  334|       |     * @returns new matrix
  335|       |     */
  336|       |    template <typename Number, typename = typename std::enable_if<
  337|       |                                   std::is_integral<Number>::value ||
  338|       |                                       std::is_floating_point<Number>::value,
  339|       |                                   bool>::type>
  340|    400|    Matrix strassens_multiplication(const Matrix<Number> &other) const {
  341|    400|        const size_t size = _mat.size();
  342|       |        // Base case: when a matrix is small enough for faster naive
  343|       |        // multiplication, or the matrix is of odd size, then go with the naive
  344|       |        // multiplication route;
  345|       |        // else; go with the strassen's method.
  346|    400|        if (size <= 64ULL || (size & 1ULL)) {
  347|    343|            return this->naive_multiplication(other);
  348|    343|        } else {
  349|     57|            const Matrix<Number>
  350|     57|                A = this->slice(0ULL, size >> 1, 0ULL, size >> 1),
  351|     57|                B = this->slice(0ULL, size >> 1, size >> 1, size),
  352|     57|                C = this->slice(size >> 1, size, 0ULL, size >> 1),
  353|     57|                D = this->slice(size >> 1, size, size >> 1, size),
  354|     57|                E = other.slice(0ULL, size >> 1, 0ULL, size >> 1),
  355|     57|                F = other.slice(0ULL, size >> 1, size >> 1, size),
  356|     57|                G = other.slice(size >> 1, size, 0ULL, size >> 1),
  357|     57|                H = other.slice(size >> 1, size, size >> 1, size);
  358|       |
  359|     57|            Matrix P1 = A.strassens_multiplication(F - H);
  360|     57|            Matrix P2 = (A + B).strassens_multiplication(H);
  361|     57|            Matrix P3 = (C + D).strassens_multiplication(E);
  362|     57|            Matrix P4 = D.strassens_multiplication(G - E);
  363|     57|            Matrix P5 = (A + D).strassens_multiplication(E + H);
  364|     57|            Matrix P6 = (B - D).strassens_multiplication(G + H);
  365|     57|            Matrix P7 = (A - C).strassens_multiplication(E + F);
  366|       |
  367|       |            // Building final matrix C11 would be
  368|       |            //     [      |      ]
  369|       |            //     [ C11  |  C12 ]
  370|       |            // C = [ ____ | ____ ]
  371|       |            //     [      |      ]
  372|       |            //     [ C21  |  C22 ]
  373|       |            //     [      |      ]
  374|       |
  375|     57|            Matrix C11 = P5 + P4 - P2 + P6;
  376|     57|            Matrix C12 = P1 + P2;
  377|     57|            Matrix C21 = P3 + P4;
  378|     57|            Matrix C22 = P1 + P5 - P3 - P7;
  379|       |
  380|     57|            C21.h_stack(C22);
  381|     57|            C11.h_stack(C12);
  382|     57|            C11.v_stack(C21);
  383|       |
  384|     57|            return C11;
  385|     57|        }
  386|    400|    }
  387|       |
  388|       |    /**
  389|       |     * @brief Compares two matrices if each of them are equal or not
  390|       |     * @param other other matrix to compare
  391|       |     * @returns whether they are equal or not
  392|       |     */
  393|      1|    bool operator==(const Matrix<T> &other) const {
  394|      1|        if (_mat.size() != other._mat.size() ||
  395|      1|            _mat[0].size() != other._mat[0].size()) {
  396|      0|            return false;
  397|      0|        }
  398|    513|        for (size_t i = 0; i < _mat.size(); ++i) {
  399|   262k|            for (size_t j = 0; j < _mat[i].size(); ++j) {
  400|   262k|                if (_mat[i][j] != other._mat[i][j]) {
  401|      0|                    return false;
  402|      0|                }
  403|   262k|            }
  404|    512|        }
  405|      1|        return true;
  406|      1|    }
  407|       |
  408|       |    friend std::ostream &operator<<(std::ostream &out, const Matrix<T> &mat) {
  409|       |        for (auto &row : mat._mat) {
  410|       |            for (auto &elem : row) {
  411|       |                out << elem << " ";
  412|       |            }
  413|       |            out << "\n";
  414|       |        }
  415|       |        return out << "\n";
  416|       |    }
  417|       |};
  418|       |
  419|       |}  // namespace strassens_multiplication
  420|       |
  421|       |}  // namespace divide_and_conquer
  422|       |
  423|       |/**
  424|       | * @brief Self-test implementations
  425|       | * @returns void
  426|       | */
  427|      1|static void test() {
  428|      1|    const size_t s = 512;
  429|      1|    auto matrix_demo =
  430|      1|        divide_and_conquer::strassens_multiplication::Matrix<size_t>(s, s);
  431|       |
  432|    513|    for (size_t i = 0; i < s; ++i) {
  433|   262k|        for (size_t j = 0; j < s; ++j) {
  434|   262k|            matrix_demo[i][j] = i + j;
  435|   262k|        }
  436|    512|    }
  437|       |
  438|      1|    auto matrix_demo2 =
  439|      1|        divide_and_conquer::strassens_multiplication::Matrix<size_t>(s, s);
  440|    513|    for (size_t i = 0; i < s; ++i) {
  441|   262k|        for (size_t j = 0; j < s; ++j) {
  442|   262k|            matrix_demo2[i][j] = 2 + i + j;
  443|   262k|        }
  444|    512|    }
  445|       |
  446|      1|    auto start = std::chrono::system_clock::now();
  447|      1|    auto Mat3 = matrix_demo2 * matrix_demo;
  448|      1|    auto end = std::chrono::system_clock::now();
  449|       |
  450|      1|    std::chrono::duration<double> time = (end - start);
  451|      1|    std::cout << "Strassen time: " << time.count() << "s" << std::endl;
  452|       |
  453|      1|    start = std::chrono::system_clock::now();
  454|      1|    auto conf = matrix_demo2.naive_multiplication(matrix_demo);
  455|      1|    end = std::chrono::system_clock::now();
  456|       |
  457|      1|    time = end - start;
  458|      1|    std::cout << "Normal time: " << time.count() << "s" << std::endl;
  459|       |
  460|       |    // std::cout << Mat3 << conf << std::endl;
  461|      1|    assert(Mat3 == conf);
  462|      1|}
  463|       |
  464|       |/**
  465|       | * @brief main function
  466|       | * @returns 0 on exit
  467|       | */
  468|      1|int main() {
  469|      1|    test();  // run self-test implementation
  470|      1|    return 0;
  471|      1|}

