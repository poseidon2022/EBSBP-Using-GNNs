    1|       |/**
    2|       | * @file
    3|       | * @brief [Persistent segment tree with range updates (lazy
    4|       | * propagation)](https://en.wikipedia.org/wiki/Persistent_data_structure)
    5|       | *
    6|       | * @details
    7|       | * A normal segment tree facilitates making point updates and range queries in
    8|       | * logarithmic time. Lazy propagation preserves the logarithmic time with range
    9|       | * updates. So, a segment tree with lazy propagation enables doing range updates
   10|       | * and range queries in logarithmic time, but it doesn't save any information
   11|       | * about itself before the last update. A persistent data structure always
   12|       | * preserves the previous version of itself when it is modified. That is, a new
   13|       | * version of the segment tree is generated after every update. It saves all
   14|       | * previous versions of itself (before every update) to facilitate doing range
   15|       | * queries in any version. More memory is used ,but the logarithmic time is
   16|       | * preserved because the new version points to the same nodes, that the previous
   17|       | * version points to, that are not affected by the update. That is, only the
   18|       | * nodes that are affected by the update and their ancestors are copied. The
   19|       | * rest is copied using lazy propagation in the next queries. Thus preserving
   20|       | * the logarithmic time because the number of nodes copied after any update is
   21|       | * logarithmic.
   22|       | *
   23|       | * @author [Magdy Sedra](https://github.com/MSedra)
   24|       | */
   25|       |#include <iostream>  /// for IO operations
   26|       |#include <memory>    /// to manage dynamic memory
   27|       |#include <vector>    /// for std::vector
   28|       |
   29|       |/**
   30|       | * @namespace range_queries
   31|       | * @brief Range queries algorithms
   32|       | */
   33|       |namespace range_queries {
   34|       |
   35|       |/**
   36|       | * @brief Range query here is range sum, but the code can be modified to make
   37|       | * different queries like range max or min.
   38|       | */
   39|       |class perSegTree {
   40|       | private:
   41|       |    class Node {
   42|       |     public:
   43|       |        std::shared_ptr<Node> left = nullptr;   /// pointer to the left node
   44|       |        std::shared_ptr<Node> right = nullptr;  /// pointer to the right node
   45|       |        int64_t val = 0,
   46|       |                prop = 0;  /// val is the value of the node (here equals to the
   47|       |                           /// sum of the leaf nodes children of that node),
   48|       |                           /// prop is the value to be propagated/added to all
   49|       |                           /// the leaf nodes children of that node
   50|       |    };
   51|       |
   52|       |    uint32_t n = 0;  /// number of elements/leaf nodes in the segment tree
   53|       |    std::vector<std::shared_ptr<Node>>
   54|       |        ptrs{};  /// ptrs[i] holds a root pointer to the segment tree after the
   55|       |                 /// ith update. ptrs[0] holds a root pointer to the segment
   56|       |                 /// tree before any updates
   57|       |    std::vector<int64_t> vec{};  /// values of the leaf nodes that the segment
   58|       |                                 /// tree will be constructed with
   59|       |
   60|       |    /**
   61|       |     * @brief Creating a new node with the same values of curr node
   62|       |     * @param curr node that would be copied
   63|       |     * @returns the new node
   64|       |     */
   65|     22|    std::shared_ptr<Node> newKid(std::shared_ptr<Node> const &curr) {
   66|     22|        auto newNode = std::make_shared<Node>(Node());
   67|     22|        newNode->left = curr->left;
   68|     22|        newNode->right = curr->right;
   69|     22|        newNode->prop = curr->prop;
   70|     22|        newNode->val = curr->val;
   71|     22|        return newNode;
   72|     22|    }
   73|       |
   74|       |    /**
   75|       |     * @brief If there is some value to be propagated to the passed node, value
   76|       |     * is added to the node and the children of the node, if exist, are copied
   77|       |     * and the propagated value is also added to them
   78|       |     * @param i the left index of the range that the passed node holds its sum
   79|       |     * @param j the right index of the range that the passed node holds its sum
   80|       |     * @param curr pointer to the node to be propagated
   81|       |     * @returns void
   82|       |     */
   83|       |    void lazy(const uint32_t &i, const uint32_t &j,
   84|    153|              std::shared_ptr<Node> const &curr) {
   85|    153|        if (!curr->prop) {
   86|    131|            return;
   87|    131|        }
   88|     22|        curr->val += (j - i + 1) * curr->prop;
   89|     22|        if (i != j) {
   90|      9|            curr->left = newKid(curr->left);
   91|      9|            curr->right = newKid(curr->right);
   92|      9|            curr->left->prop += curr->prop;
   93|      9|            curr->right->prop += curr->prop;
   94|      9|        }
   95|     22|        curr->prop = 0;
   96|     22|    }
   97|       |
   98|       |    /**
   99|       |     * @brief Constructing the segment tree with the early passed vector. Every
  100|       |     * call creates a node to hold the sum of the given range, set its pointers
  101|       |     * to the children, and set its value to the sum of the children's values
  102|       |     * @param i the left index of the range that the created node holds its sum
  103|       |     * @param j the right index of the range that the created node holds its sum
  104|       |     * @returns pointer to the newly created node
  105|       |     */
  106|     15|    std::shared_ptr<Node> construct(const uint32_t &i, const uint32_t &j) {
  107|     15|        auto newNode = std::make_shared<Node>(Node());
  108|     15|        if (i == j) {
  109|      8|            newNode->val = vec[i];
  110|      8|        } else {
  111|      7|            uint32_t mid = i + (j - i) / 2;
  112|      7|            auto leftt = construct(i, mid);
  113|      7|            auto right = construct(mid + 1, j);
  114|      7|            newNode->val = leftt->val + right->val;
  115|      7|            newNode->left = leftt;
  116|      7|            newNode->right = right;
  117|      7|        }
  118|     15|        return newNode;
  119|     15|    }
  120|       |
  121|       |    /**
  122|       |     * @brief Doing range update, checking at every node if it has some value to
  123|       |     * be propagated. All nodes affected by the update are copied and
  124|       |     * propagation value is added to the leaf of them
  125|       |     * @param i the left index of the range that the passed node holds its sum
  126|       |     * @param j the right index of the range that the passed node holds its sum
  127|       |     * @param l the left index of the range to be updated
  128|       |     * @param r the right index of the range to be updated
  129|       |     * @param value the value to be added to every element whose index x
  130|       |     * satisfies l<=x<=r
  131|       |     * @param curr pointer to the current node, which has value = the sum of
  132|       |     * elements whose index x satisfies i<=x<=j
  133|       |     * @returns pointer to the current newly created node
  134|       |     */
  135|       |    std::shared_ptr<Node> update(const uint32_t &i, const uint32_t &j,
  136|       |                                 const uint32_t &l, const uint32_t &r,
  137|       |                                 const int64_t &value,
  138|     10|                                 std::shared_ptr<Node> const &curr) {
  139|     10|        lazy(i, j, curr);
  140|     10|        if (i >= l && j <= r) {
  141|      4|            std::shared_ptr<Node> newNode = newKid(curr);
  142|      4|            newNode->prop += value;
  143|      4|            lazy(i, j, newNode);
  144|      4|            return newNode;
  145|      4|        }
  146|      6|        if (i > r || j < l) {
  147|      2|            return curr;
  148|      2|        }
  149|      4|        auto newNode = std::make_shared<Node>(Node());
  150|      4|        uint32_t mid = i + (j - i) / 2;
  151|      4|        newNode->left = update(i, mid, l, r, value, curr->left);
  152|      4|        newNode->right = update(mid + 1, j, l, r, value, curr->right);
  153|      4|        newNode->val = newNode->left->val + newNode->right->val;
  154|      4|        return newNode;
  155|      6|    }
  156|       |
  157|       |    /**
  158|       |     * @brief Querying the range from index l to index r, checking at every node
  159|       |     * if it has some value to be propagated. Current node's value is returned
  160|       |     * if its range is completely inside the wanted range, else 0 is returned
  161|       |     * @param i the left index of the range that the passed node holds its sum
  162|       |     * @param j the right index of the range that the passed node holds its sum
  163|       |     * @param l the left index of the range whose sum should be returned as a
  164|       |     * result
  165|       |     * @param r the right index of the range whose sum should be returned as a
  166|       |     * result
  167|       |     * @param curr pointer to the current node, which has value = the sum of
  168|       |     * elements whose index x satisfies i<=x<=j
  169|       |     * @returns sum of elements whose index x satisfies l<=x<=r
  170|       |     */
  171|       |    int64_t query(const uint32_t &i, const uint32_t &j, const uint32_t &l,
  172|    139|                  const uint32_t &r, std::shared_ptr<Node> const &curr) {
  173|    139|        lazy(i, j, curr);
  174|    139|        if (j < l || r < i) {
  175|     57|            return 0;
  176|     57|        }
  177|     82|        if (i >= l && j <= r) {
  178|     22|            return curr->val;
  179|     22|        }
  180|     60|        uint32_t mid = i + (j - i) / 2;
  181|     60|        return query(i, mid, l, r, curr->left) +
  182|     60|               query(mid + 1, j, l, r, curr->right);
  183|     82|    }
  184|       |
  185|       |    /**
  186|       |     * public methods that can be used directly from outside the class. They
  187|       |     * call the private functions that do all the work
  188|       |     */
  189|       | public:
  190|       |    /**
  191|       |     * @brief Constructing the segment tree with the values in the passed
  192|       |     * vector. Returned root pointer is pushed in the pointers vector to have
  193|       |     * access to the original version if the segment tree is updated
  194|       |     * @param vec vector whose values will be used to build the segment tree
  195|       |     * @returns void
  196|       |     */
  197|       |    void construct(const std::vector<int64_t>
  198|       |                       &vec)  // the segment tree will be built from the values
  199|       |                              // in "vec", "vec" is 0 indexed
  200|      1|    {
  201|      1|        if (vec.empty()) {
  202|      0|            return;
  203|      0|        }
  204|      1|        n = vec.size();
  205|      1|        this->vec = vec;
  206|      1|        auto root = construct(0, n - 1);
  207|      1|        ptrs.push_back(root);
  208|      1|    }
  209|       |
  210|       |    /**
  211|       |     * @brief Doing range update by passing the left and right indexes of the
  212|       |     * range as well as the value to be added.
  213|       |     * @param l the left index of the range to be updated
  214|       |     * @param r the right index of the range to be updated
  215|       |     * @param value the value to be added to every element whose index x
  216|       |     * satisfies l<=x<=r
  217|       |     * @returns void
  218|       |     */
  219|       |    void update(const uint32_t &l, const uint32_t &r,
  220|       |                const int64_t
  221|       |                    &value)  // all elements from index "l" to index "r" would
  222|       |                             // by updated by "value", "l" and "r" are 0 indexed
  223|      2|    {
  224|      2|        ptrs.push_back(update(
  225|      2|            0, n - 1, l, r, value,
  226|      2|            ptrs[ptrs.size() -
  227|      2|                 1]));  // saving the root pointer to the new segment tree
  228|      2|    }
  229|       |
  230|       |    /**
  231|       |     * @brief Querying the range from index l to index r, getting the sum of the
  232|       |     * elements whose index x satisfies l<=x<=r
  233|       |     * @param l the left index of the range whose sum should be returned as a
  234|       |     * result
  235|       |     * @param r the right index of the range whose sum should be returned as a
  236|       |     * result
  237|       |     * @param version the version to query on. If equals to 0, the original
  238|       |     * segment tree will be queried
  239|       |     * @returns sum of elements whose index x satisfies l<=x<=r
  240|       |     */
  241|       |    int64_t query(
  242|       |        const uint32_t &l, const uint32_t &r,
  243|       |        const uint32_t
  244|       |            &version)  // querying the range from "l" to "r" in a segment tree
  245|       |                       // after "version" updates, "l" and "r" are 0 indexed
  246|     19|    {
  247|     19|        return query(0, n - 1, l, r, ptrs[version]);
  248|     19|    }
  249|       |
  250|       |    /**
  251|       |     * @brief Getting the number of versions after updates so far which is equal
  252|       |     * to the size of the pointers vector
  253|       |     * @returns the number of versions
  254|       |     */
  255|       |    uint32_t size()  // returns the number of segment trees (versions) , the
  256|       |                     // number of updates done so far = returned value - 1
  257|       |                     // ,because one of the trees is the original segment tree
  258|      1|    {
  259|      1|        return ptrs.size();
  260|      1|    }
  261|       |};
  262|       |}  // namespace range_queries
  263|       |
  264|       |/**
  265|       | * @brief Test implementations
  266|       | * @returns void
  267|       | */
  268|      1|static void test() {
  269|      1|    std::vector<int64_t> arr = {-5, 2, 3, 11, -2, 7, 0, 1};
  270|      1|    range_queries::perSegTree tree;
  271|      1|    std::cout << "Elements before any updates are {";
  272|      9|    for (uint32_t i = 0; i < arr.size(); ++i) {
  273|      8|        std::cout << arr[i];
  274|      8|        if (i != arr.size() - 1) {
  275|      7|            std::cout << ",";
  276|      7|        }
  277|      8|    }
  278|      1|    std::cout << "}\n";
  279|      1|    tree.construct(
  280|      1|        arr);  // constructing the original segment tree (version = 0)
  281|      1|    std::cout << "Querying range sum on version 0 from index 2 to 4 = 3+11-2 = "
  282|      1|              << tree.query(2, 4, 0) << '\n';
  283|      1|    std::cout
  284|      1|        << "Subtract 7 from all elements from index 1 to index 5 inclusive\n";
  285|      1|    tree.update(1, 5, -7);  // subtracting 7 from index 1 to index 5
  286|      1|    std::cout << "Elements of the segment tree whose version = 1 (after 1 "
  287|      1|                 "update) are {";
  288|      9|    for (uint32_t i = 0; i < arr.size(); ++i) {
  289|      8|        std::cout << tree.query(i, i, 1);
  290|      8|        if (i != arr.size() - 1) {
  291|      7|            std::cout << ",";
  292|      7|        }
  293|      8|    }
  294|      1|    std::cout << "}\n";
  295|      1|    std::cout << "Add 10 to all elements from index 0 to index 7 inclusive\n";
  296|      1|    tree.update(0, 7, 10);  // adding 10 to all elements
  297|      1|    std::cout << "Elements of the segment tree whose version = 2 (after 2 "
  298|      1|                 "updates) are {";
  299|      9|    for (uint32_t i = 0; i < arr.size(); ++i) {
  300|      8|        std::cout << tree.query(i, i, 2);
  301|      8|        if (i != arr.size() - 1) {
  302|      7|            std::cout << ",";
  303|      7|        }
  304|      8|    }
  305|      1|    std::cout << "}\n";
  306|      1|    std::cout << "Number of segment trees (versions) now = " << tree.size()
  307|      1|              << '\n';
  308|      1|    std::cout << "Querying range sum on version 0 from index 3 to 5 = 11-2+7 = "
  309|      1|              << tree.query(3, 5, 0) << '\n';
  310|      1|    std::cout << "Querying range sum on version 1 from index 3 to 5 = 4-9+0 = "
  311|      1|              << tree.query(3, 5, 1) << '\n';
  312|      1|}
  313|       |
  314|       |/**
  315|       | * @brief Main function
  316|       | * @returns 0 on exit
  317|       | */
  318|      1|int main() {
  319|      1|    test();  // run self-test implementations
  320|      1|    return 0;
  321|      1|}

