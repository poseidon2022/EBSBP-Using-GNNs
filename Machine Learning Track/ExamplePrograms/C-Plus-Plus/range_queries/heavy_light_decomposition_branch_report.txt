    1|       |/**
    2|       | * @file
    3|       | * @brief [Heavy Light
    4|       | * Decomposition](https://en.wikipedia.org/wiki/Heavy_path_decomposition)
    5|       | * implementation
    6|       | * @author [Aniruthan R](https://github.com/aneee004)
    7|       | *
    8|       | * @details
    9|       | * Heavy-Light Decomposition is a technique on trees, that supports the
   10|       | * following:
   11|       | * 1. Update node s, with a value v
   12|       | * 2. Return the (sum) of all node values on the simple path from a to b
   13|       | * (sum) can also be replced with XOR, OR, AND, min, or max
   14|       | *
   15|       | * The update is done in O(log n) time, and
   16|       | * the query is done in O(log^2 n) time with HLD
   17|       | * where, n is the number of nodes
   18|       | *
   19|       | * The template type is the data type of the value stored in the nodes.
   20|       | * If a non-primitive data-type is used as a template,
   21|       | * the coressponding operators must be overloaded.
   22|       | *
   23|       | * An HLD object can only be created with a constant number of nodes, and
   24|       | * it cannot be changed later. Creaty an empty instance is not supported.
   25|       | *
   26|       | * To start answering updates and queries,
   27|       | * 1. Create an instance of HLD<X> object (obj), with the required data type.
   28|       | * 2. Read in the edge/parent information and update it with obj.add_edge().
   29|       | * Note: The edges addes must be 0 indexed.
   30|       | * 3. Create a vector with initial node values, and call set_node_val() with it.
   31|       | * 4. Call obj.init() to populate the required information for supporting
   32|       | * operations.
   33|       | * 5. Call obj.update(node, new_val), to update the value at index 'node' to the
   34|       | * new value. Note: node must be 0 indexed
   35|       | * 6. Call obj.query(a, b) to get the (sum) of node values in the simple path
   36|       | * from a to b. Note: a and b, must be 0 indexed.
   37|       | *
   38|       | * Sample I/O at the bottom.
   39|       | * @todo Support edge weight queries, by storing the edge weight value in it's
   40|       | * child algorithm verified by testing in CSES path queries:
   41|       | * https://cses.fi/problemset/task/1138
   42|       | */
   43|       |
   44|       |#include <algorithm>
   45|       |#include <cassert>
   46|       |#include <cmath>
   47|       |#include <cstring>
   48|       |#include <iostream>
   49|       |#include <list>
   50|       |#include <numeric>
   51|       |#include <string>
   52|       |#include <vector>
   53|       |
   54|       |/**
   55|       | * @namespace range_queries
   56|       | * @brief Algorithms and Data Structures that support range queries and updates.
   57|       | */
   58|       |namespace range_queries {
   59|       |/**
   60|       | * @namespace heavy_light_decomposition
   61|       | * @brief Heavy light decomposition algorithm
   62|       | */
   63|       |namespace heavy_light_decomposition {
   64|       |/**
   65|       | * @brief A Basic Tree, which supports binary lifting
   66|       | * @tparam the data type of the values stored in the tree nodes
   67|       | * @details Deleting the default constructor
   68|       | * An instance can only be created with the number of nodes
   69|       | * Defaults:
   70|       | * t_node indexing are zero based
   71|       | * t_root is 0
   72|       | * depth of root_node is 0
   73|       | * Supports:
   74|       | * lift :- lift a node k units up the tree
   75|       | * kth_ancestor :- returns the kth ancestor
   76|       | * lca :- returns the least common ancestor
   77|       | */
   78|       |template <typename X> class Tree {
   79|       |  //
   80|       |
   81|       |private:
   82|       |  std::vector<std::list<int>>
   83|       |      t_adj;         ///< an adjacency list to stores the tree edges
   84|       |  const int t_nodes, ///< number of nodes
   85|       |      t_maxlift;     ///< maximum possible height of the tree
   86|       |  std::vector<std::vector<int>>
   87|       |      t_par;                ///< a matrix to store every node's 2^kth parent
   88|       |  std::vector<int> t_depth, ///< a vector to store the depth of a node,
   89|       |      t_size; ///< a vector to store the subtree size rooted at node
   90|       |
   91|       |  int t_root;           ///< the root of the tree
   92|       |  std::vector<X> t_val; ///< values of nodes
   93|       |  template <typename T> friend class HLD;
   94|       |
   95|       |  /**
   96|       |   * @brief Utility function to compute sub-tree sizes
   97|       |   * @param u current dfs node
   98|       |   * @param p the parent of node @param u
   99|       |   * @returns void
  100|       |   */
  101|     23|  void dfs_size(int u, int p = -1) {
  102|     40|    for (const int &v : t_adj[u]) {
  103|     40|      if (v ^ p) {
  104|     20|        dfs_size(v, u);
  105|     20|        t_size[u] += t_size[v];
  106|     20|      }
  107|     40|    }
  108|     23|  }
  109|       |
  110|       |  /**
  111|       |   * @brief Utility function to populate the t_par vector
  112|       |   * @param u current dfs node
  113|       |   * @param p the parent of node u
  114|       |   * @returns void
  115|       |   */
  116|     23|  void dfs_lca(int u, int p = -1) {
  117|     23|    t_par[u][0] = p;
  118|     23|    if (p != -1) {
  119|     20|      t_depth[u] = 1 + t_depth[p];
  120|     20|    }
  121|     87|    for (int k = 1; k < t_maxlift; k++) {
  122|     64|      if (t_par[u][k - 1] != -1) {
  123|     41|        t_par[u][k] = t_par[t_par[u][k - 1]][k - 1];
  124|     41|      }
  125|     64|    }
  126|       |
  127|     40|    for (const int &v : t_adj[u]) {
  128|     40|      if (v ^ p) {
  129|     20|        dfs_lca(v, u);
  130|     20|      }
  131|     40|    }
  132|     23|  }
  133|       |
  134|       |public:
  135|       |  /**
  136|       |   * @brief Class parameterized constructor, resizes the and initializes the
  137|       |   * data members
  138|       |   * @param nodes the total number of nodes in the tree
  139|       |   */
  140|       |  explicit Tree(int nodes)
  141|      3|      : t_nodes(nodes), t_maxlift(static_cast<int>(floor(log2(nodes))) + 1) {
  142|       |    /* Initialize and resize all the vectors */
  143|      3|    t_root = 0; /* Default */
  144|      3|    t_adj.resize(t_nodes);
  145|      3|    t_par.assign(t_nodes, std::vector<int>(t_maxlift, -1));
  146|      3|    t_depth.assign(t_nodes, 0);
  147|      3|    t_size.assign(t_nodes, 1);
  148|      3|    t_val.resize(t_nodes);
  149|      3|  }
  150|       |
  151|       |  /**
  152|       |   * @brief Adds an undirected edge from node u to node v in the tree
  153|       |   * @param u the node where the edge is from
  154|       |   * @param v the node where the edge is to
  155|       |   * @returns void
  156|       |   */
  157|     20|  void add_edge(const int u, const int v) {
  158|     20|    t_adj[u].push_back(v);
  159|     20|    t_adj[v].push_back(u);
  160|     20|  }
  161|       |
  162|       |  /**
  163|       |   * @brief Set the root for the tree
  164|       |   * @param new_root the new root
  165|       |   * @returns void
  166|       |   */
  167|       |  void change_root(int new_root) { t_root = new_root; }
  168|       |
  169|       |  /**
  170|       |   * @brief Set the values for all the nodes
  171|       |   * @param node_val a vector of size n, with all the node values where, n is
  172|       |   * the number of nodes
  173|       |   * @returns void
  174|       |   */
  175|      3|  void set_node_val(const std::vector<X> &node_val) {
  176|      3|    assert(static_cast<int>(node_val.size()) == t_nodes);
  177|      0|    t_val = node_val;
  178|      3|  }
  179|       |
  180|       |  /**
  181|       |   * @brief This function must be called after the tree adjacency list and node
  182|       |   * values are populated The function initializes the required parameters, and
  183|       |   * populates the segment tree
  184|       |   * @returns void
  185|       |   */
  186|      3|  void init() {
  187|      3|    assert(t_nodes > 0);
  188|      0|    dfs_size(t_root);
  189|      3|    dfs_lca(t_root);
  190|      3|  }
  191|       |
  192|       |  /**
  193|       |   * @brief The function lifts a node, k units up the tree.
  194|       |   * The lifting is done in place, and the result is stored in the address
  195|       |   * pointed by p.
  196|       |   * @param p a pointer to the variable that stores the node id
  197|       |   * @param dist the distance to move up the tree
  198|       |   * @returns void
  199|       |   */
  200|     10|  void lift(int *const p, int dist) {
  201|     48|    for (int k = 0; k < t_maxlift; k++) {
  202|     38|      if (*p == -1) {
  203|      0|        return;
  204|      0|      }
  205|     38|      if (dist & 1) {
  206|     14|        *p = t_par[*p][k];
  207|     14|      }
  208|     38|      dist >>= 1;
  209|     38|    }
  210|     10|  }
  211|       |
  212|       |  /**
  213|       |   * @brief The function returns the kth ancestor of a node
  214|       |   * @param p the node id whose kth ancestor is to be found
  215|       |   * @param dist the distance to move up the tree
  216|       |   * @returns the kth ancestor of node
  217|       |   */
  218|       |  int kth_ancestor(int p, const int &dist) {
  219|       |    lift(&p, dist);
  220|       |    return p;
  221|       |  }
  222|       |
  223|       |  /**
  224|       |   * @brief The function returns the least common ancestor of two nodes
  225|       |   * @param a node id_1
  226|       |   * @param b node id_2
  227|       |   * @returns the least common ancestor of node a, and node b
  228|       |   */
  229|     12|  int lca(int a, int b) {
  230|     12|    assert(a >= 0 and b >= 0 and a < t_nodes and b < t_nodes);
  231|     12|    if (t_depth[a] > t_depth[b]) {
  232|      1|      lift(&a, t_depth[a] - t_depth[b]);
  233|      1|    }
  234|     12|    if (t_depth[b] > t_depth[a]) {
  235|      9|      lift(&b, t_depth[b] - t_depth[a]);
  236|      9|    }
  237|     12|    if (a == b) {
  238|     10|      return a;
  239|     10|    }
  240|     10|    for (int k = t_maxlift - 1; k >= 0; k--) {
  241|      8|      if (t_par[a][k] != t_par[b][k]) {
  242|      1|        a = t_par[a][k];
  243|      1|        b = t_par[b][k];
  244|      1|      }
  245|      8|    }
  246|      2|    return t_par[a][0];
  247|     12|  }
  248|       |};
  249|       |
  250|       |/**
  251|       | * @brief Segment Tree, to store heavy chains
  252|       | * @tparam the data type of the values stored in the tree nodes
  253|       | */
  254|       |template <typename X> class SG {
  255|       |private:
  256|       |  /**
  257|       |   * @brief Everything here is private,
  258|       |   * and can only be accessed through the methods,
  259|       |   * in the derived class (HLD)
  260|       |   */
  261|       |
  262|       |  std::vector<X> s_tree; ///< the segment tree, stored as a vector
  263|       |  int s_size;            ///< number of leaves in the segment tree
  264|       |  X sret_init = 0;       ///< inital query return value
  265|       |  template <typename T> friend class HLD;
  266|       |
  267|       |  /**
  268|       |   * @brief Function that specifies the type of operation involved when segments
  269|       |   * are combined
  270|       |   * @param lhs the left segment
  271|       |   * @param rhs the right segment
  272|       |   * @returns the combined result
  273|       |   */
  274|    118|  X combine(X lhs, X rhs) { return lhs + rhs; }
  275|       |
  276|       |  /**
  277|       |   * @brief Class parameterized constructor. Resizes the and initilizes the data
  278|       |   * members.
  279|       |   * @param nodes the total number of nodes in the tree
  280|       |   * @returns void
  281|       |   */
  282|      3|  explicit SG(int size) {
  283|      3|    s_size = size;
  284|      3|    s_tree.assign(2 * s_size, 0ll);
  285|      3|  }
  286|       |
  287|       |  /**
  288|       |   * @brief Update the value at a node
  289|       |   * @param p the node to be udpated
  290|       |   * @param v the update value
  291|       |   * @returns void
  292|       |   */
  293|     11|  void update(int p, X v) {
  294|     56|    for (p += s_size; p > 0; p >>= 1) {
  295|     45|      s_tree[p] += v;
  296|     45|    }
  297|     11|  }
  298|       |
  299|       |  /**
  300|       |   * @brief Make a range query from node label l to node label r
  301|       |   * @param l node label where the path starts
  302|       |   * @param r node label where the path ends
  303|       |   * @returns void
  304|       |   */
  305|     29|  X query(int l, int r) {
  306|     29|    X lhs = sret_init, rhs = sret_init;
  307|     72|    for (l += s_size, r += s_size + 1; l < r; l >>= 1, r >>= 1) {
  308|     43|      if (l & 1) {
  309|     19|        lhs = combine(lhs, s_tree[l++]);
  310|     19|      }
  311|     43|      if (r & 1) {
  312|     21|        rhs = combine(s_tree[--r], rhs);
  313|     21|      }
  314|     43|    }
  315|     29|    return combine(lhs, rhs);
  316|     29|  }
  317|       |
  318|       |  /**
  319|       |   * @brief Set the initialization for the query data type, based on requirement
  320|       |   *
  321|       |   * @details
  322|       |   * Change the sret_init, based on requirement:
  323|       |   * * Sum Query: 0 (Default)
  324|       |   * * XOR Query: 0 (Default)
  325|       |   * * Min Query: Infinity
  326|       |   * * Max Query: -Infinity
  327|       |   * @param new_sret_init the new init
  328|       |   */
  329|       |  void set_sret_init(X new_sret_init) { sret_init = new_sret_init; }
  330|       |};
  331|       |
  332|       |/**
  333|       | * @brief The Heavy-Light Decomposition class
  334|       | * @tparam the data type of the values stored in the tree nodes
  335|       | */
  336|       |template <typename X> class HLD : public Tree<X>, public SG<X> {
  337|       |private:
  338|       |  int label;                ///< utility member to assign labels in dfs_labels()
  339|       |  std::vector<int> h_label, ///< stores the label of a node
  340|       |      h_heavychlid,         ///< stores the heavy child of a node
  341|       |      h_parent;             ///< stores the top of the heavy chain from a node
  342|       |
  343|       |  /**
  344|       |   * @brief Utility function to assign heavy child to each node (-1 for a leaf
  345|       |   * node)
  346|       |   * @param u current dfs node
  347|       |   * @param p the parent of node u
  348|       |   * @returns void
  349|       |   */
  350|     23|  void dfs_hc(int u, int p = -1) {
  351|     23|    int hc_size = -1, hc_id = -1;
  352|     40|    for (const int &v : Tree<X>::t_adj[u]) {
  353|     40|      if (v ^ p) {
  354|     20|        dfs_hc(v, u);
  355|     20|        if (Tree<X>::t_size[v] > hc_size) {
  356|     17|          hc_size = Tree<X>::t_size[v];
  357|     17|          hc_id = v;
  358|     17|        }
  359|     20|      }
  360|     40|    }
  361|     23|    h_heavychlid[u] = hc_id;
  362|     23|  }
  363|       |
  364|       |  /**
  365|       |   * @brief Utility function to assign highest parent that can be reached though
  366|       |   * heavy chains
  367|       |   * @param u current dfs node
  368|       |   * @param p the parent of node u
  369|       |   * @returns void
  370|       |   */
  371|     23|  void dfs_par(int u, int p = -1) {
  372|     23|    if (h_heavychlid[u] != -1) {
  373|     16|      h_parent[h_heavychlid[u]] = h_parent[u];
  374|     16|      dfs_par(h_heavychlid[u], u);
  375|     16|    }
  376|     40|    for (const int &v : Tree<X>::t_adj[u]) {
  377|     40|      if (v ^ p and v ^ h_heavychlid[u]) {
  378|      4|        dfs_par(v, u);
  379|      4|      }
  380|     40|    }
  381|     23|  }
  382|       |
  383|       |  /**
  384|       |   * @brief Utility function to lable the nodes so that heavy chains have a
  385|       |   * contigous lable
  386|       |   * @param u current dfs node
  387|       |   * @param p the parent of node u
  388|       |   * @returns void
  389|       |   */
  390|     23|  void dfs_labels(int u, int p = -1) {
  391|     23|    h_label[u] = label++;
  392|     23|    if (h_heavychlid[u] != -1) {
  393|     16|      dfs_labels(h_heavychlid[u], u);
  394|     16|    }
  395|     40|    for (const int &v : Tree<X>::t_adj[u]) {
  396|     40|      if (v ^ p and v ^ h_heavychlid[u]) {
  397|      4|        dfs_labels(v, u);
  398|      4|      }
  399|     40|    }
  400|     23|  }
  401|       |
  402|       |  /**
  403|       |   * @brief Utility function to break down a path query into two chain queries
  404|       |   * @param a node where the path starts
  405|       |   * @param b node where the path ends
  406|       |   * a and b must belong to a single root to leaf chain
  407|       |   * @returns the sum of ndoe values in the simple path from a to b
  408|       |   */
  409|     24|  X chain_query(int a, int b) {
  410|     24|    X ret = SG<X>::sret_init;
  411|     24|    if (Tree<X>::t_depth[a] < Tree<X>::t_depth[b]) {
  412|      0|      std::swap(a, b);
  413|      0|    }
  414|     31|    while (Tree<X>::t_depth[a] >= Tree<X>::t_depth[b]) {
  415|     29|      int l = h_label[h_parent[a]];
  416|     29|      int r = h_label[a];
  417|     29|      if (Tree<X>::t_depth[h_parent[a]] < Tree<X>::t_depth[b]) {
  418|      6|        l += Tree<X>::t_depth[b] - Tree<X>::t_depth[h_parent[a]];
  419|      6|      }
  420|     29|      ret = SG<X>::combine(ret, SG<X>::query(l, r));
  421|     29|      a = Tree<X>::t_par[h_parent[a]][0];
  422|     29|      if (a == -1) {
  423|     22|        break;
  424|     22|      }
  425|     29|    }
  426|     24|    return ret;
  427|     24|  }
  428|       |
  429|       |public:
  430|       |  /**
  431|       |   * @brief Class parameterized constructor. Resizes the and initilizes the data
  432|       |   * members.
  433|       |   * @param nodes the total number of nodes in the tree
  434|       |   */
  435|      3|  explicit HLD<X>(int nodes) : Tree<X>(nodes), SG<X>(nodes) {
  436|       |    /* Initialization and resize vectors */
  437|      3|    label = 0;
  438|      3|    h_label.assign(Tree<X>::t_nodes, -1);
  439|      3|    h_heavychlid.assign(Tree<X>::t_nodes, -1);
  440|      3|    h_parent.resize(Tree<X>::t_nodes);
  441|      3|    iota(h_parent.begin(), h_parent.end(), 0);
  442|      3|  }
  443|       |
  444|       |  /**
  445|       |   * @brief This function must be called after the tree adjacency list and node
  446|       |   * values are populated The function initializes the required parametes, and
  447|       |   * populates the segment tree
  448|       |   * @returns void
  449|       |   */
  450|      3|  void init() {
  451|      3|    Tree<X>::init();
  452|       |
  453|       |    // Fill the heavy child, greatest parent, and labels
  454|      3|    label = 0;
  455|      3|    dfs_hc(Tree<X>::t_root);
  456|      3|    dfs_par(Tree<X>::t_root);
  457|      3|    dfs_labels(Tree<X>::t_root);
  458|       |
  459|       |    // Segment Tree Initialization
  460|     26|    for (int i = 0; i < Tree<X>::t_nodes; i++) {
  461|     23|      SG<X>::s_tree[h_label[i] + Tree<X>::t_nodes] = Tree<X>::t_val[i];
  462|     23|    }
  463|     23|    for (int i = Tree<X>::t_nodes - 1; i > 0; i--) {
  464|     20|      SG<X>::s_tree[i] =
  465|     20|          SG<X>::combine(SG<X>::s_tree[i << 1], SG<X>::s_tree[i << 1 | 1]);
  466|     20|    }
  467|      3|  }
  468|       |
  469|       |  /**
  470|       |   * @brief This function updates the value at node with val
  471|       |   * @param node the node where the update is done
  472|       |   * @param val the value that is being updated
  473|       |   * @returns void
  474|       |   */
  475|     11|  void update(int node, X val) {
  476|     11|    X diff = val - Tree<X>::t_val[node];
  477|     11|    SG<X>::update(h_label[node], diff);
  478|     11|    Tree<X>::t_val[node] = val;
  479|     11|  }
  480|       |
  481|       |  /**
  482|       |   * @brief This function returns the sum of node values in the simple path from
  483|       |   * from node_1 to node_2
  484|       |   * @param a the node where the simple path starts
  485|       |   * @param b the node where the simple path ends
  486|       |   * (parameters are interchangeable, i.e., the function is commutative)
  487|       |   * @returns the sum of node values in the simple path from a to b
  488|       |   */
  489|     12|  X query(int a, int b) {
  490|     12|    int lc = Tree<X>::lca(a, b);
  491|     12|    X ret = SG<X>::sret_init;
  492|     12|    assert(lc != -1);
  493|      0|    ret += chain_query(a, lc);
  494|     12|    ret += chain_query(b, lc);
  495|     12|    return ret - Tree<X>::t_val[lc];
  496|     12|  }
  497|       |};
  498|       |} // namespace heavy_light_decomposition
  499|       |} // namespace range_queries
  500|       |
  501|       |/**
  502|       | * Test implementations
  503|       | * @returns none
  504|       | */
  505|      1|static void test_1() {
  506|      1|  std::cout << "Test 1:\n";
  507|       |
  508|       |  // Test details
  509|      1|  int n = 5;
  510|      1|  std::vector<int64_t> node_values = {4, 2, 5, 2, 1};
  511|      1|  std::vector<std::vector<int>> edges = {{1, 2}, {1, 3}, {3, 4}, {3, 5}};
  512|      1|  std::vector<std::vector<int>> queries = {
  513|      1|      {2, 1, 4},
  514|      1|      {1, 3, 2},
  515|      1|      {2, 1, 4},
  516|      1|  };
  517|      1|  std::vector<int> expected_result = {11, 8};
  518|      1|  std::vector<int> code_result;
  519|       |
  520|      1|  range_queries::heavy_light_decomposition::HLD<int64_t> hld(n);
  521|      1|  hld.set_node_val(node_values);
  522|      5|  for (int i = 0; i < n - 1; i++) {
  523|      4|    int u = edges[i][0], v = edges[i][1];
  524|      4|    hld.add_edge(u - 1, v - 1);
  525|      4|  }
  526|      1|  hld.init();
  527|      3|  for (const auto &q : queries) {
  528|      3|    int type = q[0];
  529|      3|    if (type == 1) {
  530|      1|      int p = q[1], x = q[2];
  531|      1|      hld.update(p - 1, x);
  532|      2|    } else if (type == 2) {
  533|      2|      int a = q[1], b = q[2];
  534|      2|      code_result.push_back(hld.query(a - 1, b - 1));
  535|      2|    } else {
  536|      0|      continue;
  537|      0|    }
  538|      3|  }
  539|      3|  for (int i = 0; i < static_cast<int>(expected_result.size()); i++) {
  540|      2|    assert(expected_result[i] == code_result[i]);
  541|      2|  }
  542|      1|  std::cout << "\nTest 1 passed!\n";
  543|      1|}
  544|       |
  545|       |/**
  546|       | * Second test implementations
  547|       | * @returns void
  548|       | */
  549|      1|static void test_2() {
  550|      1|  std::cout << "Test 2:\n";
  551|       |
  552|       |  // Test details (Bamboo)
  553|      1|  int n = 10;
  554|      1|  std::vector<int64_t> node_values = {1, 8, 6, 8, 6, 2, 9, 2, 3, 2};
  555|      1|  std::vector<std::vector<int>> edges = {
  556|      1|      {10, 5}, {6, 2}, {10, 7}, {5, 2}, {3, 9}, {8, 3}, {1, 4}, {6, 4}, {8, 7}};
  557|      1|  std::vector<std::vector<int>> queries = {
  558|      1|      {2, 1, 10}, {2, 1, 6}, {1, 3, 4}, {2, 1, 9}, {1, 5, 3},
  559|      1|      {1, 7, 8},  {2, 1, 4}, {2, 1, 8}, {1, 1, 4}, {1, 2, 7}};
  560|      1|  std::vector<int> expected_result = {27, 11, 45, 9, 34};
  561|      1|  std::vector<int> code_result;
  562|       |
  563|      1|  range_queries::heavy_light_decomposition::HLD<int64_t> hld(n);
  564|      1|  hld.set_node_val(node_values);
  565|     10|  for (int i = 0; i < n - 1; i++) {
  566|      9|    int u = edges[i][0], v = edges[i][1];
  567|      9|    hld.add_edge(u - 1, v - 1);
  568|      9|  }
  569|      1|  hld.init();
  570|     10|  for (const auto &q : queries) {
  571|     10|    int type = q[0];
  572|     10|    if (type == 1) {
  573|      5|      int p = q[1], x = q[2];
  574|      5|      hld.update(p - 1, x);
  575|      5|    } else if (type == 2) {
  576|      5|      int a = q[1], b = q[2];
  577|      5|      code_result.push_back(hld.query(a - 1, b - 1));
  578|      5|    } else {
  579|      0|      continue;
  580|      0|    }
  581|     10|  }
  582|      6|  for (int i = 0; i < static_cast<int>(expected_result.size()); i++) {
  583|      5|    assert(expected_result[i] == code_result[i]);
  584|      5|  }
  585|      1|  std::cout << "\nTest2 passed!\n";
  586|      1|}
  587|       |
  588|       |/**
  589|       | * Third test implementations
  590|       | * @returns void
  591|       | */
  592|      1|static void test_3() {
  593|      1|  std::cout << "Test 3:\n";
  594|       |
  595|       |  // Test details
  596|      1|  int n = 8;
  597|      1|  std::vector<int64_t> node_values = {1, 8, 6, 8, 6, 2, 9, 2};
  598|      1|  std::vector<std::vector<int>> edges = {{1, 2}, {2, 3}, {3, 4}, {1, 5},
  599|      1|                                         {6, 3}, {7, 5}, {8, 7}};
  600|      1|  std::vector<std::vector<int>> queries = {
  601|      1|      {2, 6, 8}, {2, 3, 6}, {1, 3, 4}, {2, 7, 1}, {1, 5, 3},
  602|      1|      {1, 7, 8}, {2, 6, 4}, {2, 7, 8}, {1, 1, 4}, {1, 2, 7}};
  603|      1|  std::vector<int> expected_result = {34, 8, 16, 14, 10};
  604|      1|  std::vector<int> code_result;
  605|       |
  606|      1|  range_queries::heavy_light_decomposition::HLD<int64_t> hld(n);
  607|      1|  hld.set_node_val(node_values);
  608|      8|  for (int i = 0; i < n - 1; i++) {
  609|      7|    int u = edges[i][0], v = edges[i][1];
  610|      7|    hld.add_edge(u - 1, v - 1);
  611|      7|  }
  612|      1|  hld.init();
  613|     10|  for (const auto &q : queries) {
  614|     10|    int type = q[0];
  615|     10|    if (type == 1) {
  616|      5|      int p = q[1], x = q[2];
  617|      5|      hld.update(p - 1, x);
  618|      5|    } else if (type == 2) {
  619|      5|      int a = q[1], b = q[2];
  620|      5|      code_result.push_back(hld.query(a - 1, b - 1));
  621|      5|    } else {
  622|      0|      continue;
  623|      0|    }
  624|     10|  }
  625|      6|  for (int i = 0; i < static_cast<int>(expected_result.size()); i++) {
  626|      5|    assert(expected_result[i] == code_result[i]);
  627|      5|  }
  628|      1|  std::cout << "\nTest3 passed!\n";
  629|      1|}
  630|       |
  631|       |/**
  632|       | * Main function
  633|       | */
  634|      1|int main() {
  635|      1|  test_1();
  636|      1|  test_2();
  637|      1|  test_3();
  638|      1|  return 0;
  639|      1|}

