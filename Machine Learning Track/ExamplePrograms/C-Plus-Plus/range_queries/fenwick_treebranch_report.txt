    1|       |/**
    2|       | * @file
    3|       | * @brief [Fenwick Tree](https://en.wikipedia.org/wiki/Fenwick_tree) algorithm
    4|       | * implementation
    5|       | * @details
    6|       | * _From Wikipedia, the free encyclopedia._
    7|       | *
    8|       | * A Fenwick tree or binary indexed tree (BIT) is a clever implementation of a
    9|       | * datastructure called bionomal tree. It can update values and solve range
   10|       | * queries with operations that is; commulative, associative and has an
   11|       | * inverse for this type of element. It can also solve immutable range queries
   12|       | * (min/max), when operations only are associative over this type of element.
   13|       | * Some of these restrictions can be removed, by storing redunant information;
   14|       | * like in max/min range queries.
   15|       | *
   16|       | * @author [Mateusz Grzegorzek](https://github.com/mateusz-grzegorzek)
   17|       | * @author [David Leal](https://github.com/Panquesito7)
   18|       | */
   19|       |
   20|       |#include <cassert>   /// for assert
   21|       |#include <iostream>  /// for IO operations
   22|       |#include <vector>    /// for std::vector
   23|       |
   24|       |/**
   25|       | * @namespace
   26|       | * @brief Range Queries
   27|       | */
   28|       |namespace range_queries {
   29|       |/**
   30|       | * @brief The class that initializes the Fenwick Tree.
   31|       | */
   32|       |class fenwick_tree {
   33|       |    size_t n = 0;            ///< No. of elements present in input array
   34|       |    std::vector<int> bit{};  ///< Array that represents Binary Indexed Tree.
   35|       |
   36|       |    /**
   37|       |     * @brief Returns the highest power of two which is not more than `x`.
   38|       |     * @param x Index of element in original array.
   39|       |     * @return Offset of index.
   40|       |     */
   41|     19|    inline int offset(int x) { return (x & (-x)); }
   42|       | public:
   43|       |    /**
   44|       |     * @brief Class Constructor
   45|       |     * @tparam T the type of the array
   46|       |     * @param[in] arr Input array for which prefix sum is evaluated.
   47|       |     * @return void
   48|       |     */
   49|       |    template <typename T>
   50|      1|    explicit fenwick_tree(const std::vector<T>& arr) : n(arr.size()) {
   51|      1|        bit.assign(n + 1, 0);
   52|      6|        for (int i = 0; i < n; ++i) {
   53|      5|            update(i, arr[i]);
   54|      5|        }
   55|      1|    }
   56|       |
   57|       |    /**
   58|       |     * @brief Class Constructor
   59|       |     * @tparam T the type of the variable
   60|       |     * @param[in] x Size of array that represents Binary Indexed Tree.
   61|       |     * @return void
   62|       |     */
   63|       |    template <typename T>
   64|       |    explicit fenwick_tree(T x) : n(x) { bit.assign(n + 1, 0); }
   65|       |
   66|       |    /**
   67|       |     * @brief Updates the value of an element in original array and
   68|       |     * accordingly updates the values in BIT array.
   69|       |     * @tparam T the type of the variables
   70|       |     * @param id Index of element in original array.
   71|       |     * @param val Value with which element's value is updated.
   72|       |     * @return void
   73|       |     */
   74|       |    template <typename T>
   75|      6|    void update(T id, T val) {
   76|      6|        id++;
   77|     18|        while (id <= n) {
   78|     12|            bit[id] += val;
   79|     12|            id += offset(id);
   80|     12|        }
   81|      6|    }
   82|       |
   83|       |    /**
   84|       |     * @brief Returns the sum of elements in range from 0 to ID.
   85|       |     * @tparam T the type of the variables
   86|       |     * @param id Index in original array up to which sum is evaluated.
   87|       |     * @return Sum of elements in range from 0 to id.
   88|       |     */
   89|       |    template <typename T>
   90|     10|    int sum(T id) {
   91|     10|        id++;
   92|     10|        T res = 0;
   93|     17|        while (id > 0) {
   94|      7|            res += bit[id];
   95|      7|            id -= offset(id);
   96|      7|        }
   97|     10|        return res;
   98|     10|    }
   99|       |
  100|       |    /**
  101|       |     * @brief Returns the prefix sum in range from L to R.
  102|       |     * @param l Left index of range.
  103|       |     * @param r Right index of range.
  104|       |     * @return Sum of elements in range from L to R.
  105|       |     */
  106|      5|    int sum_range(int l, int r) { return sum(r) - sum(l - 1); }
  107|       |};
  108|       |}  // namespace range_queries
  109|       |
  110|       |/**
  111|       | * @brief Self-test implementations
  112|       | * @returns void
  113|       | */
  114|      1|static void tests() {
  115|      1|    std::vector<int> arr = {1, 2, 3, 4, 5};
  116|      1|    range_queries::fenwick_tree fenwick_tree(arr);
  117|       |
  118|      1|    assert(fenwick_tree.sum_range(0, 0) == 1);
  119|      0|    assert(fenwick_tree.sum_range(0, 1) == 3);
  120|      0|    assert(fenwick_tree.sum_range(0, 2) == 6);
  121|      0|    assert(fenwick_tree.sum_range(0, 3) == 10);
  122|      0|    assert(fenwick_tree.sum_range(0, 4) == 15);
  123|       |
  124|      0|    fenwick_tree.update(0, 6);
  125|      1|    std::cout << "All tests have successfully passed!\n";
  126|      1|}
  127|       |
  128|       |/**
  129|       | * @brief Main function
  130|       | * @returns 0 on exit
  131|       | */
  132|      1|int main() {
  133|      1|    tests();  // run self-test implementations
  134|      1|    return 0;
  135|      1|}

