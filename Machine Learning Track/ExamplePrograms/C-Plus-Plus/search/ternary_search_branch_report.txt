    1|       |/**
    2|       | * \file
    3|       | * \brief [Ternary search](https://en.wikipedia.org/wiki/Ternary_search)
    4|       | * algorithm
    5|       | *
    6|       | * This is a divide and conquer algorithm.
    7|       | * It does this by dividing the search space by 3 parts and
    8|       | * using its property (usually monotonic property) to find
    9|       | * the desired index.
   10|       | *
   11|       | * * Time Complexity : O(log3 n)
   12|       | * * Space Complexity : O(1) (without the array)
   13|       | */
   14|       |
   15|       |#include <iostream>
   16|       |
   17|       |/**
   18|       | * The absolutePrecision can be modified to fit preference but
   19|       | * it is recommended to not go lower than 10 due to errors that
   20|       | * may occur.
   21|       | */
   22|      4|#define absolutePrecision 10
   23|       |/**
   24|       | * The value of _target should be decided or can be decided later
   25|       | * by using the variable of the function.
   26|       | */
   27|      1|#define _target 10
   28|       |
   29|       |#define MAX 10000000  ///< Maximum length of array
   30|       |
   31|       |/**
   32|       | * get_input function is to receive input from standard IO
   33|       | * @todo @christianbender Get input from STDIO or write input to memory as done
   34|       | * above.
   35|       | */
   36|      1|void get_input() {}
   37|       |
   38|       |/**
   39|       | * This is the iterative method of the ternary search which returns the index of
   40|       | * the element.
   41|       | * \param[in] left lower interval limit
   42|       | * \param[in] right upper interval limit
   43|       | * \param[in] A array to search in
   44|       | * \param[in] target value to search for
   45|       | * \returns index where the target value was found
   46|       | * \returns -1 if target value not found
   47|       | */
   48|      1|int it_ternary_search(int left, int right, int A[], int target) {
   49|      2|    while (1) {
   50|      2|        if (left < right) {
   51|      2|            if (right - left < absolutePrecision) {
   52|      6|                for (int i = left; i <= right; i++)
   53|      6|                    if (A[i] == target)
   54|      1|                        return i;
   55|       |
   56|      0|                return -1;
   57|      1|            }
   58|       |
   59|      1|            int oneThird = (left + right) / 3 + 1;
   60|      1|            int twoThird = (left + right) * 2 / 3 + 1;
   61|       |
   62|      1|            if (A[oneThird] == target)
   63|      0|                return oneThird;
   64|      1|            else if (A[twoThird] == target)
   65|      0|                return twoThird;
   66|       |
   67|      1|            else if (target > A[twoThird])
   68|      1|                left = twoThird + 1;
   69|      0|            else if (target < A[oneThird])
   70|      0|                right = oneThird - 1;
   71|       |
   72|      0|            else
   73|      0|                left = oneThird + 1, right = twoThird - 1;
   74|      1|        } else {
   75|      0|            return -1;
   76|      0|        }
   77|      2|    }
   78|      1|}
   79|       |
   80|       |/**
   81|       | * This is the recursive method of the ternary search which returns the index of
   82|       | * the element.
   83|       | * \param[in] left lower interval limit
   84|       | * \param[in] right upper interval limit
   85|       | * \param[in] A array to search in
   86|       | * \param[in] target value to search for
   87|       | * \returns index where the target value was found
   88|       | * \returns -1 if target value not found
   89|       | */
   90|      2|int rec_ternary_search(int left, int right, int A[], int target) {
   91|      2|    if (left < right) {
   92|      2|        if (right - left < absolutePrecision) {
   93|      6|            for (int i = left; i <= right; i++)
   94|      6|                if (A[i] == target)
   95|      1|                    return i;
   96|       |
   97|      0|            return -1;
   98|      1|        }
   99|       |
  100|      1|        int oneThird = (left + right) / 3 + 1;
  101|      1|        int twoThird = (left + right) * 2 / 3 + 1;
  102|       |
  103|      1|        if (A[oneThird] == target)
  104|      0|            return oneThird;
  105|      1|        if (A[twoThird] == target)
  106|      0|            return twoThird;
  107|       |
  108|      1|        if (target < A[oneThird])
  109|      0|            return rec_ternary_search(left, oneThird - 1, A, target);
  110|      1|        if (target > A[twoThird])
  111|      1|            return rec_ternary_search(twoThird + 1, right, A, target);
  112|       |
  113|      0|        return rec_ternary_search(oneThird + 1, twoThird - 1, A, target);
  114|      1|    } else {
  115|      0|        return -1;
  116|      0|    }
  117|      2|}
  118|       |
  119|       |/**
  120|       | * ternary_search is a template function
  121|       | * You could either use it_ternary_search or rec_ternary_search according to
  122|       | * preference.
  123|       | * \param [in] N length of array
  124|       | * \param[in] A array to search in
  125|       | * \param[in] target value to search for
  126|       | */
  127|      1|void ternary_search(int N, int A[], int target) {
  128|      1|    std::cout << it_ternary_search(0, N - 1, A, target) << '\t';
  129|      1|    std::cout << rec_ternary_search(0, N - 1, A, target) << '\t';
  130|      1|    std::cout << std::endl;
  131|      1|}
  132|       |
  133|       |/** Main function */
  134|      1|int main() {
  135|      1|    int N = 21;
  136|      1|    int A[] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 4, 10};
  137|      1|    get_input();
  138|      1|    ternary_search(N, A, _target);
  139|      1|    return 0;
  140|      1|}

