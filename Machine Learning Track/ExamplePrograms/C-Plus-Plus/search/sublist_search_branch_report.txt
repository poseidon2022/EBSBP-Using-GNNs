    1|       |/**
    2|       | * @file
    3|       | * @brief Implementation of the [Sublist Search
    4|       | * Algorithm](https://www.geeksforgeeks.org/sublist-search-search-a-linked-list-in-another-list)
    5|       | * @details
    6|       | *
    7|       | * ### Algorithm
    8|       | *
    9|       | *  * Sublist search is used to detect a presence of one list in another list.
   10|       | *  * Suppose we have a single-node list (let's say the first list), and we
   11|       | *  want to ensure that the list is present in another list (let's say the
   12|       | * second list), then we can perform the sublist search to find it.
   13|       | *
   14|       | *  * For instance, the first list contains these elements: 23 -> 30 -> 41,
   15|       | *  and the second list contains these elements: 10 -> 15 -> 23 -> 30 -> 41
   16|       | *  -> 49. At a glance, we see that the first list presents in the second list.
   17|       | *
   18|       | * ### Working
   19|       | *
   20|       | *  * The sublist search algorithm works by comparing the first element
   21|       | *  of the first list with the first element of the second list.
   22|       | *  * If the two values don't match, it goes to the next element of the
   23|       | *  second list. It does this until the two values match.
   24|       | *
   25|       | * @author [Nitin Sharma](https://github.com/foo290)
   26|       | */
   27|       |
   28|       |#include <cassert>   /// for assert
   29|       |#include <cstdint>
   30|       |#include <iostream>  /// for IO operations
   31|       |#include <vector>    /// for std::vector
   32|       |
   33|       |/**
   34|       | * @namespace search
   35|       | * @brief Searching algorithms
   36|       | */
   37|       |namespace search {
   38|       |/**
   39|       | * @namespace sublist_search
   40|       | * @brief Functions for the [Sublist
   41|       | * Search](https://www.geeksforgeeks.org/sublist-search-search-a-linked-list-in-another-list)
   42|       | * implementation
   43|       | */
   44|       |namespace sublist_search {
   45|       |/**
   46|       | * @brief A Node structure representing a single link Node in a linked list
   47|       | */
   48|       |struct Node {
   49|       |    uint32_t data = 0;  ///< the key/value of the node
   50|       |    Node *next{};       ///< pointer to the next node
   51|       |};
   52|       |
   53|       |/**
   54|       | * @brief A simple function to print the linked list
   55|       | * @param start The head of the linked list
   56|       | * @returns void
   57|       | */
   58|      2|void printLinkedList(Node *start) {
   59|      9|    while (start != nullptr) {
   60|      7|        std::cout << "->" << start->data;
   61|      7|        start = start->next;
   62|      7|    }
   63|      2|    std::cout << std::endl;
   64|      2|}
   65|       |
   66|       |/**
   67|       | * @brief Give a vector of data,
   68|       | * it adds each element of vector in the linked list and return the address of
   69|       | * head pointer.
   70|       | * @param data A vector of "int" containing the data that is supposed to be
   71|       | * stored in nodes of linked list.
   72|       | * @returns Node* A head pointer to the linked list.
   73|       | */
   74|      8|Node *makeLinkedList(const std::vector<uint64_t> &data) {
   75|       |    /// This is used in test cases for rapidly creating linked list with 100+
   76|       |    /// elements, instead of hard-coding 100 elements in test cases.
   77|      8|    Node *head = nullptr;
   78|      8|    Node *tail = nullptr;
   79|    273|    for (int i : data) {
   80|    273|        Node *node = new Node;
   81|    273|        node->data = i;
   82|    273|        node->next = nullptr;
   83|    273|        if (head == nullptr) {
   84|      8|            head = node;
   85|      8|            tail = node;
   86|    265|        } else {
   87|    265|            tail->next = node;
   88|    265|            tail = tail->next;
   89|    265|        }
   90|    273|    }
   91|      8|    return head;
   92|      8|}
   93|       |
   94|       |/*
   95|       | * @brief This function dealocates memory related to the given list
   96|       | * It recursively deletes all of the nodes of the input list.
   97|       | * @param room the root/head of the input list
   98|       | * @warning Plese note that the memory for each node has to be alocated using
   99|       | * new.
  100|       | */
  101|    281|void deleteList(Node *const root) {
  102|    281|    if (root != NULL) {
  103|    273|        deleteList(root->next);
  104|    273|        delete root;
  105|    273|    }
  106|    281|}
  107|       |
  108|       |/**
  109|       | * @brief Main searching function
  110|       | * @param sublist A linked list which is supposed to be searched in mainList.
  111|       | * @param mainList A linked list in which sublist will be searched.
  112|       | * @returns true if the sublist is found
  113|       | * @returns false if the sublist is NOT found
  114|       | */
  115|      4|bool sublistSearch(Node *sublist, Node *mainList) {
  116|      4|    if (sublist == nullptr || mainList == nullptr) {
  117|      0|        return false;
  118|      0|    }
  119|       |
  120|       |    /// Initialize target pointer to the head node of sublist.
  121|      4|    Node *target_ptr = sublist;
  122|       |
  123|    156|    while (mainList != nullptr) {
  124|       |        /// Initialize main pointer to the current node of main list.
  125|    154|        Node *main_ptr = mainList;
  126|       |
  127|    986|        while (target_ptr != nullptr) {
  128|    984|            if (main_ptr == nullptr) {
  129|      0|                return false;
  130|       |
  131|    984|            } else if (main_ptr->data == target_ptr->data) {
  132|       |                /// If the data of target node and main node is equal then move
  133|       |                /// to the next node of both lists.
  134|    832|                target_ptr = target_ptr->next;
  135|    832|                main_ptr = main_ptr->next;
  136|       |
  137|    832|            } else {
  138|    152|                break;
  139|    152|            }
  140|    984|        }
  141|       |
  142|    154|        if (target_ptr == nullptr) {
  143|       |            /// Is target pointer becomes null that means the target list is
  144|       |            /// been traversed without returning false. Which means the sublist
  145|       |            /// has been found and return ture.
  146|      2|            return true;
  147|      2|        }
  148|       |
  149|       |        /// set the target pointer again to stating point of target list.
  150|    152|        target_ptr = sublist;
  151|       |
  152|       |        /// set the main pointer to the next element of the main list and repeat
  153|       |        /// the algo.
  154|    152|        mainList = mainList->next;
  155|    152|    }
  156|       |
  157|       |    /// If the main list is exhausted, means sublist does not found, return
  158|       |    /// false
  159|      2|    return false;
  160|      4|}
  161|       |
  162|       |}  // namespace sublist_search
  163|       |}  // namespace search
  164|       |
  165|       |/**
  166|       | * @brief class encapsulating the necessary test cases
  167|       | */
  168|       |class TestCases {
  169|       | private:
  170|       |    /**
  171|       |     * @brief A function to print given message on console.
  172|       |     * @tparam T Type of the given message.
  173|       |     * @returns void
  174|       |     * */
  175|       |    template <typename T>
  176|     26|    void log(T msg) {
  177|       |        // It's just to avoid writing cout and endl
  178|     26|        std::cout << "[TESTS] : ---> " << msg << std::endl;
  179|     26|    }
  180|       |
  181|       | public:
  182|       |    /**
  183|       |     * @brief Executes test cases
  184|       |     * @returns void
  185|       |     * */
  186|      1|    void runTests() {
  187|      1|        log("Running Tests...");
  188|       |
  189|      1|        testCase_1();
  190|      1|        testCase_2();
  191|      1|        testCase_3();
  192|       |
  193|      1|        log("Test Cases over!");
  194|      1|        std::cout << std::endl;
  195|      1|    }
  196|       |
  197|       |    /**
  198|       |     * @brief A test case contains edge case, Only contains one element.
  199|       |     * @returns void
  200|       |     * */
  201|      1|    void testCase_1() {
  202|      1|        const bool expectedOutput = true;  ///< Expected output of this test
  203|       |
  204|      1|        log("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
  205|      1|            "~");
  206|      1|        log("This is test case 1 for sublist search Algorithm : ");
  207|      1|        log("Description:");
  208|      1|        log("   EDGE CASE : Only contains one element");
  209|       |
  210|      1|        std::vector<uint64_t> sublistData = {
  211|      1|            6};  ///< Data to make linked list which will be the sublist
  212|      1|        std::vector<uint64_t> mainlistData = {
  213|      1|            2, 5, 6, 7,
  214|      1|            8};  ///< Data to make linked list which will be the main list
  215|       |
  216|      1|        search::sublist_search::Node *sublistLL =
  217|      1|            search::sublist_search::makeLinkedList(
  218|      1|                sublistData);  ///< Sublist to be searched
  219|      1|        search::sublist_search::Node *mainlistLL =
  220|      1|            search::sublist_search::makeLinkedList(
  221|      1|                mainlistData);  ///< Main list in which sublist is to be
  222|       |                                ///< searched
  223|       |
  224|      1|        bool exists = search::sublist_search::sublistSearch(
  225|      1|            sublistLL, mainlistLL);  ///< boolean, if sublist exist or not
  226|       |
  227|      1|        log("Checking assert expression...");
  228|      1|        assert(exists == expectedOutput);
  229|      0|        log("Assertion check passed!");
  230|       |
  231|      1|        log("[PASS] : TEST CASE 1 PASS!");
  232|      1|        log("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
  233|      1|            "~");
  234|       |
  235|      1|        deleteList(mainlistLL);
  236|      1|        deleteList(sublistLL);
  237|      1|    }
  238|       |
  239|       |    /**
  240|       |     * @brief A test case which contains main list of 100 elements and sublist
  241|       |     * of 20.
  242|       |     * @returns void
  243|       |     * */
  244|      1|    void testCase_2() {
  245|      1|        const bool expectedOutput = true;  /// Expected output of this test
  246|       |
  247|      1|        log("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
  248|      1|            "~");
  249|      1|        log("This is test case 2 for sublist search Algorithm : ");
  250|      1|        log("Description:");
  251|      1|        log("   contains main list of 100 elements and sublist of 20");
  252|       |
  253|      1|        std::vector<uint64_t> sublistData(
  254|      1|            20);  ///< Data to make linked list which will be the sublist
  255|      1|        std::vector<uint64_t> mainlistData(
  256|      1|            100);  ///< Main list in which sublist is to be searched
  257|       |
  258|    101|        for (int i = 0; i < 100; i++) {
  259|       |            /// Inserts 100 elements in main list
  260|    100|            mainlistData[i] = i + 1;
  261|    100|        }
  262|       |
  263|      1|        int temp = 0;
  264|     21|        for (int i = 45; i < 65; i++) {
  265|       |            /// Inserts 20 elements in sublist
  266|     20|            sublistData[temp] = i + 1;
  267|     20|            temp++;
  268|     20|        }
  269|       |
  270|      1|        search::sublist_search::Node *sublistLL =
  271|      1|            search::sublist_search::makeLinkedList(
  272|      1|                sublistData);  ///< Sublist to be searched
  273|      1|        search::sublist_search::Node *mainlistLL =
  274|      1|            search::sublist_search::makeLinkedList(
  275|      1|                mainlistData);  ///< Main list in which sublist is to be
  276|       |                                ///< searched
  277|       |
  278|      1|        bool exists = search::sublist_search::sublistSearch(
  279|      1|            sublistLL, mainlistLL);  ///< boolean, if sublist exist or not
  280|       |
  281|      1|        log("Checking assert expression...");
  282|      1|        assert(exists == expectedOutput);
  283|      0|        log("Assertion check passed!");
  284|       |
  285|      1|        log("[PASS] : TEST CASE 2 PASS!");
  286|      1|        log("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
  287|      1|            "~");
  288|       |
  289|      1|        deleteList(mainlistLL);
  290|      1|        deleteList(sublistLL);
  291|      1|    }
  292|       |
  293|       |    /**
  294|       |     * @brief A test case which contains main list of 50 elements and sublist
  295|       |     * of 20.
  296|       |     * @returns void
  297|       |     * */
  298|      1|    void testCase_3() {
  299|      1|        const bool expectedOutput = false;  ///< Expected output of this test
  300|       |
  301|      1|        log("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
  302|      1|            "~");
  303|      1|        log("This is test case 3 for sublist search Algorithm : ");
  304|      1|        log("Description:");
  305|      1|        log("   contains main list of 50 elements and sublist of 20");
  306|       |
  307|      1|        std::vector<uint64_t> sublistData(20);  ///< Sublist to be searched
  308|      1|        std::vector<uint64_t> mainlistData(
  309|      1|            50);  ///< Main list in which sublist is to be searched
  310|       |
  311|     51|        for (int i = 0; i < 50; i++) {
  312|       |            /// Inserts 100 elements in main list
  313|     50|            mainlistData.push_back(i + 1);
  314|     50|        }
  315|       |
  316|     21|        for (int i = 45; i < 65; i++) {
  317|       |            /// Inserts 20 elements in sublist
  318|     20|            sublistData.push_back(i + 1);
  319|     20|        }
  320|       |
  321|      1|        search::sublist_search::Node *sublistLL =
  322|      1|            search::sublist_search::makeLinkedList(
  323|      1|                sublistData);  ///< Sublist to be searched
  324|      1|        search::sublist_search::Node *mainlistLL =
  325|      1|            search::sublist_search::makeLinkedList(
  326|      1|                mainlistData);  ///< Main list in which sublist is to be
  327|       |                                ///< searched
  328|       |
  329|      1|        bool exists = search::sublist_search::sublistSearch(
  330|      1|            sublistLL, mainlistLL);  ///< boolean, if sublist exist or not
  331|       |
  332|      1|        log("Checking assert expression...");
  333|      1|        assert(exists == expectedOutput);
  334|      0|        log("Assertion check passed!");
  335|       |
  336|      1|        log("[PASS] : TEST CASE 3 PASS!");
  337|      1|        log("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
  338|      1|            "~");
  339|       |
  340|      1|        deleteList(mainlistLL);
  341|      1|        deleteList(sublistLL);
  342|      1|    }
  343|       |};
  344|       |
  345|       |/**
  346|       | * @brief Self-test implementations
  347|       | * @returns void
  348|       | */
  349|      1|static void test() {
  350|      1|    TestCases tc;
  351|      1|    tc.runTests();
  352|      1|}
  353|       |
  354|       |/**
  355|       | * @brief Main function
  356|       | * @param argc commandline argument count (ignored)
  357|       | * @param argv commandline array of arguments (ignored)
  358|       | * @returns 0 on exit
  359|       | */
  360|      1|int main(int argc, char *argv[]) {
  361|      1|    test();  // run self-test implementations
  362|       |
  363|      1|    std::vector<uint64_t> mainlistData = {
  364|      1|        2, 5, 6, 7, 8};  ///< Main list in which sublist is to be searched
  365|      1|    std::vector<uint64_t> sublistData = {6, 8};  ///< Sublist to be searched
  366|       |
  367|      1|    search::sublist_search::Node *mainlistLL =
  368|      1|        search::sublist_search::makeLinkedList(mainlistData);
  369|      1|    search::sublist_search::Node *sublistLL =
  370|      1|        search::sublist_search::makeLinkedList(
  371|      1|            sublistData);  ///< Main list in which sublist is to be
  372|       |                           ///< searched
  373|       |
  374|      1|    bool exists = search::sublist_search::sublistSearch(
  375|      1|        sublistLL,
  376|      1|        mainlistLL);  ///< boolean to check if the sublist exists or not
  377|       |
  378|      1|    std::cout << "Sublist: " << std::endl;
  379|      1|    search::sublist_search::printLinkedList(sublistLL);
  380|       |
  381|      1|    std::cout << "Main list: " << std::endl;
  382|      1|    search::sublist_search::printLinkedList(mainlistLL);
  383|      1|    std::cout << std::endl;
  384|       |
  385|      1|    if (exists) {
  386|      0|        std::cout << "[TRUE] - sublist found in main list\n";
  387|      1|    } else {
  388|      1|        std::cout << "[FALSE] - sublist NOT found in main list\n";
  389|      1|    }
  390|       |
  391|      1|    deleteList(mainlistLL);
  392|      1|    deleteList(sublistLL);
  393|      1|    return 0;
  394|      1|}

