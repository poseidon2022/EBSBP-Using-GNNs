    1|       |/**
    2|       | * \file
    3|       | * \brief [Exponential search
    4|       | * algorithm](https://en.wikipedia.org/wiki/Exponential_search)
    5|       | * \copyright 2020 Divide-et-impera-11
    6|       | *
    7|       | * The algorithm try to search the range where the key should be.
    8|       | * If it has been found we do a binary search there.
    9|       | * The range of the search grows by exponential every time.
   10|       | * If the key is larger than the last element of array, the start of
   11|       | * block(block_front) will be equal to the end of block(block_size) and the
   12|       | * algorithm return null ponter, every other cases the algoritm return fom the
   13|       | * loop.
   14|       | */
   15|       |#include <cassert>
   16|       |#include <cmath>
   17|       |#include <cstdint>
   18|       |#ifdef _MSC_VER
   19|       |#include <string>  // use for MS Visual C++
   20|       |#else
   21|       |#include <cstring>  // for all other compilers
   22|       |#endif
   23|       |
   24|       |/** Binary Search Algorithm (used by ::struzik_search)\n
   25|       | * * Time Complexity O(log n) where 'n' is the number of elements
   26|       | * * Worst Time Complexity O(log n)
   27|       | * * Best Time Complexity Ω(1)
   28|       | * * Space Complexity O(1)
   29|       | * * Auxiliary Space Complexity O(1)
   30|       | * \returns pointer to value in the array
   31|       | * \returns `nullptr` if value not found
   32|       | */
   33|       |template <class Type>
   34|      3|inline Type* binary_s(Type* array, size_t size, Type key) {
   35|      3|    int32_t lower_index(0), upper_index(size - 1), middle_index;
   36|       |
   37|      6|    while (lower_index <= upper_index) {
   38|      4|        middle_index = std::floor((lower_index + upper_index) / 2);
   39|       |
   40|      4|        if (*(array + middle_index) < key)
   41|      0|            lower_index = (middle_index + 1);
   42|      4|        else if (*(array + middle_index) > key)
   43|      3|            upper_index = (middle_index - 1);
   44|      1|        else
   45|      1|            return (array + middle_index);
   46|      4|    }
   47|       |
   48|      2|    return nullptr;
   49|      3|}
   50|       |
   51|       |/** Struzik Search Algorithm(Exponential)
   52|       | * * Time Complexity O(log i) where i is the position of search key in the list
   53|       | * * Worst Time Complexity O(log i)
   54|       | * * Best Time Complexity Ω(1)
   55|       | * * Space Complexity O(1)
   56|       | * * Auxiliary Space Complexity O(1)
   57|       | */
   58|       |template <class Type>
   59|      4|Type* struzik_search(Type* array, size_t size, Type key) {
   60|      4|    uint32_t block_front(0), block_size = size == 0 ? 0 : 1;
   61|     11|    while (block_front != block_size) {
   62|     10|        if (*(array + block_size - 1) < key) {
   63|      7|            block_front = block_size;
   64|      7|            (block_size * 2 - 1 < size) ? (block_size *= 2) : block_size = size;
   65|      7|            continue;
   66|      7|        }
   67|      3|        return binary_s<Type>(array + block_front, (block_size - block_front),
   68|      3|                              key);
   69|     10|    }
   70|      1|    return nullptr;
   71|      4|}
   72|       |
   73|       |/** Main function */
   74|      1|int main() {
   75|       |    // TEST CASES
   76|      1|    int* sorted_array = new int[7]{7, 10, 15, 23, 70, 105, 203};
   77|      1|    assert(struzik_search<int>(sorted_array, 7, 0) == nullptr);
   78|      0|    assert(struzik_search<int>(sorted_array, 7, 1000) == nullptr);
   79|      0|    assert(struzik_search<int>(sorted_array, 7, 50) == nullptr);
   80|      0|    assert(struzik_search<int>(sorted_array, 7, 7) == sorted_array);
   81|       |    // TEST CASES
   82|      0|    delete[] sorted_array;
   83|      1|    return 0;
   84|      1|}

