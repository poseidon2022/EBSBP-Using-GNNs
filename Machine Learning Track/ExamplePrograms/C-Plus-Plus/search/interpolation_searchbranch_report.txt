    1|       |
    2|       |/******************************************************************************
    3|       | * @file
    4|       | * @brief [Interpolation search
    5|       | * algorithm](https://en.wikipedia.org/wiki/interpolation_search)
    6|       | *
    7|       | * @details
    8|       | * interpolation search resembles the method by which people search a telephone
    9|       | * directory for a name (the key value by which the book's entries are ordered):
   10|       | * in each step the algorithm calculates where in the remaining search space
   11|       | * the sought item might be, based on the key values at the bounds of the search
   12|       | * space and the value of the sought key, usually via a linear interpolation.
   13|       | * The key value actually found at this estimated position is then compared to
   14|       | * the key value being sought. If it is not equal, then depending on the
   15|       | * comparison, the remaining search space is reduced to the part before or
   16|       | * after the estimated position. This method will only work if calculations
   17|       | * on the size of differences between key values are sensible.
   18|       |
   19|       | * ### Complexities
   20|       | *
   21|       | * //n is the number of element in the array.
   22|       | *
   23|       | * Worst-case time complexity	O(n)                (when items are distributed
   24|       | exponentially)
   25|       | * Average time complexity	    O(log2(log2 n))
   26|       | * space complexity  0(1)
   27|       | *
   28|       | * @author [Lajat Manekar](https://github.com/Lazeeez)
   29|       | * @author Unknown author
   30|       | *******************************************************************************/
   31|       |
   32|       |#include <algorithm>  /// for std::sort function
   33|       |#include <cassert>    /// for std::assert
   34|       |#include <cstdint>
   35|       |#include <iostream>   /// for IO operations
   36|       |#include <vector>     /// for std::vector
   37|       |
   38|       |/******************************************************************************
   39|       | * @namespace search
   40|       | * @brief Searching algorithms
   41|       | *******************************************************************************/
   42|       |namespace search {
   43|       |
   44|       |/******************************************************************************
   45|       | * @namespace interpolation_search
   46|       | * @brief Functions for the [Interpolation
   47|       | *Search](https://en.wikipedia.org/wiki/interpolation_search) algorithm
   48|       | *implementation
   49|       | *******************************************************************************/
   50|       |namespace interpolation_search {
   51|       |
   52|       |/******************************************************************************
   53|       | * @brief The main function which implements interpolation search
   54|       | * @param arr vector to be searched in
   55|       | * @param number value to be searched
   56|       | * @returns integer index of `number` in vector `arr`
   57|       | *******************************************************************************/
   58|       |uint64_t interpolationSearch(const std::vector<uint64_t> &arr,
   59|      1|                             uint64_t number) {
   60|      1|    uint64_t size = arr.size();
   61|      1|    uint64_t low = 0, high = (size - 1);
   62|       |
   63|       |    // Since vector is sorted, an element present in array must be in range
   64|       |    // defined by corner
   65|     16|    while (low <= high && number >= arr[low] && number <= arr[high]) {
   66|     16|        if (low == high) {
   67|      0|            if (arr[low] == number) {
   68|      0|                return low;
   69|      0|            }
   70|      0|            return -1;
   71|      0|        }
   72|       |        // Probing the position with keeping uniform distribution in mind.
   73|     16|        uint64_t pos =
   74|     16|            low +
   75|     16|            ((static_cast<uint64_t>(high - low) / (arr[high] - arr[low])) *
   76|     16|             (number - arr[low]));
   77|       |
   78|     16|        if (arr[pos] == number) {
   79|      1|            return pos;  // Condition of target found
   80|      1|        }
   81|       |
   82|     15|        if (arr[pos] < number) {
   83|     15|            low = pos + 1;  // If x is larger, x is in upper part
   84|     15|        }
   85|       |
   86|      0|        else {
   87|      0|            high = pos - 1;  // If x is smaller, x is in the lower part
   88|      0|        }
   89|     15|    }
   90|      0|    return -1;
   91|      1|}
   92|       |
   93|       |}  // namespace interpolation_search
   94|       |
   95|       |}  // namespace search
   96|       |
   97|       |/*******************************************************************************
   98|       | * @brief Self-test implementation
   99|       | * @returns void
  100|       | *******************************************************************************/
  101|      1|static void tests() {
  102|       |    // testcase
  103|       |    // array = [10, 12, 13, 16, 18, 19, 20, 21, 1, 2, 3, 4, 22, 23, 24, 33, 35,
  104|       |    // 42, 47] , Value = 33 should return 15
  105|      1|    std::vector<uint64_t> arr = {{10, 12, 13, 16, 18, 19, 20, 21, 1, 2, 3, 4,
  106|      1|                                  22, 23, 24, 33, 35, 42, 47}};
  107|      1|    sort(arr.begin(), arr.end());
  108|      1|    uint64_t number = 33;  // Element to be searched
  109|      1|    uint64_t expected_answer = 15;
  110|      1|    uint64_t derived_answer =
  111|      1|        search::interpolation_search::interpolationSearch(arr, number);
  112|      1|    std::cout << "Testcase: ";
  113|      1|    assert(derived_answer == expected_answer);
  114|      0|    std::cout << "Passed!\n";
  115|      1|}
  116|       |
  117|       |/*******************************************************************************
  118|       | * @brief Main function
  119|       | * @returns 0 on exit
  120|       | *******************************************************************************/
  121|      1|int main() {
  122|      1|    tests();  // run self-test implementations
  123|      1|    return 0;
  124|      1|}

