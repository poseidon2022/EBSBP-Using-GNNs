    1|       |/**
    2|       | * @file
    3|       | * @brief find the length of the Longest Increasing Subsequence (LIS)
    4|       | * using [Binary Search](https://en.wikipedia.org/wiki/Longest_increasing_subsequence)
    5|       | * @details
    6|       | * Given an integer array nums, return the length of the longest strictly
    7|       | * increasing subsequence.
    8|       | * The longest increasing subsequence is described as a subsequence of an array
    9|       | * where: All elements of the subsequence are in increasing order. This subsequence
   10|       | * itself is of the longest length possible.
   11|       |
   12|       | * For solving this problem we have Three Approaches :-
   13|       |
   14|       | * Approach 1 :- Using Brute Force
   15|       | * The first approach that came to your mind is the Brute Force approach where we
   16|       | * generate all subsequences and then manually filter the subsequences whose
   17|       | * elements come in increasing order and then return the longest such subsequence.
   18|       | * Time Complexity :- O(2^n)
   19|       | * It's time complexity is exponential. Therefore we will try some other
   20|       | * approaches.
   21|       |
   22|       | * Approach 2 :- Using Dynamic Programming
   23|       | * To generate all subsequences we will use recursion and in the recursive logic we
   24|       | * will figure out a way to solve this problem. Recursive Logic to solve this
   25|       | * problem:-
   26|       | * 1. We only consider the element in the subsequence if the element is grater then
   27|       | * the last element present in the subsequence
   28|       | * 2. When we consider the element we will increase the length of subsequence by 1
   29|       | * Time Complexity: O(N*N)
   30|       | * Space Complexity: O(N*N) + O(N)
   31|       |
   32|       | * This approach is better then the previous Brute Force approach so, we can
   33|       | * consider this approach.
   34|       |
   35|       | * But when the Constraints for the problem is very larger then this approach fails
   36|       |
   37|       | * Approach 3 :- Using Binary Search
   38|       | * Other approaches use additional space to create a new subsequence Array.
   39|       | * Instead, this solution uses the existing nums Array to build the subsequence
   40|       | * array. We can do this because the length of the subsequence array will never be
   41|       | * longer than the current index.
   42|       |
   43|       | * Time complexity: O(nâˆ—log(n))
   44|       | * Space complexity: O(1)
   45|       |
   46|       | * This approach consider Most optimal Approach for solving this problem
   47|       |
   48|       | * @author [Naman Jain](https://github.com/namanmodi65)
   49|       | */
   50|       |
   51|       |#include <cassert>   /// for std::assert
   52|       |#include <iostream>  /// for IO operations
   53|       |#include <vector>    /// for std::vector
   54|       |#include <algorithm> /// for std::lower_bound
   55|       |#include <cstdint>   /// for std::uint32_t
   56|       |
   57|       |/**
   58|       | * @brief Function to find the length of the Longest Increasing Subsequence (LIS)
   59|       | * using Binary Search
   60|       | * @tparam T The type of the elements in the input vector
   61|       | * @param nums The input vector of elements of type T
   62|       | * @return The length of the longest increasing subsequence
   63|       | */
   64|       |template <typename T>
   65|      7|std::uint32_t longest_increasing_subsequence_using_binary_search(std::vector<T>& nums) {
   66|      7|    if (nums.empty()) return 0;
   67|       |
   68|      6|    std::vector<T> ans;
   69|      6|    ans.push_back(nums[0]);
   70|     38|    for (std::size_t i = 1; i < nums.size(); i++) {
   71|     32|        if (nums[i] > ans.back()) {
   72|     16|            ans.push_back(nums[i]);
   73|     16|        } else {
   74|     16|            auto idx = std::lower_bound(ans.begin(), ans.end(), nums[i]) - ans.begin();
   75|     16|            ans[idx] = nums[i];
   76|     16|        }
   77|     32|    }
   78|      6|    return static_cast<std::uint32_t>(ans.size());
   79|      7|}
  ------------------
  | _Z50longest_increasing_subsequence_using_binary_searchIiEjRSt6vectorIT_SaIS1_EE:
  |   65|      5|std::uint32_t longest_increasing_subsequence_using_binary_search(std::vector<T>& nums) {
  |   66|      5|    if (nums.empty()) return 0;
  |   67|       |
  |   68|      4|    std::vector<T> ans;
  |   69|      4|    ans.push_back(nums[0]);
  |   70|     28|    for (std::size_t i = 1; i < nums.size(); i++) {
  |   71|     24|        if (nums[i] > ans.back()) {
  |   72|     10|            ans.push_back(nums[i]);
  |   73|     14|        } else {
  |   74|     14|            auto idx = std::lower_bound(ans.begin(), ans.end(), nums[i]) - ans.begin();
  |   75|     14|            ans[idx] = nums[i];
  |   76|     14|        }
  |   77|     24|    }
  |   78|      4|    return static_cast<std::uint32_t>(ans.size());
  |   79|      5|}
  ------------------
  | _Z50longest_increasing_subsequence_using_binary_searchIdEjRSt6vectorIT_SaIS1_EE:
  |   65|      1|std::uint32_t longest_increasing_subsequence_using_binary_search(std::vector<T>& nums) {
  |   66|      1|    if (nums.empty()) return 0;
  |   67|       |
  |   68|      1|    std::vector<T> ans;
  |   69|      1|    ans.push_back(nums[0]);
  |   70|      5|    for (std::size_t i = 1; i < nums.size(); i++) {
  |   71|      4|        if (nums[i] > ans.back()) {
  |   72|      3|            ans.push_back(nums[i]);
  |   73|      3|        } else {
  |   74|      1|            auto idx = std::lower_bound(ans.begin(), ans.end(), nums[i]) - ans.begin();
  |   75|      1|            ans[idx] = nums[i];
  |   76|      1|        }
  |   77|      4|    }
  |   78|      1|    return static_cast<std::uint32_t>(ans.size());
  |   79|      1|}
  ------------------
  | _Z50longest_increasing_subsequence_using_binary_searchIcEjRSt6vectorIT_SaIS1_EE:
  |   65|      1|std::uint32_t longest_increasing_subsequence_using_binary_search(std::vector<T>& nums) {
  |   66|      1|    if (nums.empty()) return 0;
  |   67|       |
  |   68|      1|    std::vector<T> ans;
  |   69|      1|    ans.push_back(nums[0]);
  |   70|      5|    for (std::size_t i = 1; i < nums.size(); i++) {
  |   71|      4|        if (nums[i] > ans.back()) {
  |   72|      3|            ans.push_back(nums[i]);
  |   73|      3|        } else {
  |   74|      1|            auto idx = std::lower_bound(ans.begin(), ans.end(), nums[i]) - ans.begin();
  |   75|      1|            ans[idx] = nums[i];
  |   76|      1|        }
  |   77|      4|    }
  |   78|      1|    return static_cast<std::uint32_t>(ans.size());
  |   79|      1|}
  ------------------
   80|       |
   81|       |/**
   82|       | * @brief Test cases for Longest Increasing Subsequence function
   83|       | * @returns void
   84|       | */
   85|      1|static void tests() {
   86|      1|    std::vector<int> arr = {10, 9, 2, 5, 3, 7, 101, 18};
   87|      1|    assert(longest_increasing_subsequence_using_binary_search(arr) == 4);
   88|       |
   89|      0|    std::vector<int> arr2 = {0, 1, 0, 3, 2, 3};
   90|      1|    assert(longest_increasing_subsequence_using_binary_search(arr2) == 4);
   91|       |
   92|      0|    std::vector<int> arr3 = {7, 7, 7, 7, 7, 7, 7};
   93|      1|    assert(longest_increasing_subsequence_using_binary_search(arr3) == 1);
   94|       |
   95|      0|    std::vector<int> arr4 = {-10, -1, -5, 0, 5, 1, 2};
   96|      1|    assert(longest_increasing_subsequence_using_binary_search(arr4) == 5);
   97|       |
   98|      0|    std::vector<double> arr5 = {3.5, 1.2, 2.8, 3.1, 4.0};
   99|      1|    assert(longest_increasing_subsequence_using_binary_search(arr5) == 4);
  100|       |
  101|      0|    std::vector<char> arr6 = {'a', 'b', 'c', 'a', 'd'};
  102|      1|    assert(longest_increasing_subsequence_using_binary_search(arr6) == 4);
  103|       |
  104|      0|    std::vector<int> arr7 = {};
  105|      1|    assert(longest_increasing_subsequence_using_binary_search(arr7) == 0);
  106|       |
  107|      0|    std::cout << "All tests have successfully passed!\n";
  108|      1|}
  109|       |
  110|       |/**
  111|       | * @brief Main function to run tests
  112|       | * @returns 0 on exit
  113|       | */
  114|      1|int main() {
  115|      1|    tests();  // run self test implementation
  116|      1|    return 0;
  117|      1|}

