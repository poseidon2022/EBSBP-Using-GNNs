/home/kidus/Desktop/GNNs/ExamplePrograms/C-Plus-Plus/numerical_methods/lu_decompose.cpp:
    1|       |/**
    2|       | * \file
    3|       | * \brief [LU decomposition](https://en.wikipedia.org/wiki/LU_decompositon) of a
    4|       | * square matrix
    5|       | * \author [Krishna Vedala](https://github.com/kvedala)
    6|       | */
    7|       |#include <cassert>
    8|       |#include <ctime>
    9|       |#include <iomanip>
   10|       |#include <iostream>
   11|       |
   12|       |#include "./lu_decomposition.h"
   13|       |
   14|       |/**
   15|       | * operator to print a matrix
   16|       | */
   17|       |template <typename T>
   18|      0|std::ostream &operator<<(std::ostream &out, matrix<T> const &v) {
   19|      0|    const int width = 10;
   20|      0|    const char separator = ' ';
   21|       |
   22|      0|    for (size_t row = 0; row < v.size(); row++) {
   23|      0|        for (size_t col = 0; col < v[row].size(); col++)
   24|      0|            out << std::left << std::setw(width) << std::setfill(separator)
   25|      0|                << v[row][col];
   26|      0|        out << std::endl;
   27|      0|    }
   28|       |
   29|      0|    return out;
   30|      0|}
   31|       |
   32|       |/**
   33|       | * Test LU decomposition
   34|       | * \todo better ways to self-check a matrix output?
   35|       | */
   36|      0|void test1() {
   37|      0|    int mat_size = 3;  // default matrix size
   38|      0|    const int range = 50;
   39|      0|    const int range2 = range >> 1;
   40|       |
   41|       |    /* Create a square matrix with random values */
   42|      0|    matrix<double> A(mat_size, std::valarray<double>(mat_size));
   43|      0|    matrix<double> L(mat_size, std::valarray<double>(mat_size));  // output
   44|      0|    matrix<double> U(mat_size, std::valarray<double>(mat_size));  // output
   45|      0|    for (int i = 0; i < mat_size; i++) {
   46|       |        // calloc so that all valeus are '0' by default
   47|      0|        for (int j = 0; j < mat_size; j++)
   48|       |            /* create random values in the limits [-range2, range-1] */
   49|      0|            A[i][j] = static_cast<double>(std::rand() % range - range2);
   50|      0|    }
   51|       |
   52|      0|    std::clock_t start_t = std::clock();
   53|      0|    lu_decomposition(A, &L, &U);
   54|      0|    std::clock_t end_t = std::clock();
   55|      0|    std::cout << "Time taken: "
   56|      0|              << static_cast<double>(end_t - start_t) / CLOCKS_PER_SEC << "\n";
   57|       |
   58|      0|    std::cout << "A = \n" << A << "\n";
   59|      0|    std::cout << "L = \n" << L << "\n";
   60|      0|    std::cout << "U = \n" << U << "\n";
   61|      0|}
   62|       |
   63|       |/**
   64|       | * Test determinant computation using LU decomposition
   65|       | */
   66|      0|void test2() {
   67|      0|    std::cout << "Determinant test 1...";
   68|      0|    matrix<int> A1({{1, 2, 3}, {4, 9, 6}, {7, 8, 9}});
   69|      0|    assert(determinant_lu(A1) == -48);
   70|      0|    std::cout << "passed\n";
   71|       |
   72|      0|    std::cout << "Determinant test 2...";
   73|      0|    matrix<int> A2({{1, 2, 3}, {4, 5, 6}, {7, 8, 9}});
   74|      0|    assert(determinant_lu(A2) == 0);
   75|      0|    std::cout << "passed\n";
   76|       |
   77|      0|    std::cout << "Determinant test 3...";
   78|      0|    matrix<float> A3({{1.2, 2.3, 3.4}, {4.5, 5.6, 6.7}, {7.8, 8.9, 9.0}});
   79|      0|    assert(determinant_lu(A3) == 3.63);
   80|      0|    std::cout << "passed\n";
   81|      0|}
   82|       |
   83|       |/** Main function */
   84|      0|int main(int argc, char **argv) {
   85|      0|    std::srand(std::time(NULL));  // random number initializer
   86|       |
   87|      0|    test1();
   88|      0|    test2();
   89|      0|    return 0;
   90|      0|}

/home/kidus/Desktop/GNNs/ExamplePrograms/C-Plus-Plus/numerical_methods/lu_decomposition.h:
    1|       |/**
    2|       | * @file lu_decomposition.h
    3|       | * @author [Krishna Vedala](https://github.com/kvedala)
    4|       | * @brief Functions associated with [LU
    5|       | * Decomposition](https://en.wikipedia.org/wiki/LU_decomposition)
    6|       | * of a square matrix.
    7|       | */
    8|       |#pragma once
    9|       |
   10|       |#include <iostream>
   11|       |#include <valarray>
   12|       |#include <vector>
   13|       |#ifdef _OPENMP
   14|       |#include <omp.h>
   15|       |#endif
   16|       |
   17|       |/** Define matrix type as a `std::vector` of `std::valarray` */
   18|       |template <typename T>
   19|       |using matrix = std::vector<std::valarray<T>>;
   20|       |
   21|       |/** Perform LU decomposition on matrix
   22|       | * \param[in] A matrix to decompose
   23|       | * \param[out] L output L matrix
   24|       | * \param[out] U output U matrix
   25|       | * \returns 0 if no errors
   26|       | * \returns negative if error occurred
   27|       | */
   28|       |template <typename T>
   29|      0|int lu_decomposition(const matrix<T> &A, matrix<double> *L, matrix<double> *U) {
   30|      0|    int row, col, j;
   31|      0|    int mat_size = A.size();
   32|       |
   33|      0|    if (mat_size != A[0].size()) {
   34|       |        // check matrix is a square matrix
   35|      0|        std::cerr << "Not a square matrix!\n";
   36|      0|        return -1;
   37|      0|    }
   38|       |
   39|       |    // regularize each row
   40|      0|    for (row = 0; row < mat_size; row++) {
   41|       |        // Upper triangular matrix
   42|       |#ifdef _OPENMP
   43|       |#pragma omp for
   44|       |#endif
   45|      0|        for (col = row; col < mat_size; col++) {
   46|       |            // Summation of L[i,j] * U[j,k]
   47|      0|            double lu_sum = 0.;
   48|      0|            for (j = 0; j < row; j++) {
   49|      0|                lu_sum += L[0][row][j] * U[0][j][col];
   50|      0|            }
   51|       |
   52|       |            // Evaluate U[i,k]
   53|      0|            U[0][row][col] = A[row][col] - lu_sum;
   54|      0|        }
   55|       |
   56|       |        // Lower triangular matrix
   57|       |#ifdef _OPENMP
   58|       |#pragma omp for
   59|       |#endif
   60|      0|        for (col = row; col < mat_size; col++) {
   61|      0|            if (row == col) {
   62|      0|                L[0][row][col] = 1.;
   63|      0|                continue;
   64|      0|            }
   65|       |
   66|       |            // Summation of L[i,j] * U[j,k]
   67|      0|            double lu_sum = 0.;
   68|      0|            for (j = 0; j < row; j++) {
   69|      0|                lu_sum += L[0][col][j] * U[0][j][row];
   70|      0|            }
   71|       |
   72|       |            // Evaluate U[i,k]
   73|      0|            L[0][col][row] = (A[col][row] - lu_sum) / U[0][row][row];
   74|      0|        }
   75|      0|    }
   76|       |
   77|      0|    return 0;
   78|      0|}
  ------------------
  | Unexecuted instantiation: _Z16lu_decompositionIdEiRKSt6vectorISt8valarrayIT_ESaIS3_EEPS0_IS1_IdESaIS8_EESB_
  ------------------
  | Unexecuted instantiation: _Z16lu_decompositionIiEiRKSt6vectorISt8valarrayIT_ESaIS3_EEPS0_IS1_IdESaIS8_EESB_
  ------------------
  | Unexecuted instantiation: _Z16lu_decompositionIfEiRKSt6vectorISt8valarrayIT_ESaIS3_EEPS0_IS1_IdESaIS8_EESB_
  ------------------
   79|       |
   80|       |/**
   81|       | * Compute determinant of an NxN square matrix using LU decomposition.
   82|       | * Using LU decomposition, the determinant is given by the product of diagonal
   83|       | * elements of matrices L and U.
   84|       | *
   85|       | * @tparam T datatype of input matrix - int, unsigned int, double, etc
   86|       | * @param A input square matrix
   87|       | * @return determinant of matrix A
   88|       | */
   89|       |template <typename T>
   90|      0|double determinant_lu(const matrix<T> &A) {
   91|      0|    matrix<double> L(A.size(), std::valarray<double>(A.size()));
   92|      0|    matrix<double> U(A.size(), std::valarray<double>(A.size()));
   93|       |
   94|      0|    if (lu_decomposition(A, &L, &U) < 0)
   95|      0|        return 0;
   96|       |
   97|      0|    double result = 1.f;
   98|      0|    for (size_t i = 0; i < A.size(); i++) {
   99|      0|        result *= L[i][i] * U[i][i];
  100|      0|    }
  101|      0|    return result;
  102|      0|}
  ------------------
  | Unexecuted instantiation: _Z14determinant_luIiEdRKSt6vectorISt8valarrayIT_ESaIS3_EE
  ------------------
  | Unexecuted instantiation: _Z14determinant_luIfEdRKSt6vectorISt8valarrayIT_ESaIS3_EE
  ------------------

