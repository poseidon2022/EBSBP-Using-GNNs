    1|       |/**
    2|       | * @file
    3|       | * @brief [Gram Schmidt Orthogonalisation
    4|       | * Process](https://en.wikipedia.org/wiki/Gram%E2%80%93Schmidt_process)
    5|       | *
    6|       | * @details
    7|       | * Takes the input of Linearly Independent Vectors,
    8|       | * returns vectors orthogonal to each other.
    9|       | *
   10|       | * ### Algorithm
   11|       | * Take the first vector of given LI vectors as first vector of Orthogonal
   12|       | * vectors. Take projection of second input vector on the first vector of
   13|       | * Orthogonal vector and subtract it from the 2nd LI vector. Take projection of
   14|       | * third vector on the second vector of Othogonal vectors and subtract it from
   15|       | * the 3rd LI vector. Keep repeating the above process until all the vectors in
   16|       | * the given input array are exhausted.
   17|       | *
   18|       | * For Example:
   19|       | * In R2,
   20|       | * Input LI Vectors={(3,1),(2,2)}
   21|       | * then Orthogonal Vectors= {(3, 1),(-0.4, 1.2)}
   22|       | *
   23|       | *  Have defined maximum dimension of vectors to be 10 and number of vectors
   24|       | *  taken is 20.
   25|       | *  Please do not give linearly dependent vectors
   26|       | *
   27|       | *
   28|       | * @author [Akanksha Gupta](https://github.com/Akanksha-Gupta920)
   29|       | */
   30|       |
   31|       |#include <array>     /// for std::array
   32|       |#include <cassert>   /// for assert
   33|       |#include <cmath>     /// for fabs
   34|       |#include <iostream>  /// for io operations
   35|       |
   36|       |#include "math.h"
   37|       |
   38|       |/**
   39|       | * @namespace numerical_methods
   40|       | * @brief Numerical Methods algorithms
   41|       | */
   42|       |namespace numerical_methods {
   43|       |/**
   44|       | * @namespace gram_schmidt
   45|       | * @brief Functions for [Gram Schmidt Orthogonalisation
   46|       | * Process](https://en.wikipedia.org/wiki/Gram%E2%80%93Schmidt_process)
   47|       | */
   48|       |namespace gram_schmidt {
   49|       |/**
   50|       | * Dot product function.
   51|       | * Takes 2 vectors along with their dimension as input and returns the dot
   52|       | * product.
   53|       | * @param x vector 1
   54|       | * @param y vector 2
   55|       | * @param c dimension of the vectors
   56|       | *
   57|       | * @returns sum
   58|       | */
   59|       |double dot_product(const std::array<double, 10>& x,
   60|     15|                   const std::array<double, 10>& y, const int& c) {
   61|     15|    double sum = 0;
   62|     66|    for (int i = 0; i < c; ++i) {
   63|     51|        sum += x[i] * y[i];
   64|     51|    }
   65|     15|    return sum;
   66|     15|}
   67|       |
   68|       |/**
   69|       | * Projection Function
   70|       | * Takes input of 2 vectors along with their dimension and evaluates their
   71|       | * projection in temp
   72|       | *
   73|       | * @param x Vector 1
   74|       | * @param y Vector 2
   75|       | * @param c dimension of each vector
   76|       | *
   77|       | * @returns factor
   78|       | */
   79|       |double projection(const std::array<double, 10>& x,
   80|      5|                  const std::array<double, 10>& y, const int& c) {
   81|      5|    double dot =
   82|      5|        dot_product(x, y, c);  /// The dot product of two vectors is taken
   83|      5|    double anorm =
   84|      5|        dot_product(y, y, c);  /// The norm of the second vector is taken.
   85|      5|    double factor =
   86|      5|        dot /
   87|      5|        anorm;  /// multiply that factor with every element in a 3rd vector,
   88|       |                /// whose initial values are same as the 2nd vector.
   89|      5|    return factor;
   90|      5|}
   91|       |
   92|       |/**
   93|       | * Function to print the orthogonalised vector
   94|       | *
   95|       | * @param r number of vectors
   96|       | * @param c dimenaion of vectors
   97|       | * @param B stores orthogonalised vectors
   98|       | *
   99|       | * @returns void
  100|       | */
  101|       |void display(const int& r, const int& c,
  102|      4|             const std::array<std::array<double, 10>, 20>& B) {
  103|     11|    for (int i = 0; i < r; ++i) {
  104|      7|        std::cout << "Vector " << i + 1 << ": ";
  105|     29|        for (int j = 0; j < c; ++j) {
  106|     22|            std::cout << B[i][j] << " ";
  107|     22|        }
  108|      7|        std::cout << '\n';
  109|      7|    }
  110|      4|}
  111|       |
  112|       |/**
  113|       | * Function for the process of Gram Schimdt Process
  114|       | * @param r number of vectors
  115|       | * @param c dimension of vectors
  116|       | * @param A stores input of given LI vectors
  117|       | * @param B stores orthogonalised vectors
  118|       | *
  119|       | * @returns void
  120|       | */
  121|       |void gram_schmidt(int r, const int& c,
  122|       |                  const std::array<std::array<double, 10>, 20>& A,
  123|      4|                  std::array<std::array<double, 10>, 20> B) {
  124|      4|    if (c < r) {  /// we check whether appropriate dimensions are given or not.
  125|      0|        std::cout << "Dimension of vector is less than number of vector, hence "
  126|      0|                     "\n first "
  127|      0|                  << c << " vectors are orthogonalised\n";
  128|      0|        r = c;
  129|      0|    }
  130|       |
  131|      4|    int k = 1;
  132|       |
  133|     11|    while (k <= r) {
  134|      7|        if (k == 1) {
  135|     12|            for (int j = 0; j < c; j++)
  136|      9|                B[0][j] = A[0][j];  /// First vector is copied as it is.
  137|      3|        }
  138|       |
  139|      4|        else {
  140|      4|            std::array<double, 10>
  141|      4|                all_projection{};  /// array to store projections
  142|     17|            for (int i = 0; i < c; ++i) {
  143|     13|                all_projection[i] = 0;  /// First initialised to zero
  144|     13|            }
  145|       |
  146|      4|            int l = 1;
  147|      9|            while (l < k) {
  148|      5|                std::array<double, 10>
  149|      5|                    temp{};           /// to store previous projected array
  150|      5|                double factor = NAN;  /// to store the factor by which the
  151|       |                                      /// previous array will change
  152|      5|                factor = projection(A[k - 1], B[l - 1], c);
  153|     22|                for (int i = 0; i < c; ++i) {
  154|     17|                    temp[i] = B[l - 1][i] * factor;  /// projected array created
  155|     17|                }
  156|     22|                for (int j = 0; j < c; ++j) {
  157|     17|                    all_projection[j] =
  158|     17|                        all_projection[j] +
  159|     17|                        temp[j];  /// we take the projection with all the
  160|       |                                  /// previous vector and add them.
  161|     17|                }
  162|      5|                l++;
  163|      5|            }
  164|     17|            for (int i = 0; i < c; ++i) {
  165|     13|                B[k - 1][i] =
  166|     13|                    A[k - 1][i] -
  167|     13|                    all_projection[i];  /// subtract total projection vector
  168|       |                                        /// from the input vector
  169|     13|            }
  170|      4|        }
  171|      7|        k++;
  172|      7|    }
  173|      4|    display(r, c, B);  // for displaying orthogoanlised vectors
  174|      4|}
  175|       |}  // namespace gram_schmidt
  176|       |}  // namespace numerical_methods
  177|       |/**
  178|       | * Test Function. Process has been tested for 3 Sample Inputs
  179|       | * @returns void
  180|       | */
  181|      1|static void test() {
  182|      1|    std::array<std::array<double, 10>, 20> a1 = {
  183|      1|        {{1, 0, 1, 0}, {1, 1, 1, 1}, {0, 1, 2, 1}}};
  184|      1|    std::array<std::array<double, 10>, 20> b1 = {{0}};
  185|      1|    double dot1 = 0;
  186|      1|    numerical_methods::gram_schmidt::gram_schmidt(3, 4, a1, b1);
  187|      1|    int flag = 1;
  188|      3|    for (int i = 0; i < 2; ++i) {
  189|      5|        for (int j = i + 1; j < 3; ++j) {
  190|      3|            dot1 = fabs(
  191|      3|                numerical_methods::gram_schmidt::dot_product(b1[i], b1[j], 4));
  192|      3|            if (dot1 > 0.1) {
  193|      0|                flag = 0;
  194|      0|                break;
  195|      0|            }
  196|      3|        }
  197|      2|    }
  198|      1|    if (flag == 0)
  199|      0|        std::cout << "Vectors are linearly dependent\n";
  200|      1|    assert(flag == 1);
  201|      0|    std::cout << "Passed Test Case 1\n ";
  202|       |
  203|      1|    std::array<std::array<double, 10>, 20> a2 = {{{3, 1}, {2, 2}}};
  204|      1|    std::array<std::array<double, 10>, 20> b2 = {{0}};
  205|      1|    double dot2 = 0;
  206|      1|    numerical_methods::gram_schmidt::gram_schmidt(2, 2, a2, b2);
  207|      1|    flag = 1;
  208|      2|    for (int i = 0; i < 1; ++i) {
  209|      2|        for (int j = i + 1; j < 2; ++j) {
  210|      1|            dot2 = fabs(
  211|      1|                numerical_methods::gram_schmidt::dot_product(b2[i], b2[j], 2));
  212|      1|            if (dot2 > 0.1) {
  213|      0|                flag = 0;
  214|      0|                break;
  215|      0|            }
  216|      1|        }
  217|      1|    }
  218|      1|    if (flag == 0)
  219|      0|        std::cout << "Vectors are linearly dependent\n";
  220|      1|    assert(flag == 1);
  221|      0|    std::cout << "Passed Test Case 2\n";
  222|       |
  223|      1|    std::array<std::array<double, 10>, 20> a3 = {{{1, 2, 2}, {-4, 3, 2}}};
  224|      1|    std::array<std::array<double, 10>, 20> b3 = {{0}};
  225|      1|    double dot3 = 0;
  226|      1|    numerical_methods::gram_schmidt::gram_schmidt(2, 3, a3, b3);
  227|      1|    flag = 1;
  228|      2|    for (int i = 0; i < 1; ++i) {
  229|      2|        for (int j = i + 1; j < 2; ++j) {
  230|      1|            dot3 = fabs(
  231|      1|                numerical_methods::gram_schmidt::dot_product(b3[i], b3[j], 3));
  232|      1|            if (dot3 > 0.1) {
  233|      0|                flag = 0;
  234|      0|                break;
  235|      0|            }
  236|      1|        }
  237|      1|    }
  238|      1|    if (flag == 0)
  239|      0|        std::cout << "Vectors are linearly dependent\n";
  240|      1|    assert(flag == 1);
  241|      0|    std::cout << "Passed Test Case 3\n";
  242|      1|}
  243|       |
  244|       |/**
  245|       | * @brief Main Function
  246|       | * @return 0 on exit
  247|       | */
  248|      1|int main() {
  249|      1|    int r = 0, c = 0;
  250|      1|    test();  // perform self tests
  251|      1|    std::cout << "Enter the dimension of your vectors\n";
  252|      1|    std::cin >> c;
  253|      1|    std::cout << "Enter the number of vectors you will enter\n";
  254|      1|    std::cin >> r;
  255|       |
  256|      1|    std::array<std::array<double, 10>, 20>
  257|      1|        A{};  /// a 2-D array for storing all vectors
  258|      1|    std::array<std::array<double, 10>, 20> B = {
  259|      1|        {0}};  /// a 2-D array for storing orthogonalised vectors
  260|       |    /// storing vectors in array A
  261|      1|    for (int i = 0; i < r; ++i) {
  262|      0|        std::cout << "Enter vector " << i + 1
  263|      0|                  << '\n';  /// Input of vectors is taken
  264|      0|        for (int j = 0; j < c; ++j) {
  265|      0|            std::cout << "Value " << j + 1 << "th of vector: ";
  266|      0|            std::cin >> A[i][j];
  267|      0|        }
  268|      0|        std::cout << '\n';
  269|      0|    }
  270|       |
  271|      1|    numerical_methods::gram_schmidt::gram_schmidt(r, c, A, B);
  272|       |
  273|      1|    double dot = 0;
  274|      1|    int flag = 1;  /// To check whether vectors are orthogonal or  not
  275|      1|    for (int i = 0; i < r - 1; ++i) {
  276|      0|        for (int j = i + 1; j < r; ++j) {
  277|      0|            dot = fabs(
  278|      0|                numerical_methods::gram_schmidt::dot_product(B[i], B[j], c));
  279|      0|            if (dot > 0.1)  /// take make the process numerically stable, upper
  280|       |                            /// bound for the dot product take 0.1
  281|      0|            {
  282|      0|                flag = 0;
  283|      0|                break;
  284|      0|            }
  285|      0|        }
  286|      0|    }
  287|      1|    if (flag == 0)
  288|      0|        std::cout << "Vectors are linearly dependent\n";
  289|      1|    return 0;
  290|      1|}

