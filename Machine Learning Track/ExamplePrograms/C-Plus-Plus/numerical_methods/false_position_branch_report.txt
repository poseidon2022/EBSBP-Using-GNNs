    1|       |/**
    2|       | * \file
    3|       | * \brief Solve the equation \f$f(x)=0\f$ using [false position
    4|       | * method](https://en.wikipedia.org/wiki/Regula_falsi), also known as the Secant
    5|       | * method
    6|       | *
    7|       | * \details
    8|       | * First, multiple intervals are selected with the interval gap provided.
    9|       | * Separate recursive function called for every root.
   10|       | * Roots are printed Separatelt.
   11|       | *
   12|       | * For an interval [a,b] \f$a\f$ and \f$b\f$ such that \f$f(a)<0\f$ and
   13|       | * \f$f(b)>0\f$, then the \f$(i+1)^\text{th}\f$ approximation is given by: \f[
   14|       | * x_{i+1} = \frac{a_i\cdot f(b_i) - b_i\cdot f(a_i)}{f(b_i) - f(a_i)}
   15|       | * \f]
   16|       | * For the next iteration, the interval is selected
   17|       | * as: \f$[a,x]\f$ if \f$x>0\f$ or \f$[x,b]\f$ if \f$x<0\f$. The Process is
   18|       | * continued till a close enough approximation is achieved.
   19|       | *
   20|       | * \see newton_raphson_method.cpp, bisection_method.cpp
   21|       | *
   22|       | * \author Unknown author
   23|       | * \author [Samruddha Patil](https://github.com/sampatil578)
   24|       | */
   25|       |#include <cmath>     /// for math operations
   26|       |#include <iostream>  /// for io operations
   27|       |
   28|       |/**
   29|       | * @namespace numerical_methods
   30|       | * @brief Numerical methods
   31|       | */
   32|       |namespace numerical_methods {
   33|       |/**
   34|       | * @namespace false_position
   35|       | * @brief Functions for [False Position]
   36|       | * (https://en.wikipedia.org/wiki/Regula_falsi) method.
   37|       | */
   38|       |namespace false_position {
   39|       |/**
   40|       | * @brief This function gives the value of f(x) for given x.
   41|       | * @param x value for which we have to find value of f(x).
   42|       | * @return value of f(x) for given x.
   43|       | */
   44|   400k|static float eq(float x) {
   45|   400k|    return (x * x - x);  // original equation
   46|   400k|}
   47|       |
   48|       |/**
   49|       |* @brief This function finds root of the equation in given interval i.e.
   50|       |(x1,x2).
   51|       |* @param x1,x2 values for an interval in which root is present.
   52|       |  @param y1,y2 values of function at x1, x2 espectively.
   53|       |* @return root of the equation in the given interval.
   54|       |*/
   55|      0|static float regula_falsi(float x1, float x2, float y1, float y2) {
   56|      0|    float diff = x1 - x2;
   57|      0|    if (diff < 0) {
   58|      0|        diff = (-1) * diff;
   59|      0|    }
   60|      0|    if (diff < 0.00001) {
   61|      0|        if (y1 < 0) {
   62|      0|            y1 = -y1;
   63|      0|        }
   64|      0|        if (y2 < 0) {
   65|      0|            y2 = -y2;
   66|      0|        }
   67|      0|        if (y1 < y2) {
   68|      0|            return x1;
   69|      0|        } else {
   70|      0|            return x2;
   71|      0|        }
   72|      0|    }
   73|      0|    float x3 = 0, y3 = 0;
   74|      0|    x3 = x1 - (x1 - x2) * (y1) / (y1 - y2);
   75|      0|    y3 = eq(x3);
   76|      0|    return regula_falsi(x2, x3, y2, y3);
   77|      0|}
   78|       |
   79|       |/**
   80|       | * @brief This function prints roots of the equation.
   81|       | * @param root which we have to print.
   82|       | * @param count which is count of the root in an interval [-range,range].
   83|       | */
   84|      2|void printRoot(float root, const int16_t &count) {
   85|      2|    if (count == 1) {
   86|      1|        std::cout << "Your 1st root is : " << root << std::endl;
   87|      1|    } else if (count == 2) {
   88|      1|        std::cout << "Your 2nd root is : " << root << std::endl;
   89|      1|    } else if (count == 3) {
   90|      0|        std::cout << "Your 3rd root is : " << root << std::endl;
   91|      0|    } else {
   92|      0|        std::cout << "Your " << count << "th root is : " << root << std::endl;
   93|      0|    }
   94|      2|}
   95|       |}  // namespace false_position
   96|       |}  // namespace numerical_methods
   97|       |
   98|       |/**
   99|       | * @brief Main function
  100|       | * @returns 0 on exit
  101|       | */
  102|      1|int main() {
  103|      1|    float a = 0, b = 0, i = 0, root = 0;
  104|      1|    int16_t count = 0;
  105|      1|    float range =
  106|      1|        100000;       // Range in which we have to find the root. (-range,range)
  107|      1|    float gap = 0.5;  // interval gap. lesser the gap more the accuracy
  108|      1|    a = numerical_methods::false_position::eq((-1) * range);
  109|      1|    i = ((-1) * range + gap);
  110|       |    // while loop for selecting proper interval in provided range and with
  111|       |    // provided interval gap.
  112|   400k|    while (i <= range) {
  113|   400k|        b = numerical_methods::false_position::eq(i);
  114|   400k|        if (b == 0) {
  115|      2|            count++;
  116|      2|            numerical_methods::false_position::printRoot(i, count);
  117|      2|        }
  118|   400k|        if (a * b < 0) {
  119|      0|            root = numerical_methods::false_position::regula_falsi(i - gap, i,
  120|      0|                                                                   a, b);
  121|      0|            count++;
  122|      0|            numerical_methods::false_position::printRoot(root, count);
  123|      0|        }
  124|   400k|        a = b;
  125|   400k|        i += gap;
  126|   400k|    }
  127|      1|    return 0;
  128|      1|}

