    1|       |/**
    2|       | * \file
    3|       | * \brief Find real extrema of a univariate real function in a given interval
    4|       | * using [Brent's method](https://en.wikipedia.org/wiki/Brent%27s_method).
    5|       | *
    6|       | * Refer the algorithm discoverer's publication
    7|       | * [online](https://maths-people.anu.edu.au/~brent/pd/rpb011i.pdf) and also
    8|       | * associated book:
    9|       | * > R. P. Brent, Algorithms for Minimization without
   10|       | * > Derivatives, Prentice-Hall, Englewood Cliffs, New Jersey, 1973
   11|       | *
   12|       | * \see golden_search_extrema.cpp
   13|       | *
   14|       | * \author [Krishna Vedala](https://github.com/kvedala)
   15|       | */
   16|       |#define _USE_MATH_DEFINES  ///< required for MS Visual C++
   17|       |#include <cassert>
   18|       |#include <cmath>
   19|       |#include <cstdint>
   20|       |#include <functional>
   21|       |#include <iostream>
   22|       |#include <limits>
   23|       |
   24|       |#define EPSILON \
   25|     37|    std::sqrt(  \
   26|     37|        std::numeric_limits<double>::epsilon())  ///< system accuracy limit
   27|       |
   28|       |/**
   29|       | * @brief Get the real root of a function in the given interval.
   30|       | *
   31|       | * @param f function to get root for
   32|       | * @param lim_a lower limit of search window
   33|       | * @param lim_b upper limit of search window
   34|       | * @return root found in the interval
   35|       | */
   36|       |double get_minima(const std::function<double(double)> &f, double lim_a,
   37|      3|                  double lim_b) {
   38|      3|    uint32_t iters = 0;
   39|       |
   40|      3|    if (lim_a > lim_b) {
   41|      0|        std::swap(lim_a, lim_b);
   42|      3|    } else if (std::abs(lim_a - lim_b) <= EPSILON) {
   43|      0|        std::cerr << "Search range must be greater than " << EPSILON << "\n";
   44|      0|        return lim_a;
   45|      0|    }
   46|       |
   47|       |    // golden ratio value
   48|      3|    const double M_GOLDEN_RATIO = (3.f - std::sqrt(5.f)) / 2.f;
   49|       |
   50|      3|    double v = lim_a + M_GOLDEN_RATIO * (lim_b - lim_a);
   51|      3|    double u, w = v, x = v;
   52|      3|    double fu, fv = f(v);
   53|      3|    double fw = fv, fx = fv;
   54|       |
   55|      3|    double mid_point = (lim_a + lim_b) / 2.f;
   56|      3|    double p = 0, q = 0, r = 0;
   57|       |
   58|      3|    double d, e = 0;
   59|      3|    double tolerance, tolerance2;
   60|       |
   61|     33|    do {
   62|     33|        mid_point = (lim_a + lim_b) / 2.f;
   63|     33|        tolerance = EPSILON * std::abs(x);
   64|     33|        tolerance2 = 2 * tolerance;
   65|       |
   66|     33|        if (std::abs(e) > tolerance2) {
   67|       |            // fit parabola
   68|     25|            r = (x - w) * (fx - fv);
   69|     25|            q = (x - v) * (fx - fw);
   70|     25|            p = (x - v) * q - (x - w) * r;
   71|     25|            q = 2.f * (q - r);
   72|     25|            if (q > 0)
   73|     11|                p = -p;
   74|     14|            else
   75|     14|                q = -q;
   76|     25|            r = e;
   77|     25|            e = d;
   78|     25|        }
   79|       |
   80|     33|        if (std::abs(p) < std::abs(0.5 * q * r) && p < q * (lim_b - x)) {
   81|       |            // parabolic interpolation step
   82|     25|            d = p / q;
   83|     25|            u = x + d;
   84|     25|            if (u - lim_a < tolerance2 || lim_b - u < tolerance2)
   85|      7|                d = x < mid_point ? tolerance : -tolerance;
   86|     25|        } else {
   87|       |            // golden section interpolation step
   88|      8|            e = (x < mid_point ? lim_b : lim_a) - x;
   89|      8|            d = M_GOLDEN_RATIO * e;
   90|      8|        }
   91|       |
   92|       |        // evaluate not too close to x
   93|     33|        if (std::abs(d) >= tolerance)
   94|     29|            u = d;
   95|      4|        else if (d > 0)
   96|      0|            u = tolerance;
   97|      4|        else
   98|      4|            u = -tolerance;
   99|     33|        u += x;
  100|     33|        fu = f(u);
  101|       |
  102|       |        // update variables
  103|     33|        if (fu <= fx) {
  104|     21|            if (u < x)
  105|      9|                lim_b = x;
  106|     12|            else
  107|     12|                lim_a = x;
  108|     21|            v = w;
  109|     21|            fv = fw;
  110|     21|            w = x;
  111|     21|            fw = fx;
  112|     21|            x = u;
  113|     21|            fx = fu;
  114|     21|        } else {
  115|     12|            if (u < x)
  116|      7|                lim_a = u;
  117|      5|            else
  118|      5|                lim_b = u;
  119|     12|            if (fu <= fw || x == w) {
  120|      8|                v = w;
  121|      8|                fv = fw;
  122|      8|                w = u;
  123|      8|                fw = fu;
  124|      8|            } else if (fu <= fv || v == x || v == w) {
  125|      3|                v = u;
  126|      3|                fv = fu;
  127|      3|            }
  128|     12|        }
  129|       |
  130|     33|        iters++;
  131|     33|    } while (std::abs(x - mid_point) > (tolerance - (lim_b - lim_a) / 2.f));
  132|       |
  133|      3|    std::cout << " (iters: " << iters << ") ";
  134|       |
  135|      3|    return x;
  136|      3|}
  137|       |
  138|       |/**
  139|       | * @brief Test function to find root for the function
  140|       | * \f$f(x)= (x-2)^2\f$
  141|       | * in the interval \f$[1,5]\f$
  142|       | * \n Expected result = 2
  143|       | */
  144|      1|void test1() {
  145|       |    // define the function to minimize as a lambda function
  146|      7|    std::function<double(double)> f1 = [](double x) {
  147|      7|        return (x - 2) * (x - 2);
  148|      7|    };
  149|       |
  150|      1|    std::cout << "Test 1.... ";
  151|       |
  152|      1|    double minima = get_minima(f1, -1, 5);
  153|       |
  154|      1|    std::cout << minima << "...";
  155|       |
  156|      1|    assert(std::abs(minima - 2) < EPSILON);
  157|      0|    std::cout << "passed\n";
  158|      1|}
  159|       |
  160|       |/**
  161|       | * @brief Test function to find root for the function
  162|       | * \f$f(x)= x^{\frac{1}{x}}\f$
  163|       | * in the interval \f$[-2,10]\f$
  164|       | * \n Expected result: \f$e\approx 2.71828182845904509\f$
  165|       | */
  166|      1|void test2() {
  167|       |    // define the function to maximize as a lambda function
  168|       |    // since we are maximixing, we negated the function return value
  169|     17|    std::function<double(double)> func = [](double x) {
  170|     17|        return -std::pow(x, 1.f / x);
  171|     17|    };
  172|       |
  173|      1|    std::cout << "Test 2.... ";
  174|       |
  175|      1|    double minima = get_minima(func, -2, 5);
  176|       |
  177|      1|    std::cout << minima << " (" << M_E << ")...";
  178|       |
  179|      1|    assert(std::abs(minima - M_E) < EPSILON);
  180|      0|    std::cout << "passed\n";
  181|      1|}
  182|       |
  183|       |/**
  184|       | * @brief Test function to find *maxima* for the function
  185|       | * \f$f(x)= \cos x\f$
  186|       | * in the interval \f$[0,12]\f$
  187|       | * \n Expected result: \f$\pi\approx 3.14159265358979312\f$
  188|       | */
  189|      1|void test3() {
  190|       |    // define the function to maximize as a lambda function
  191|       |    // since we are maximixing, we negated the function return value
  192|     12|    std::function<double(double)> func = [](double x) { return std::cos(x); };
  193|       |
  194|      1|    std::cout << "Test 3.... ";
  195|       |
  196|      1|    double minima = get_minima(func, -4, 12);
  197|       |
  198|      1|    std::cout << minima << " (" << M_PI << ")...";
  199|       |
  200|      1|    assert(std::abs(minima - M_PI) < EPSILON);
  201|      0|    std::cout << "passed\n";
  202|      1|}
  203|       |
  204|       |/** Main function */
  205|      1|int main() {
  206|      1|    std::cout.precision(18);
  207|       |
  208|      1|    std::cout << "Computations performed with machine epsilon: " << EPSILON
  209|      1|              << "\n";
  210|       |
  211|      1|    test1();
  212|      1|    test2();
  213|      1|    test3();
  214|       |
  215|      1|    return 0;
  216|      1|}

