    1|       |/**
    2|       | * @file
    3|       | * @brief Implementation of the Composite Simpson Rule for the approximation
    4|       | *
    5|       | * @details The following is an implementation of the Composite Simpson Rule for
    6|       | * the approximation of definite integrals. More info -> wiki:
    7|       | * https://en.wikipedia.org/wiki/Simpson%27s_rule#Composite_Simpson's_rule
    8|       | *
    9|       | * The idea is to split the interval in an EVEN number N of intervals and use as
   10|       | * interpolation points the xi for which it applies that xi = x0 + i*h, where h
   11|       | * is a step defined as h = (b-a)/N where a and b are the first and last points
   12|       | * of the interval of the integration [a, b].
   13|       | *
   14|       | * We create a table of the xi and their corresponding f(xi) values and we
   15|       | * evaluate the integral by the formula: I = h/3 * {f(x0) + 4*f(x1) + 2*f(x2) +
   16|       | * ... + 2*f(xN-2) + 4*f(xN-1) + f(xN)}
   17|       | *
   18|       | * That means that the first and last indexed i f(xi) are multiplied by 1,
   19|       | * the odd indexed f(xi) by 4 and the even by 2.
   20|       | *
   21|       | * In this program there are 4 sample test functions f, g, k, l that are
   22|       | * evaluated in the same interval.
   23|       | *
   24|       | * Arguments can be passed as parameters from the command line argv[1] = N,
   25|       | * argv[2] = a, argv[3] = b
   26|       | *
   27|       | * N must be even number and a<b.
   28|       | *
   29|       | * In the end of the main() i compare the program's result with the one from
   30|       | * mathematical software with 2 decimal points margin.
   31|       | *
   32|       | * Add sample function by replacing one of the f, g, k, l and the assert
   33|       | *
   34|       | * @author [ggkogkou](https://github.com/ggkogkou)
   35|       | *
   36|       | */
   37|       |
   38|       |#include <cassert>  /// for assert
   39|       |#include <cmath>    /// for math functions
   40|       |#include <cmath>
   41|       |#include <cstdint>     /// for integer allocation
   42|       |#include <cstdlib>     /// for std::atof
   43|       |#include <functional>  /// for std::function
   44|       |#include <iostream>    /// for IO operations
   45|       |#include <map>         /// for std::map container
   46|       |
   47|       |/**
   48|       | * @namespace numerical_methods
   49|       | * @brief Numerical algorithms/methods
   50|       | */
   51|       |namespace numerical_methods {
   52|       |/**
   53|       | * @namespace simpson_method
   54|       | * @brief Contains the Simpson's method implementation
   55|       | */
   56|       |namespace simpson_method {
   57|       |/**
   58|       | * @fn double evaluate_by_simpson(int N, double h, double a,
   59|       | * std::function<double (double)> func)
   60|       | * @brief Calculate integral or assert if integral is not a number (Nan)
   61|       | * @param N number of intervals
   62|       | * @param h step
   63|       | * @param a x0
   64|       | * @param func: choose the function that will be evaluated
   65|       | * @returns the result of the integration
   66|       | */
   67|       |double evaluate_by_simpson(std::int32_t N, double h, double a,
   68|      4|                           const std::function<double(double)>& func) {
   69|      4|    std::map<std::int32_t, double>
   70|      4|        data_table;  // Contains the data points. key: i, value: f(xi)
   71|      4|    double xi = a;   // Initialize xi to the starting point x0 = a
   72|       |
   73|       |    // Create the data table
   74|      4|    double temp = NAN;
   75|     72|    for (std::int32_t i = 0; i <= N; i++) {
   76|     68|        temp = func(xi);
   77|     68|        data_table.insert(
   78|     68|            std::pair<std::int32_t, double>(i, temp));  // add i and f(xi)
   79|     68|        xi += h;  // Get the next point xi for the next iteration
   80|     68|    }
   81|       |
   82|       |    // Evaluate the integral.
   83|       |    // Remember: f(x0) + 4*f(x1) + 2*f(x2) + ... + 2*f(xN-2) + 4*f(xN-1) + f(xN)
   84|      4|    double evaluate_integral = 0;
   85|     72|    for (std::int32_t i = 0; i <= N; i++) {
   86|     68|        if (i == 0 || i == N) {
   87|      8|            evaluate_integral += data_table.at(i);
   88|     60|        } else if (i % 2 == 1) {
   89|     32|            evaluate_integral += 4 * data_table.at(i);
   90|     32|        } else {
   91|     28|            evaluate_integral += 2 * data_table.at(i);
   92|     28|        }
   93|     68|    }
   94|       |
   95|       |    // Multiply by the coefficient h/3
   96|      4|    evaluate_integral *= h / 3;
   97|       |
   98|       |    // If the result calculated is nan, then the user has given wrong input
   99|       |    // interval.
  100|      4|    assert(!std::isnan(evaluate_integral) &&
  101|      4|           "The definite integral can't be evaluated. Check the validity of "
  102|      4|           "your input.\n");
  103|       |    // Else return
  104|      0|    return evaluate_integral;
  105|      4|}
  106|       |
  107|       |/**
  108|       | * @fn double f(double x)
  109|       | * @brief A function f(x) that will be used to test the method
  110|       | * @param x The independent variable xi
  111|       | * @returns the value of the dependent variable yi = f(xi)
  112|       | */
  113|     17|double f(double x) { return std::sqrt(x) + std::log(x); }
  114|       |/** @brief Another test function */
  115|     17|double g(double x) { return std::exp(-x) * (4 - std::pow(x, 2)); }
  116|       |/** @brief Another test function */
  117|     17|double k(double x) { return std::sqrt(2 * std::pow(x, 3) + 3); }
  118|       |/** @brief Another test function*/
  119|     17|double l(double x) { return x + std::log(2 * x + 1); }
  120|       |}  // namespace simpson_method
  121|       |}  // namespace numerical_methods
  122|       |
  123|       |/**
  124|       | * \brief Self-test implementations
  125|       | * @param N is the number of intervals
  126|       | * @param h is the step
  127|       | * @param a is x0
  128|       | * @param b is the end of the interval
  129|       | * @param used_argv_parameters is 'true' if argv parameters are given and
  130|       | * 'false' if not
  131|       | */
  132|       |static void test(std::int32_t N, double h, double a, double b,
  133|      1|                 bool used_argv_parameters) {
  134|       |    // Call the functions and find the integral of each function
  135|      1|    double result_f = numerical_methods::simpson_method::evaluate_by_simpson(
  136|      1|        N, h, a, numerical_methods::simpson_method::f);
  137|      1|    assert((used_argv_parameters || (result_f >= 4.09 && result_f <= 4.10)) &&
  138|      1|           "The result of f(x) is wrong");
  139|      0|    std::cout << "The result of integral f(x) on interval [" << a << ", " << b
  140|      1|              << "] is equal to: " << result_f << std::endl;
  141|       |
  142|      1|    double result_g = numerical_methods::simpson_method::evaluate_by_simpson(
  143|      1|        N, h, a, numerical_methods::simpson_method::g);
  144|      1|    assert((used_argv_parameters || (result_g >= 0.27 && result_g <= 0.28)) &&
  145|      1|           "The result of g(x) is wrong");
  146|      0|    std::cout << "The result of integral g(x) on interval [" << a << ", " << b
  147|      1|              << "] is equal to: " << result_g << std::endl;
  148|       |
  149|      1|    double result_k = numerical_methods::simpson_method::evaluate_by_simpson(
  150|      1|        N, h, a, numerical_methods::simpson_method::k);
  151|      1|    assert((used_argv_parameters || (result_k >= 9.06 && result_k <= 9.07)) &&
  152|      1|           "The result of k(x) is wrong");
  153|      0|    std::cout << "The result of integral k(x) on interval [" << a << ", " << b
  154|      1|              << "] is equal to: " << result_k << std::endl;
  155|       |
  156|      1|    double result_l = numerical_methods::simpson_method::evaluate_by_simpson(
  157|      1|        N, h, a, numerical_methods::simpson_method::l);
  158|      1|    assert((used_argv_parameters || (result_l >= 7.16 && result_l <= 7.17)) &&
  159|      1|           "The result of l(x) is wrong");
  160|      0|    std::cout << "The result of integral l(x) on interval [" << a << ", " << b
  161|      1|              << "] is equal to: " << result_l << std::endl;
  162|      1|}
  163|       |
  164|       |/**
  165|       | * @brief Main function
  166|       | * @param argc commandline argument count (ignored)
  167|       | * @param argv commandline array of arguments (ignored)
  168|       | * @returns 0 on exit
  169|       | */
  170|      1|int main(int argc, char** argv) {
  171|      1|    std::int32_t N = 16;  /// Number of intervals to divide the integration
  172|       |                          /// interval. MUST BE EVEN
  173|      1|    double a = 1, b = 3;  /// Starting and ending point of the integration in
  174|       |                          /// the real axis
  175|      1|    double h = NAN;       /// Step, calculated by a, b and N
  176|       |
  177|      1|    bool used_argv_parameters =
  178|      1|        false;  // If argv parameters are used then the assert must be omitted
  179|       |                // for the tst cases
  180|       |
  181|       |    // Get user input (by the command line parameters or the console after
  182|       |    // displaying messages)
  183|      1|    if (argc == 4) {
  184|      0|        N = std::atoi(argv[1]);
  185|      0|        a = std::atof(argv[2]);
  186|      0|        b = std::atof(argv[3]);
  187|       |        // Check if a<b else abort
  188|      0|        assert(a < b && "a has to be less than b");
  189|      0|        assert(N > 0 && "N has to be > 0");
  190|      0|        if (N < 16 || a != 1 || b != 3) {
  191|      0|            used_argv_parameters = true;
  192|      0|        }
  193|      0|        std::cout << "You selected N=" << N << ", a=" << a << ", b=" << b
  194|      0|                  << std::endl;
  195|      1|    } else {
  196|      1|        std::cout << "Default N=" << N << ", a=" << a << ", b=" << b
  197|      1|                  << std::endl;
  198|      1|    }
  199|       |
  200|       |    // Find the step
  201|      0|    h = (b - a) / N;
  202|       |
  203|      1|    test(N, h, a, b, used_argv_parameters);  // run self-test implementations
  204|       |
  205|      1|    return 0;
  206|      1|}

