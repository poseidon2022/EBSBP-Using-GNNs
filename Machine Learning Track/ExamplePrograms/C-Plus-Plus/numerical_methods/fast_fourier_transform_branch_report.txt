    1|       |/**
    2|       | * @file
    3|       | * @brief [A fast Fourier transform
    4|       | * (FFT)](https://medium.com/@aiswaryamathur/understanding-fast-fouriertransform-from-scratch-to-solve-polynomial-multiplication-8018d511162f)
    5|       | * is an algorithm that computes the
    6|       | * discrete Fourier transform (DFT) of a sequence, or its inverse (IDFT).
    7|       | * @details
    8|       | * This
    9|       | * algorithm has application in use case scenario where a user wants to find
   10|       | points of a
   11|       | * function
   12|       | * in a short time by just using the coefficients of the polynomial
   13|       | * function.
   14|       | * It can be also used to find inverse fourier transform by just switching the
   15|       | value of omega.
   16|       | * Time complexity
   17|       | * this algorithm computes the DFT in O(nlogn) time in comparison to traditional
   18|       | O(n^2).
   19|       | * @author [Ameya Chawla](https://github.com/ameyachawlaggsipu)
   20|       | */
   21|       |
   22|       |#include <cassert>   /// for assert
   23|       |#include <cmath>     /// for mathematical-related functions
   24|       |#include <complex>   /// for storing points and coefficents
   25|       |#include <cstdint>
   26|       |#include <iostream>  /// for IO operations
   27|       |#include <vector>    /// for std::vector
   28|       |
   29|       |/**
   30|       | * @namespace numerical_methods
   31|       | * @brief Numerical algorithms/methods
   32|       | */
   33|       |namespace numerical_methods {
   34|       |/**
   35|       | * @brief FastFourierTransform is a recursive function which returns list of
   36|       | * complex numbers
   37|       | * @param p List of Coefficents in form of complex numbers
   38|       | * @param n Count of elements in list p
   39|       | * @returns p if n==1
   40|       | * @returns y if n!=1
   41|       | */
   42|     10|std::complex<double> *FastFourierTransform(std::complex<double> *p, uint8_t n) {
   43|     10|    if (n == 1) {
   44|      6|        return p;  /// Base Case To return
   45|      6|    }
   46|       |
   47|      4|    double pi = 2 * asin(1.0);  /// Declaring value of pi
   48|       |
   49|      4|    std::complex<double> om = std::complex<double>(
   50|      4|        cos(2 * pi / n), sin(2 * pi / n));  /// Calculating value of omega
   51|       |
   52|      4|    auto *pe = new std::complex<double>[n / 2];  /// Coefficients of even power
   53|       |
   54|      4|    auto *po = new std::complex<double>[n / 2];  /// Coefficients of odd power
   55|       |
   56|      4|    int k1 = 0, k2 = 0;
   57|     14|    for (int j = 0; j < n; j++) {
   58|     10|        if (j % 2 == 0) {
   59|      5|            pe[k1++] = p[j];  /// Assigning values of even Coefficients
   60|       |
   61|      5|        } else {
   62|      5|            po[k2++] = p[j];  /// Assigning value of odd Coefficients
   63|      5|        }
   64|     10|    }
   65|       |
   66|      4|    std::complex<double> *ye =
   67|      4|        FastFourierTransform(pe, n / 2);  /// Recursive Call
   68|       |
   69|      4|    std::complex<double> *yo =
   70|      4|        FastFourierTransform(po, n / 2);  /// Recursive Call
   71|       |
   72|      4|    auto *y = new std::complex<double>[n];  /// Final value representation list
   73|       |
   74|      4|    k1 = 0, k2 = 0;
   75|       |
   76|      9|    for (int i = 0; i < n / 2; i++) {
   77|      5|        y[i] =
   78|      5|            ye[k1] + pow(om, i) * yo[k2];  /// Updating the first n/2 elements
   79|      5|        y[i + n / 2] =
   80|      5|            ye[k1] - pow(om, i) * yo[k2];  /// Updating the last n/2 elements
   81|       |
   82|      5|        k1++;
   83|      5|        k2++;
   84|      5|    }
   85|       |
   86|      4|    if (n != 2) {
   87|      1|        delete[] pe;
   88|      1|        delete[] po;
   89|      1|    }
   90|       |
   91|      4|    delete[] ye;  /// Deleting dynamic array ye
   92|      4|    delete[] yo;  /// Deleting dynamic array yo
   93|      4|    return y;
   94|     10|}
   95|       |
   96|       |}  // namespace numerical_methods
   97|       |
   98|       |/**
   99|       | * @brief Self-test implementations
  100|       | * @details
  101|       | * Declaring two test cases and checking for the error
  102|       | * in predicted and true value is less than 0.000000000001.
  103|       | * @returns void
  104|       | */
  105|      1|static void test() {
  106|       |    /* descriptions of the following test */
  107|       |
  108|      1|    auto *t1 = new std::complex<double>[2];  /// Test case 1
  109|      1|    auto *t2 = new std::complex<double>[4];  /// Test case 2
  110|       |
  111|      1|    t1[0] = {1, 0};
  112|      1|    t1[1] = {2, 0};
  113|      1|    t2[0] = {1, 0};
  114|      1|    t2[1] = {2, 0};
  115|      1|    t2[2] = {3, 0};
  116|      1|    t2[3] = {4, 0};
  117|       |
  118|      1|    uint8_t n1 = 2;
  119|      1|    uint8_t n2 = 4;
  120|      1|    std::vector<std::complex<double>> r1 = {
  121|      1|        {3, 0}, {-1, 0}};  /// True Answer for test case 1
  122|       |
  123|      1|    std::vector<std::complex<double>> r2 = {
  124|      1|        {10, 0}, {-2, -2}, {-2, 0}, {-2, 2}};  /// True Answer for test case 2
  125|       |
  126|      1|    std::complex<double> *o1 = numerical_methods::FastFourierTransform(t1, n1);
  127|      1|    std::complex<double> *t3 =
  128|      1|        o1;  /// Temporary variable used to delete memory location of o1
  129|      1|    std::complex<double> *o2 = numerical_methods::FastFourierTransform(t2, n2);
  130|      1|    std::complex<double> *t4 =
  131|      1|        o2;  /// Temporary variable used to delete memory location of o2
  132|      3|    for (uint8_t i = 0; i < n1; i++) {
  133|      2|        assert((r1[i].real() - o1->real() < 0.000000000001) &&
  134|      2|               (r1[i].imag() - o1->imag() <
  135|      2|                0.000000000001));  /// Comparing for both real and imaginary
  136|       |                                   /// values for test case 1
  137|      0|        o1++;
  138|      2|    }
  139|       |
  140|      5|    for (uint8_t i = 0; i < n2; i++) {
  141|      4|        assert((r2[i].real() - o2->real() < 0.000000000001) &&
  142|      4|               (r2[i].imag() - o2->imag() <
  143|      4|                0.000000000001));  /// Comparing for both real and imaginary
  144|       |                                   /// values for test case 2
  145|      0|        o2++;
  146|      4|    }
  147|       |
  148|      1|    delete[] t1;
  149|      1|    delete[] t2;
  150|      1|    delete[] t3;
  151|      1|    delete[] t4;
  152|      1|    std::cout << "All tests have successfully passed!\n";
  153|      1|}
  154|       |
  155|       |/**
  156|       | * @brief Main function
  157|       | * @param argc commandline argument count (ignored)
  158|       | * @param argv commandline array of arguments (ignored)
  159|       | * calls automated test function to test the working of fast fourier transform.
  160|       | * @returns 0 on exit
  161|       | */
  162|       |
  163|      1|int main(int argc, char const *argv[]) {
  164|      1|    test();  //  run self-test implementations
  165|       |             //  with 2 defined test cases
  166|      1|    return 0;
  167|      1|}

