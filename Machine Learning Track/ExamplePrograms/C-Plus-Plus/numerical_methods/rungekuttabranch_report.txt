    1|       |/**
    2|       | * @{
    3|       | * \file
    4|       | * \brief [Runge Kutta fourth
    5|       | * order](https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods) method
    6|       | * implementation
    7|       | *
    8|       | * \author [Rudra Prasad Das](http://github.com/rudra697)
    9|       | *
   10|       | * \details
   11|       | * It solves the unknown value of y
   12|       | * for a given value of x
   13|       | * only first order differential equations
   14|       | * can be solved
   15|       | * \example
   16|       | * it solves \frac{\mathrm{d} y}{\mathrm{d} x}= \frac{\left ( x-y \right )}{2}
   17|       | * given x for given initial
   18|       | * conditions
   19|       | * There can be many such equations
   20|       | */
   21|       |#include <cassert>   /// asserting the test functions
   22|       |#include <cstdint>
   23|       |#include <iostream>  /// for io operations
   24|       |#include <vector>    /// for using the vector container
   25|       |/**
   26|       | * @brief The change() function is used
   27|       | * to return the updated iterative value corresponding
   28|       | * to the given function
   29|       | * @param x is the value corresponding to the x coordinate
   30|       | * @param y is the value corresponding to the y coordinate
   31|       | * @returns the computed function value at that call
   32|       | */
   33|    400|static double change(double x, double y) { return ((x - y) / 2.0); }
   34|       |
   35|       |/**
   36|       | * @namespace numerical_methods
   37|       | * @brief Numerical Methods
   38|       | */
   39|       |namespace numerical_methods {
   40|       |/**
   41|       | * @namespace runge_kutta
   42|       | * @brief Functions for [Runge Kutta fourth
   43|       | * order](https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods) method
   44|       | */
   45|       |namespace runge_kutta {
   46|       |/**
   47|       | * @brief the Runge Kutta method finds the value of integration of a function in
   48|       | * the given limits. the lower limit of integration as the initial value and the
   49|       | * upper limit is the given x
   50|       | * @param init_x is the value of initial x and is updated after each call
   51|       | * @param init_y is the value of initial x and is updated after each call
   52|       | * @param x is current iteration at which the function needs to be evaluated
   53|       | * @param h is the step value
   54|       | * @returns the value of y at thr required value of x from the initial
   55|       | * conditions
   56|       | */
   57|       |double rungeKutta(double init_x, const double &init_y, const double &x,
   58|      3|                  const double &h) {
   59|       |    // Count number of iterations
   60|       |    // using step size or
   61|       |    // step height h
   62|       |
   63|       |    // n calucates the number of iterations
   64|       |    // k1, k2, k3, k4 are the Runge Kutta variables
   65|       |    // used for calculation of y at each iteration
   66|       |
   67|      3|    auto n = static_cast<uint64_t>((x - init_x) / h);
   68|       |    // used a vector container for the variables
   69|      3|    std::vector<double> k(4, 0.0);
   70|       |
   71|       |    // Iterate for number of iterations
   72|       |
   73|      3|    double y = init_y;
   74|    103|    for (int i = 1; i <= n; ++i) {
   75|       |        // Apply Runge Kutta Formulas
   76|       |        // to find next value of y
   77|    100|        k[0] = h * change(init_x, y);
   78|    100|        k[1] = h * change(init_x + 0.5 * h, y + 0.5 * k[0]);
   79|    100|        k[2] = h * change(init_x + 0.5 * h, y + 0.5 * k[1]);
   80|    100|        k[3] = h * change(init_x + h, y + k[2]);
   81|       |
   82|       |        // Update next value of y
   83|       |
   84|    100|        y += (1.0 / 6.0) * (k[0] + 2 * k[1] + 2 * k[2] + k[3]);
   85|       |
   86|       |        // Update next value of x
   87|       |
   88|    100|        init_x += h;
   89|    100|    }
   90|       |
   91|      3|    return y;
   92|      3|}
   93|       |}  // namespace runge_kutta
   94|       |}  // namespace numerical_methods
   95|       |
   96|       |/**
   97|       | * @brief Tests to check algorithm implementation.
   98|       | * @returns void
   99|       | */
  100|      1|static void test() {
  101|      1|    std::cout << "The Runge Kutta function will be tested on the basis of "
  102|      1|                 "precomputed values\n";
  103|       |
  104|      1|    std::cout << "Test 1...."
  105|      1|              << "\n";
  106|      1|    double valfirst = numerical_methods::runge_kutta::rungeKutta(
  107|      1|        2, 3, 4, 0.2);  // Tests the function with pre calculated values
  108|      1|    assert(valfirst == 3.10363932323749570);
  109|      0|    std::cout << "Passed Test 1\n";
  110|       |
  111|      1|    std::cout << "Test 2...."
  112|      1|              << "\n";
  113|      1|    double valsec = numerical_methods::runge_kutta::rungeKutta(
  114|      1|        1, 2, 5, 0.1);  // The value of step changed
  115|      1|    assert(valsec == 3.40600589380261409);
  116|      0|    std::cout << "Passed Test 2\n";
  117|       |
  118|      1|    std::cout << "Test 3...."
  119|      1|              << "\n";
  120|      1|    double valthird = numerical_methods::runge_kutta::rungeKutta(
  121|      1|        -1, 3, 4, 0.1);  // Tested with negative value
  122|      1|    assert(valthird == 2.49251005860244268);
  123|      0|    std::cout << "Passed Test 3\n";
  124|      1|}
  125|       |
  126|       |/**
  127|       | * @brief Main function
  128|       | * @returns 0 on exit
  129|       | */
  130|      1|int main() {
  131|      1|    test();  // Execute the tests
  132|      1|    return 0;
  133|      1|}

