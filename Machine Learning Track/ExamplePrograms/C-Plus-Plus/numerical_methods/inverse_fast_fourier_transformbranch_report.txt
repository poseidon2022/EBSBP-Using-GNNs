    1|       |/**
    2|       | * @file
    3|       | * @brief [An inverse fast Fourier transform
    4|       | * (IFFT)](https://www.geeksforgeeks.org/python-inverse-fast-fourier-transformation/)
    5|       | * is an algorithm that computes the inverse fourier transform.
    6|       | * @details
    7|       | * This algorithm has an application in use case scenario where a user wants
    8|       | * find coefficients of a function in a short time by just using points
    9|       | * generated by DFT. Time complexity this algorithm computes the IDFT in
   10|       | * O(nlogn) time in comparison to traditional O(n^2).
   11|       | * @author [Ameya Chawla](https://github.com/ameyachawlaggsipu)
   12|       | */
   13|       |
   14|       |#include <cassert>   /// for assert
   15|       |#include <cmath>     /// for mathematical-related functions
   16|       |#include <complex>   /// for storing points and coefficents
   17|       |#include <cstdint>
   18|       |#include <iostream>  /// for IO operations
   19|       |#include <vector>    /// for std::vector
   20|       |
   21|       |/**
   22|       | * @namespace numerical_methods
   23|       | * @brief Numerical algorithms/methods
   24|       | */
   25|       |namespace numerical_methods {
   26|       |/**
   27|       | * @brief InverseFastFourierTransform is a recursive function which returns list
   28|       | * of complex numbers
   29|       | * @param p List of Coefficents in form of complex numbers
   30|       | * @param n Count of elements in list p
   31|       | * @returns p if n==1
   32|       | * @returns y if n!=1
   33|       | */
   34|       |std::complex<double> *InverseFastFourierTransform(std::complex<double> *p,
   35|     10|                                                  uint8_t n) {
   36|     10|    if (n == 1) {
   37|      6|        return p;  /// Base Case To return
   38|      6|    }
   39|       |
   40|      4|    double pi = 2 * asin(1.0);  /// Declaring value of pi
   41|       |
   42|      4|    std::complex<double> om = std::complex<double>(
   43|      4|        cos(2 * pi / n), sin(2 * pi / n));  /// Calculating value of omega
   44|       |
   45|      4|    om.real(om.real() / n);  /// One change in comparison with DFT
   46|      4|    om.imag(om.imag() / n);  /// One change in comparison with DFT
   47|       |
   48|      4|    auto *pe = new std::complex<double>[n / 2];  /// Coefficients of even power
   49|       |
   50|      4|    auto *po = new std::complex<double>[n / 2];  /// Coefficients of odd power
   51|       |
   52|      4|    int k1 = 0, k2 = 0;
   53|     14|    for (int j = 0; j < n; j++) {
   54|     10|        if (j % 2 == 0) {
   55|      5|            pe[k1++] = p[j];  /// Assigning values of even Coefficients
   56|       |
   57|      5|        } else {
   58|      5|            po[k2++] = p[j];  /// Assigning value of odd Coefficients
   59|      5|        }
   60|     10|    }
   61|       |
   62|      4|    std::complex<double> *ye =
   63|      4|        InverseFastFourierTransform(pe, n / 2);  /// Recursive Call
   64|       |
   65|      4|    std::complex<double> *yo =
   66|      4|        InverseFastFourierTransform(po, n / 2);  /// Recursive Call
   67|       |
   68|      4|    auto *y = new std::complex<double>[n];  /// Final value representation list
   69|       |
   70|      4|    k1 = 0, k2 = 0;
   71|       |
   72|      9|    for (int i = 0; i < n / 2; i++) {
   73|      5|        y[i] =
   74|      5|            ye[k1] + pow(om, i) * yo[k2];  /// Updating the first n/2 elements
   75|      5|        y[i + n / 2] =
   76|      5|            ye[k1] - pow(om, i) * yo[k2];  /// Updating the last n/2 elements
   77|       |
   78|      5|        k1++;
   79|      5|        k2++;
   80|      5|    }
   81|       |
   82|      4|    if (n != 2) {
   83|      1|        delete[] pe;
   84|      1|        delete[] po;
   85|      1|    }
   86|       |
   87|      4|    delete[] ye;  /// Deleting dynamic array ye
   88|      4|    delete[] yo;  /// Deleting dynamic array yo
   89|      4|    return y;
   90|     10|}
   91|       |
   92|       |}  // namespace numerical_methods
   93|       |
   94|       |/**
   95|       | * @brief Self-test implementations
   96|       | * @details
   97|       | * Declaring two test cases and checking for the error
   98|       | * in predicted and true value is less than 0.000000000001.
   99|       | * @returns void
  100|       | */
  101|      1|static void test() {
  102|       |    /* descriptions of the following test */
  103|       |
  104|      1|    auto *t1 = new std::complex<double>[2];  /// Test case 1
  105|      1|    auto *t2 = new std::complex<double>[4];  /// Test case 2
  106|       |
  107|      1|    t1[0] = {3, 0};
  108|      1|    t1[1] = {-1, 0};
  109|      1|    t2[0] = {10, 0};
  110|      1|    t2[1] = {-2, -2};
  111|      1|    t2[2] = {-2, 0};
  112|      1|    t2[3] = {-2, 2};
  113|       |
  114|      1|    uint8_t n1 = 2;
  115|      1|    uint8_t n2 = 4;
  116|      1|    std::vector<std::complex<double>> r1 = {
  117|      1|        {1, 0}, {2, 0}};  /// True Answer for test case 1
  118|       |
  119|      1|    std::vector<std::complex<double>> r2 = {
  120|      1|        {1, 0}, {2, 0}, {3, 0}, {4, 0}};  /// True Answer for test case 2
  121|       |
  122|      1|    std::complex<double> *o1 =
  123|      1|        numerical_methods::InverseFastFourierTransform(t1, n1);
  124|       |
  125|      1|    std::complex<double> *o2 =
  126|      1|        numerical_methods::InverseFastFourierTransform(t2, n2);
  127|       |
  128|      3|    for (uint8_t i = 0; i < n1; i++) {
  129|      2|        assert((r1[i].real() - o1[i].real() < 0.000000000001) &&
  130|      2|               (r1[i].imag() - o1[i].imag() <
  131|      2|                0.000000000001));  /// Comparing for both real and imaginary
  132|       |                                   /// values for test case 1
  133|      2|    }
  134|       |
  135|      5|    for (uint8_t i = 0; i < n2; i++) {
  136|      4|        assert((r2[i].real() - o2[i].real() < 0.000000000001) &&
  137|      4|               (r2[i].imag() - o2[i].imag() <
  138|      4|                0.000000000001));  /// Comparing for both real and imaginary
  139|       |                                   /// values for test case 2
  140|      4|    }
  141|       |
  142|      1|    delete[] t1;
  143|      1|    delete[] t2;
  144|      1|    delete[] o1;
  145|      1|    delete[] o2;
  146|      1|    std::cout << "All tests have successfully passed!\n";
  147|      1|}
  148|       |
  149|       |/**
  150|       | * @brief Main function
  151|       | * @param argc commandline argument count (ignored)
  152|       | * @param argv commandline array of arguments (ignored)
  153|       | * calls automated test function to test the working of fast fourier transform.
  154|       | * @returns 0 on exit
  155|       | */
  156|       |
  157|      1|int main(int argc, char const *argv[]) {
  158|      1|    test();  //  run self-test implementations
  159|       |             //  with 2 defined test cases
  160|      1|    return 0;
  161|      1|}

