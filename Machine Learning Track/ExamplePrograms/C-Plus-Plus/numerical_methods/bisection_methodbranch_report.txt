    1|       |/**
    2|       | * \file
    3|       | * \brief Solve the equation \f$f(x)=0\f$ using [bisection
    4|       | * method](https://en.wikipedia.org/wiki/Bisection_method)
    5|       | *
    6|       | * Given two points \f$a\f$ and \f$b\f$ such that \f$f(a)<0\f$ and
    7|       | * \f$f(b)>0\f$, then the \f$(i+1)^\text{th}\f$ approximation is given by: \f[
    8|       | * x_{i+1} = \frac{a_i+b_i}{2}
    9|       | * \f]
   10|       | * For the next iteration, the interval is selected
   11|       | * as: \f$[a,x]\f$ if \f$x>0\f$ or \f$[x,b]\f$ if \f$x<0\f$. The Process is
   12|       | * continued till a close enough approximation is achieved.
   13|       | *
   14|       | * \see newton_raphson_method.cpp, false_position.cpp, secant_method.cpp
   15|       | */
   16|       |#include <cmath>
   17|       |#include <iostream>
   18|       |#include <limits>
   19|       |
   20|       |#define EPSILON \
   21|     26|    1e-6  // std::numeric_limits<double>::epsilon()  ///< system accuracy limit
   22|     29|#define MAX_ITERATIONS 50000  ///< Maximum number of iterations to check
   23|       |
   24|       |/** define \f$f(x)\f$ to find root for
   25|       | */
   26|     32|static double eq(double i) {
   27|     32|    return (std::pow(i, 3) - (4 * i) - 9);  // original equation
   28|     32|}
   29|       |
   30|       |/** get the sign of any given number */
   31|       |template <typename T>
   32|      6|int sgn(T val) {
   33|      6|    return (T(0) < val) - (val < T(0));
   34|      6|}
   35|       |
   36|       |/** main function */
   37|      1|int main() {
   38|      1|    double a = -1, b = 1, x, z;
   39|      1|    int i;
   40|       |
   41|       |    // loop to find initial intervals a, b
   42|      3|    for (int i = 0; i < MAX_ITERATIONS; i++) {
   43|      3|        z = eq(a);
   44|      3|        x = eq(b);
   45|      3|        if (sgn(z) == sgn(x)) {  // same signs, increase interval
   46|      2|            b++;
   47|      2|            a--;
   48|      2|        } else {  // if opposite signs, we got our interval
   49|      1|            break;
   50|      1|        }
   51|      3|    }
   52|       |
   53|      1|    std::cout << "\nFirst initial: " << a;
   54|      1|    std::cout << "\nSecond initial: " << b;
   55|       |
   56|       |    // start iterations
   57|     26|    for (i = 0; i < MAX_ITERATIONS; i++) {
   58|     26|        x = (a + b) / 2;
   59|     26|        z = eq(x);
   60|     26|        std::cout << "\n\nz: " << z << "\t[" << a << " , " << b
   61|     26|                  << " | Bisect: " << x << "]";
   62|       |
   63|     26|        if (z < 0) {
   64|     13|            a = x;
   65|     13|        } else {
   66|     13|            b = x;
   67|     13|        }
   68|       |
   69|     26|        if (std::abs(z) < EPSILON)  // stoping criteria
   70|      1|            break;
   71|     26|    }
   72|       |
   73|      1|    std::cout << "\n\nRoot: " << x << "\t\tSteps: " << i << std::endl;
   74|      1|    return 0;
   75|      1|}

