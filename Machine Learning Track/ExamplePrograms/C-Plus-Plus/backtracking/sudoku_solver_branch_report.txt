    1|       |/**
    2|       | * @file
    3|       | * @brief [Sudoku Solver](https://en.wikipedia.org/wiki/Sudoku) algorithm.
    4|       | *
    5|       | * @details
    6|       | * Sudoku (数独, sūdoku, digit-single) (/suːˈdoʊkuː/, /-ˈdɒk-/, /sə-/,
    7|       | * originally called Number Place) is a logic-based, combinatorial
    8|       | * number-placement puzzle. In classic sudoku, the objective is to fill a 9×9
    9|       | * grid with digits so that each column, each row, and each of the nine 3×3
   10|       | * subgrids that compose the grid (also called "boxes", "blocks", or "regions")
   11|       | * contain all of the digits from 1 to 9. The puzzle setter provides a
   12|       | * partially completed grid, which for a well-posed puzzle has a single
   13|       | * solution.
   14|       | *
   15|       | * @author [DarthCoder3200](https://github.com/DarthCoder3200)
   16|       | * @author [David Leal](https://github.com/Panquesito7)
   17|       | */
   18|       |#include <array>     /// for assert
   19|       |#include <iostream>  /// for IO operations
   20|       |
   21|       |/**
   22|       | * @namespace backtracking
   23|       | * @brief Backtracking algorithms
   24|       | */
   25|       |namespace backtracking {
   26|       |/**
   27|       | * @namespace sudoku_solver
   28|       | * @brief Functions for the [Sudoku
   29|       | * Solver](https://en.wikipedia.org/wiki/Sudoku) implementation
   30|       | */
   31|       |namespace sudoku_solver {
   32|       |/**
   33|       | * @brief Check if it's possible to place a number (`no` parameter)
   34|       | * @tparam V number of vertices in the array
   35|       | * @param mat matrix where numbers are saved
   36|       | * @param i current index in rows
   37|       | * @param j current index in columns
   38|       | * @param no number to be added in matrix
   39|       | * @param n number of times loop will run
   40|       | * @returns `true` if 'mat' is different from 'no'
   41|       | * @returns `false` if 'mat' equals to 'no'
   42|       | */
   43|       |template <size_t V>
   44|       |bool isPossible(const std::array<std::array<int, V>, V> &mat, int i, int j,
   45|  37.6k|                int no, int n) {
   46|       |    /// `no` shouldn't be present in either row i or column j
   47|   168k|    for (int x = 0; x < n; x++) {
   48|   163k|        if (mat[x][j] == no || mat[i][x] == no) {
   49|  32.0k|            return false;
   50|  32.0k|        }
   51|   163k|    }
   52|       |
   53|       |    /// `no` shouldn't be present in the 3*3 subgrid
   54|  5.60k|    int sx = (i / 3) * 3;
   55|  5.60k|    int sy = (j / 3) * 3;
   56|       |
   57|  19.8k|    for (int x = sx; x < sx + 3; x++) {
   58|  59.6k|        for (int y = sy; y < sy + 3; y++) {
   59|  45.4k|            if (mat[x][y] == no) {
   60|  1.40k|                return false;
   61|  1.40k|            }
   62|  45.4k|        }
   63|  15.6k|    }
   64|       |
   65|  4.20k|    return true;
   66|  5.60k|}
   67|       |/**
   68|       | * @brief Utility function to print the matrix
   69|       | * @tparam V number of vertices in array
   70|       | * @param mat matrix where numbers are saved
   71|       | * @param starting_mat copy of mat, required by printMat for highlighting the
   72|       | * differences
   73|       | * @param n number of times loop will run
   74|       | * @return void
   75|       | */
   76|       |template <size_t V>
   77|       |void printMat(const std::array<std::array<int, V>, V> &mat,
   78|      2|              const std::array<std::array<int, V>, V> &starting_mat, int n) {
   79|     20|    for (int i = 0; i < n; i++) {
   80|    180|        for (int j = 0; j < n; j++) {
   81|    162|            if (starting_mat[i][j] != mat[i][j]) {
   82|     51|                std::cout << "\033[93m" << mat[i][j] << "\033[0m"
   83|     51|                          << " ";
   84|    111|            } else {
   85|    111|                std::cout << mat[i][j] << " ";
   86|    111|            }
   87|    162|            if ((j + 1) % 3 == 0) {
   88|     54|                std::cout << '\t';
   89|     54|            }
   90|    162|        }
   91|     18|        if ((i + 1) % 3 == 0) {
   92|      6|            std::cout << std::endl;
   93|      6|        }
   94|     18|        std::cout << std::endl;
   95|     18|    }
   96|      2|}
   97|       |
   98|       |/**
   99|       | * @brief Main function to implement the Sudoku algorithm
  100|       | * @tparam V number of vertices in array
  101|       | * @param mat matrix where numbers are saved
  102|       | * @param starting_mat copy of mat, required by printMat for highlighting the
  103|       | * differences
  104|       | * @param i current index in rows
  105|       | * @param j current index in columns
  106|       | * @returns `true` if 'no' was placed
  107|       | * @returns `false` if 'no' was not placed
  108|       | */
  109|       |template <size_t V>
  110|       |bool solveSudoku(std::array<std::array<int, V>, V> &mat,
  111|       |                 const std::array<std::array<int, V>, V> &starting_mat, int i,
  112|  6.87k|                 int j) {
  113|       |    /// Base Case
  114|  6.87k|    if (i == 9) {
  115|       |        /// Solved for 9 rows already
  116|      1|        printMat<V>(mat, starting_mat, 9);
  117|      1|        return true;
  118|      1|    }
  119|       |
  120|       |    /// Crossed the last  Cell in the row
  121|  6.87k|    if (j == 9) {
  122|    451|        return solveSudoku<V>(mat, starting_mat, i + 1, 0);
  123|    451|    }
  124|       |
  125|       |    /// Blue Cell - Skip
  126|  6.42k|    if (mat[i][j] != 0) {
  127|  2.21k|        return solveSudoku<V>(mat, starting_mat, i, j + 1);
  128|  2.21k|    }
  129|       |    /// White Cell
  130|       |    /// Try to place every possible no
  131|  41.8k|    for (int no = 1; no <= 9; no++) {
  132|  37.6k|        if (isPossible<V>(mat, i, j, no, 9)) {
  133|       |            /// Place the 'no' - assuming a solution will exist
  134|  4.20k|            mat[i][j] = no;
  135|  4.20k|            bool solution_found = solveSudoku<V>(mat, starting_mat, i, j + 1);
  136|  4.20k|            if (solution_found) {
  137|     51|                return true;
  138|     51|            }
  139|       |            /// Couldn't find a solution
  140|       |            /// loop will place the next `no`.
  141|  4.20k|        }
  142|  37.6k|    }
  143|       |    /// Solution couldn't be found for any of the numbers provided
  144|  4.15k|    mat[i][j] = 0;
  145|  4.15k|    return false;
  146|  4.20k|}
  147|       |}  // namespace sudoku_solver
  148|       |}  // namespace backtracking
  149|       |
  150|       |/**
  151|       | * @brief Main function
  152|       | * @returns 0 on exit
  153|       | */
  154|      1|int main() {
  155|      1|    const int V = 9;
  156|      1|    std::array<std::array<int, V>, V> mat = {
  157|      1|        std::array<int, V>{5, 3, 0, 0, 7, 0, 0, 0, 0},
  158|      1|        std::array<int, V>{6, 0, 0, 1, 9, 5, 0, 0, 0},
  159|      1|        std::array<int, V>{0, 9, 8, 0, 0, 0, 0, 6, 0},
  160|      1|        std::array<int, V>{8, 0, 0, 0, 6, 0, 0, 0, 3},
  161|      1|        std::array<int, V>{4, 0, 0, 8, 0, 3, 0, 0, 1},
  162|      1|        std::array<int, V>{7, 0, 0, 0, 2, 0, 0, 0, 6},
  163|      1|        std::array<int, V>{0, 6, 0, 0, 0, 0, 2, 8, 0},
  164|      1|        std::array<int, V>{0, 0, 0, 4, 1, 9, 0, 0, 5},
  165|      1|        std::array<int, V>{0, 0, 0, 0, 8, 0, 0, 7, 9}};
  166|       |
  167|      1|    backtracking::sudoku_solver::printMat<V>(mat, mat, 9);
  168|      1|    std::cout << "Solution " << std::endl;
  169|      1|    std::array<std::array<int, V>, V> starting_mat = mat;
  170|      1|    backtracking::sudoku_solver::solveSudoku<V>(mat, starting_mat, 0, 0);
  171|       |
  172|      1|    return 0;
  173|      1|}

