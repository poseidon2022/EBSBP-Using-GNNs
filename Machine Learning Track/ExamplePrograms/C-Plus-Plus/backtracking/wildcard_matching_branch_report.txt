    1|       |/**
    2|       | * @file
    3|       | * @brief Implementation of the [Wildcard
    4|       | * Matching](https://www.geeksforgeeks.org/wildcard-pattern-matching/) problem.
    5|       | * @details
    6|       | * Given a matching string and a pattern, implement wildcard pattern
    7|       | * matching with support for `?` and `*`. `?` matches any single character.
    8|       | * `*` matches any sequence of characters (including the empty sequence).
    9|       | * The matching should cover the entire matching string (not partial). The task
   10|       | * is to determine if the pattern matches with the matching string
   11|       | * @author [Swastika Gupta](https://github.com/Swastyy)
   12|       | */
   13|       |
   14|       |#include <cassert>   /// for assert
   15|       |#include <cstdint>
   16|       |#include <iostream>  /// for IO operations
   17|       |#include <vector>    /// for std::vector
   18|       |
   19|       |/**
   20|       | * @namespace backtracking
   21|       | * @brief Backtracking algorithms
   22|       | */
   23|       |namespace backtracking {
   24|       |/**
   25|       | * @namespace wildcard_matching
   26|       | * @brief Functions for the [Wildcard
   27|       | * Matching](https://www.geeksforgeeks.org/wildcard-pattern-matching/) problem.
   28|       | */
   29|       |namespace wildcard_matching {
   30|       |/**
   31|       | * @brief The main function implements if pattern can be matched with given
   32|       | * string
   33|       | * @param s is the given matching string
   34|       | * @param p is the given pattern
   35|       | * @param pos1 is the starting index
   36|       | * @param pos2 is the last index
   37|       | * @returns 1 if pattern matches with matching string otherwise 0
   38|       | */
   39|       |std::vector<std::vector<int64_t>> dpTable(1000, std::vector<int64_t>(1000, -1));
   40|       |bool wildcard_matching(std::string s, std::string p, uint32_t pos1,
   41|     28|                       uint32_t pos2) {
   42|     28|    uint32_t n = s.length();
   43|     28|    uint32_t m = p.length();
   44|       |    // matching is successfull if both strings are done
   45|     28|    if (pos1 == n && pos2 == m) {
   46|      1|        return true;
   47|      1|    }
   48|       |
   49|       |    // matching is unsuccessfull if pattern is not finished but matching string
   50|       |    // is
   51|     27|    if (pos1 != n && pos2 == m) {
   52|      1|        return false;
   53|      1|    }
   54|       |
   55|       |    // all the remaining characters of patterns must be * inorder to match with
   56|       |    // finished string
   57|     26|    if (pos1 == n && pos2 != m) {
   58|      0|        while (pos2 < m && p[pos2] == '*') {
   59|      0|            pos2++;
   60|      0|        }
   61|       |
   62|      0|        return pos2 == m;
   63|      0|    }
   64|       |
   65|       |    // if already calculted for these positions
   66|     26|    if (dpTable[pos1][pos2] != -1) {
   67|      4|        return dpTable[pos1][pos2];
   68|      4|    }
   69|       |
   70|       |    // if the characters are same just go ahead in both the string
   71|     22|    if (s[pos1] == p[pos2]) {
   72|      7|        return dpTable[pos1][pos2] =
   73|      7|                   wildcard_matching(s, p, pos1 + 1, pos2 + 1);
   74|      7|    }
   75|       |
   76|     15|    else {
   77|       |        // can only single character
   78|     15|        if (p[pos2] == '?') {
   79|      0|            return dpTable[pos1][pos2] =
   80|      0|                       wildcard_matching(s, p, pos1 + 1, pos2 + 1);
   81|      0|        }
   82|       |        // have choice either to match one or more charcters
   83|     15|        else if (p[pos2] == '*') {
   84|     13|            return dpTable[pos1][pos2] =
   85|     13|                       wildcard_matching(s, p, pos1, pos2 + 1) ||
   86|     13|                       wildcard_matching(s, p, pos1 + 1, pos2);
   87|     13|        }
   88|       |        // not possible to match
   89|      2|        else {
   90|      2|            return dpTable[pos1][pos2] = 0;
   91|      2|        }
   92|     15|    }
   93|     22|}
   94|       |
   95|       |}  // namespace wildcard_matching
   96|       |}  // namespace backtracking
   97|       |
   98|       |/**
   99|       | * @brief Self-test implementations
  100|       | * @returns void
  101|       | */
  102|      1|static void test() {
  103|       |    // 1st test
  104|      1|    std::cout << "1st test ";
  105|      1|    std::string matching1 = "baaabab";
  106|      1|    std::string pattern1 = "*****ba*****ab";
  107|      1|    assert(backtracking::wildcard_matching::wildcard_matching(matching1,
  108|      1|                                                              pattern1, 0, 0) ==
  109|      1|           1);  // here the pattern matches with given string
  110|      0|    std::cout << "passed" << std::endl;
  111|       |
  112|       |    // 2nd test
  113|      1|    std::cout << "2nd test ";
  114|      1|    std::string matching2 = "baaabab";
  115|      1|    std::string pattern2 = "ba*****ab";
  116|      1|    assert(backtracking::wildcard_matching::wildcard_matching(matching2,
  117|      1|                                                              pattern2, 0, 0) ==
  118|      1|           1);  // here the pattern matches with given string
  119|      0|    std::cout << "passed" << std::endl;
  120|       |
  121|       |    // 3rd test
  122|      1|    std::cout << "3rd test ";
  123|      1|    std::string matching3 = "baaabab";
  124|      1|    std::string pattern3 = "ba*ab";
  125|      1|    assert(backtracking::wildcard_matching::wildcard_matching(matching3,
  126|      1|                                                              pattern3, 0, 0) ==
  127|      1|           1);  // here the pattern matches with given string
  128|      0|    std::cout << "passed" << std::endl;
  129|       |
  130|       |    // 4th test
  131|      1|    std::cout << "4th test ";
  132|      1|    std::string matching4 = "baaabab";
  133|      1|    std::string pattern4 = "a*ab";
  134|      1|    assert(backtracking::wildcard_matching::wildcard_matching(matching4,
  135|      1|                                                              pattern4, 0, 0) ==
  136|      1|           1);  // here the pattern matches with given string
  137|      0|    std::cout << "passed" << std::endl;
  138|       |
  139|       |    // 5th test
  140|      1|    std::cout << "5th test ";
  141|      1|    std::string matching5 = "baaabab";
  142|      1|    std::string pattern5 = "aa?ab";
  143|      1|    assert(backtracking::wildcard_matching::wildcard_matching(matching5,
  144|      1|                                                              pattern5, 0, 0) ==
  145|      1|           1);  // here the pattern matches with given string
  146|      0|    std::cout << "passed" << std::endl;
  147|      1|}
  148|       |
  149|       |/**
  150|       | * @brief Main function
  151|       | * @returns 0 on exit
  152|       | */
  153|      1|int main() {
  154|      1|    test();  // run self-test implementations
  155|      1|    return 0;
  156|      1|}

