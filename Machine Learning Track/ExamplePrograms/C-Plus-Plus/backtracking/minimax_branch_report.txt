    1|       |/**
    2|       | * @file
    3|       | * @brief returns which is the longest/shortest number
    4|       | * using [minimax](https://en.wikipedia.org/wiki/Minimax) algorithm
    5|       | *
    6|       | * @details
    7|       | * Minimax (sometimes MinMax, MM or saddle point) is a decision rule used in
    8|       | * artificial intelligence, decision theory, game theory, statistics,
    9|       | * and philosophy for minimizing the possible loss for a worst case (maximum
   10|       | * loss) scenario. When dealing with gains, it is referred to as "maximin"â€”to
   11|       | * maximize the minimum gain. Originally formulated for two-player zero-sum game
   12|       | * theory, covering both the cases where players take alternate moves and those
   13|       | * where they make simultaneous moves, it has also been extended to more complex
   14|       | * games and to general decision-making in the presence of uncertainty.
   15|       | *
   16|       | * @author [Gleison Batista](https://github.com/gleisonbs)
   17|       | * @author [David Leal](https://github.com/Panquesito7)
   18|       | */
   19|       |#include <algorithm>  /// for std::max, std::min
   20|       |#include <array>      /// for std::array
   21|       |#include <cmath>      /// for log2
   22|       |#include <iostream>   /// for IO operations
   23|       |
   24|       |/**
   25|       | * @namespace backtracking
   26|       | * @brief Backtracking algorithms
   27|       | */
   28|       |namespace backtracking {
   29|       |/**
   30|       | * @brief Check which is the maximum/minimum number in the array
   31|       | * @param depth current depth in game tree
   32|       | * @param node_index current index in array
   33|       | * @param is_max if current index is the longest number
   34|       | * @param scores saved numbers in array
   35|       | * @param height maximum height for game tree
   36|       | * @returns the maximum or minimum number
   37|       | */
   38|       |template <size_t T>
   39|       |int minimax(int depth, int node_index, bool is_max,
   40|     15|            const std::array<int, T> &scores, double height) {
   41|     15|    if (depth == height) {
   42|      8|        return scores[node_index];
   43|      8|    }
   44|       |
   45|      7|    int v1 = minimax(depth + 1, node_index * 2, !is_max, scores, height);
   46|      7|    int v2 = minimax(depth + 1, node_index * 2 + 1, !is_max, scores, height);
   47|       |
   48|      7|    return is_max ? std::max(v1, v2) : std::min(v1, v2);
   49|     15|}
   50|       |}  // namespace backtracking
   51|       |
   52|       |/**
   53|       | * @brief Main function
   54|       | * @returns 0 on exit
   55|       | */
   56|      1|int main() {
   57|      1|    std::array<int, 8> scores = {90, 23, 6, 33, 21, 65, 123, 34423};
   58|      1|    double height = log2(scores.size());
   59|       |
   60|      1|    std::cout << "Optimal value: "
   61|      1|              << backtracking::minimax(0, 0, true, scores, height) << std::endl;
   62|      1|    return 0;
   63|      1|}

