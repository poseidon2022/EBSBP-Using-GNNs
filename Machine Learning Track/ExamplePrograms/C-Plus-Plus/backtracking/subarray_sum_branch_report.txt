    1|       |/**
    2|       | * @file
    3|       | * @brief [Subset-sum](https://en.wikipedia.org/wiki/Subset_sum_problem) (only
    4|       | * continuous subsets) problem
    5|       | * @details We are given an array and a sum value. The algorithms find all
    6|       | * the subarrays of that array with sum equal to the given sum and return such
    7|       | * subarrays count. This approach will have \f$O(n)\f$ time complexity and
    8|       | * \f$O(n)\f$ space complexity. NOTE: In this problem, we are only referring to
    9|       | * the continuous subsets as subarrays everywhere. Subarrays can be created
   10|       | * using deletion operation at the end of the front of an array only. The parent
   11|       | * array is also counted in subarrays having 0 number of deletion operations.
   12|       | *
   13|       | * @author [Swastika Gupta](https://github.com/Swastyy)
   14|       | */
   15|       |
   16|       |#include <cassert>        /// for assert
   17|       |#include <cstdint>
   18|       |#include <iostream>       /// for IO operations
   19|       |#include <unordered_map>  /// for unordered_map
   20|       |#include <vector>         /// for std::vector
   21|       |
   22|       |/**
   23|       | * @namespace backtracking
   24|       | * @brief Backtracking algorithms
   25|       | */
   26|       |namespace backtracking {
   27|       |/**
   28|       | * @namespace subarray_sum
   29|       | * @brief Functions for the [Subset
   30|       | * sum](https://en.wikipedia.org/wiki/Subset_sum_problem) implementation
   31|       | */
   32|       |namespace subarray_sum {
   33|       |/**
   34|       | * @brief The main function that implements the count of the subarrays
   35|       | * @param sum is the required sum of any subarrays
   36|       | * @param in_arr is the input array
   37|       | * @returns count of the number of subsets with required sum
   38|       | */
   39|      5|uint64_t subarray_sum(int64_t sum, const std::vector<int64_t> &in_arr) {
   40|      5|    int64_t nelement = in_arr.size();
   41|      5|    int64_t count_of_subset = 0;
   42|      5|    int64_t current_sum = 0;
   43|      5|    std::unordered_map<int64_t, int64_t>
   44|      5|        sumarray;  // to store the subarrays count
   45|       |                   // frequency having some sum value
   46|       |
   47|     22|    for (int64_t i = 0; i < nelement; i++) {
   48|     17|        current_sum += in_arr[i];
   49|       |
   50|     17|        if (current_sum == sum) {
   51|      3|            count_of_subset++;
   52|      3|        }
   53|       |        // If in case current_sum is greater than the required sum
   54|     17|        if (sumarray.find(current_sum - sum) != sumarray.end()) {
   55|      7|            count_of_subset += (sumarray[current_sum - sum]);
   56|      7|        }
   57|     17|        sumarray[current_sum]++;
   58|     17|    }
   59|      5|    return count_of_subset;
   60|      5|}
   61|       |}  // namespace subarray_sum
   62|       |}  // namespace backtracking
   63|       |
   64|       |/**
   65|       | * @brief Self-test implementations
   66|       | * @returns void
   67|       | */
   68|      1|static void test() {
   69|       |    // 1st test
   70|      1|    std::cout << "1st test ";
   71|      1|    std::vector<int64_t> array1 = {-7, -3, -2, 5, 8};  // input array
   72|      1|    assert(
   73|      1|        backtracking::subarray_sum::subarray_sum(0, array1) ==
   74|      1|        1);  // first argument in subarray_sum function is the required sum and
   75|       |             // second is the input array, answer is the subarray {(-3,-2,5)}
   76|      0|    std::cout << "passed" << std::endl;
   77|       |
   78|       |    // 2nd test
   79|      1|    std::cout << "2nd test ";
   80|      1|    std::vector<int64_t> array2 = {1, 2, 3, 3};
   81|      1|    assert(backtracking::subarray_sum::subarray_sum(6, array2) ==
   82|      1|           2);  // here we are expecting 2 subsets which sum up to 6 i.e.
   83|       |                // {(1,2,3),(3,3)}
   84|      0|    std::cout << "passed" << std::endl;
   85|       |
   86|       |    // 3rd test
   87|      1|    std::cout << "3rd test ";
   88|      1|    std::vector<int64_t> array3 = {1, 1, 1, 1};
   89|      1|    assert(backtracking::subarray_sum::subarray_sum(1, array3) ==
   90|      1|           4);  // here we are expecting 4 subsets which sum up to 1 i.e.
   91|       |                // {(1),(1),(1),(1)}
   92|      0|    std::cout << "passed" << std::endl;
   93|       |
   94|       |    // 4rd test
   95|      1|    std::cout << "4th test ";
   96|      1|    std::vector<int64_t> array4 = {3, 3, 3, 3};
   97|      1|    assert(backtracking::subarray_sum::subarray_sum(6, array4) ==
   98|      1|           3);  // here we are expecting 3 subsets which sum up to 6 i.e.
   99|       |                // {(3,3),(3,3),(3,3)}
  100|      0|    std::cout << "passed" << std::endl;
  101|       |
  102|       |    // 5th test
  103|      1|    std::cout << "5th test ";
  104|      1|    std::vector<int64_t> array5 = {};
  105|      1|    assert(backtracking::subarray_sum::subarray_sum(6, array5) ==
  106|      1|           0);  // here we are expecting 0 subsets which sum up to 6 i.e. we
  107|       |                // cannot select anything from an empty array
  108|      0|    std::cout << "passed" << std::endl;
  109|      1|}
  110|       |
  111|       |/**
  112|       | * @brief Main function
  113|       | * @returns 0 on exit
  114|       | */
  115|      1|int main() {
  116|      1|    test();  // run self-test implementations
  117|      1|    return 0;
  118|      1|}

