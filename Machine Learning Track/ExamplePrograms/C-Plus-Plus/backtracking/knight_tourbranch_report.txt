    1|       |/**
    2|       | * @file
    3|       | * @brief [Knight's tour](https://en.wikipedia.org/wiki/Knight%27s_tour)
    4|       | * algorithm
    5|       | *
    6|       | * @details
    7|       | * A knight's tour is a sequence of moves of a knight on a chessboard
    8|       | * such that the knight visits every square only once. If the knight
    9|       | * ends on a square that is one knight's move from the beginning
   10|       | * square (so that it could tour the board again immediately, following
   11|       | * the same path, the tour is closed; otherwise, it is open.
   12|       | *
   13|       | * @author [Nikhil Arora](https://github.com/nikhilarora068)
   14|       | * @author [David Leal](https://github.com/Panquesito7)
   15|       | */
   16|       |#include <array>     /// for std::array
   17|       |#include <iostream>  /// for IO operations
   18|       |
   19|       |/**
   20|       | * @namespace backtracking
   21|       | * @brief Backtracking algorithms
   22|       | */
   23|       |namespace backtracking {
   24|       |/**
   25|       | * @namespace knight_tour
   26|       | * @brief Functions for the [Knight's
   27|       | * tour](https://en.wikipedia.org/wiki/Knight%27s_tour) algorithm
   28|       | */
   29|       |namespace knight_tour {
   30|       |/**
   31|       | * A utility function to check if i,j are valid indexes for N*N chessboard
   32|       | * @tparam V number of vertices in array
   33|       | * @param x current index in rows
   34|       | * @param y current index in columns
   35|       | * @param sol matrix where numbers are saved
   36|       | * @returns `true` if ....
   37|       | * @returns `false` if ....
   38|       | */
   39|       |template <size_t V>
   40|  66.0M|bool issafe(int x, int y, const std::array<std::array<int, V>, V> &sol) {
   41|  66.0M|    return (x < V && x >= 0 && y < V && y >= 0 && sol[x][y] == -1);
   42|  66.0M|}
   43|       |
   44|       |/**
   45|       | * Knight's tour algorithm
   46|       | * @tparam V number of vertices in array
   47|       | * @param x current index in rows
   48|       | * @param y current index in columns
   49|       | * @param mov movement to be done
   50|       | * @param sol matrix where numbers are saved
   51|       | * @param xmov next move of knight (x coordinate)
   52|       | * @param ymov next move of knight (y coordinate)
   53|       | * @returns `true` if solution exists
   54|       | * @returns `false` if solution does not exist
   55|       | */
   56|       |template <size_t V>
   57|       |bool solve(int x, int y, int mov, std::array<std::array<int, V>, V> &sol,
   58|  8.25M|           const std::array<int, V> &xmov, std::array<int, V> &ymov) {
   59|  8.25M|    int k = 0, xnext = 0, ynext = 0;
   60|       |
   61|  8.25M|    if (mov == V * V) {
   62|      1|        return true;
   63|      1|    }
   64|       |
   65|  74.2M|    for (k = 0; k < V; k++) {
   66|  66.0M|        xnext = x + xmov[k];
   67|  66.0M|        ynext = y + ymov[k];
   68|       |
   69|  66.0M|        if (issafe<V>(xnext, ynext, sol)) {
   70|  8.25M|            sol[xnext][ynext] = mov;
   71|       |
   72|  8.25M|            if (solve<V>(xnext, ynext, mov + 1, sol, xmov, ymov) == true) {
   73|     63|                return true;
   74|  8.25M|            } else {
   75|  8.25M|                sol[xnext][ynext] = -1;
   76|  8.25M|            }
   77|  8.25M|        }
   78|  66.0M|    }
   79|  8.25M|    return false;
   80|  8.25M|}
   81|       |}  // namespace knight_tour
   82|       |}  // namespace backtracking
   83|       |
   84|       |/**
   85|       | * @brief Main function
   86|       | * @returns 0 on exit
   87|       | */
   88|      1|int main() {
   89|      1|    const int n = 8;
   90|      1|    std::array<std::array<int, n>, n> sol = {0};
   91|       |
   92|      1|    int i = 0, j = 0;
   93|      9|    for (i = 0; i < n; i++) {
   94|     72|        for (j = 0; j < n; j++) {
   95|     64|            sol[i][j] = -1;
   96|     64|        }
   97|      8|    }
   98|       |
   99|      1|    std::array<int, n> xmov = {2, 1, -1, -2, -2, -1, 1, 2};
  100|      1|    std::array<int, n> ymov = {1, 2, 2, 1, -1, -2, -2, -1};
  101|       |
  102|      1|    sol[0][0] = 0;
  103|       |
  104|      1|    bool flag = backtracking::knight_tour::solve<n>(0, 0, 1, sol, xmov, ymov);
  105|      1|    if (flag == false) {
  106|      0|        std::cout << "Error: Solution does not exist\n";
  107|      1|    } else {
  108|      9|        for (i = 0; i < n; i++) {
  109|     72|            for (j = 0; j < n; j++) {
  110|     64|                std::cout << sol[i][j] << "  ";
  111|     64|            }
  112|      8|            std::cout << "\n";
  113|      8|        }
  114|      1|    }
  115|      1|    return 0;
  116|      1|}

