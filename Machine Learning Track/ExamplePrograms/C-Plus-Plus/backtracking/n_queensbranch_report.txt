    1|       |/**
    2|       | * @file
    3|       | * @brief [Eight Queens](https://en.wikipedia.org/wiki/Eight_queens_puzzle)
    4|       | * puzzle
    5|       | *
    6|       | * @details
    7|       | * The **eight queens puzzle** is the problem of placing eight chess queens on
    8|       | * an 8×8 chessboard so that no two queens threaten each other; thus, a solution
    9|       | * requires that no two queens share the same row, column, or diagonal. The
   10|       | * eight queens puzzle is an example of the more general **n queens problem** of
   11|       | * placing n non-attacking queens on an n×n chessboard, for which solutions
   12|       | * exist for all natural numbers n with the exception of n = 2 and n = 3.
   13|       | *
   14|       | * @author Unknown author
   15|       | * @author [David Leal](https://github.com/Panquesito7)
   16|       | *
   17|       | */
   18|       |#include <array>
   19|       |#include <iostream>
   20|       |
   21|       |/**
   22|       | * @namespace backtracking
   23|       | * @brief Backtracking algorithms
   24|       | */
   25|       |namespace backtracking {
   26|       |/**
   27|       | * @namespace n_queens
   28|       | * @brief Functions for [Eight
   29|       | * Queens](https://en.wikipedia.org/wiki/Eight_queens_puzzle) puzzle.
   30|       | */
   31|       |namespace n_queens {
   32|       |/**
   33|       | * Utility function to print matrix
   34|       | * @tparam n number of matrix size
   35|       | * @param board matrix where numbers are saved
   36|       | */
   37|       |template <size_t n>
   38|      2|void printSolution(const std::array<std::array<int, n>, n> &board) {
   39|      2|    std::cout << "\n";
   40|     10|    for (int i = 0; i < n; i++) {
   41|     40|        for (int j = 0; j < n; j++) {
   42|     32|            std::cout << "" << board[i][j] << " ";
   43|     32|        }
   44|      8|        std::cout << "\n";
   45|      8|    }
   46|      2|}
   47|       |
   48|       |/**
   49|       | * Check if a queen can be placed on matrix
   50|       | * @tparam n number of matrix size
   51|       | * @param board matrix where numbers are saved
   52|       | * @param row current index in rows
   53|       | * @param col current index in columns
   54|       | * @returns `true` if queen can be placed on matrix
   55|       | * @returns `false` if queen can't be placed on matrix
   56|       | */
   57|       |template <size_t n>
   58|       |bool isSafe(const std::array<std::array<int, n>, n> &board, const int &row,
   59|     60|            const int &col) {
   60|     60|    int i = 0, j = 0;
   61|       |
   62|       |    // Check this row on left side
   63|    126|    for (i = 0; i < col; i++) {
   64|     94|        if (board[row][i]) {
   65|     28|            return false;
   66|     28|        }
   67|     94|    }
   68|       |
   69|       |    // Check upper diagonal on left side
   70|     83|    for (i = row, j = col; i >= 0 && j >= 0; i--, j--) {
   71|     60|        if (board[i][j]) {
   72|      9|            return false;
   73|      9|        }
   74|     60|    }
   75|       |    // Check lower diagonal on left side
   76|     58|    for (i = row, j = col; j >= 0 && i < n; i++, j--) {
   77|     42|        if (board[i][j]) {
   78|      7|            return false;
   79|      7|        }
   80|     42|    }
   81|     16|    return true;
   82|     23|}
   83|       |
   84|       |/**
   85|       | * Solve n queens problem
   86|       | * @tparam n number of matrix size
   87|       | * @param board matrix where numbers are saved
   88|       | * @param col current index in columns
   89|       | */
   90|       |template <size_t n>
   91|     17|void solveNQ(std::array<std::array<int, n>, n> board, const int &col) {
   92|     17|    if (col >= n) {
   93|      2|        printSolution<n>(board);
   94|      2|        return;
   95|      2|    }
   96|       |
   97|       |    // Consider this column and try placing
   98|       |    // this queen in all rows one by one
   99|     75|    for (int i = 0; i < n; i++) {
  100|       |        // Check if queen can be placed
  101|       |        // on board[i][col]
  102|     60|        if (isSafe<n>(board, i, col)) {
  103|       |            // Place this queen in matrix
  104|     16|            board[i][col] = 1;
  105|       |
  106|       |            // Recursive to place rest of the queens
  107|     16|            solveNQ<n>(board, col + 1);
  108|       |
  109|     16|            board[i][col] = 0;  // backtrack
  110|     16|        }
  111|     60|    }
  112|     15|}
  113|       |}  // namespace n_queens
  114|       |}  // namespace backtracking
  115|       |
  116|       |/**
  117|       | * @brief Main function
  118|       | * @returns 0 on exit
  119|       | */
  120|      1|int main() {
  121|      1|    const int n = 4;
  122|      1|    std::array<std::array<int, n>, n> board = {
  123|      1|        std::array<int, n>({0, 0, 0, 0}), std::array<int, n>({0, 0, 0, 0}),
  124|      1|        std::array<int, n>({0, 0, 0, 0}), std::array<int, n>({0, 0, 0, 0})};
  125|       |
  126|      1|    backtracking::n_queens::solveNQ<n>(board, 0);
  127|      1|    return 0;
  128|      1|}

