    1|       |/*
    2|       | * @brief [Magic sequence](https://www.csplib.org/Problems/prob019/)
    3|       | * implementation
    4|       | *
    5|       | * @details Solve the magic sequence problem with backtracking
    6|       | *
    7|       | * "A magic sequence of length $n$ is a sequence of integers $x_0
    8|       | * \ldots x_{n-1}$ between $0$ and $n-1$, such that for all $i$
    9|       | * in $0$ to $n-1$, the number $i$ occurs exactly $x_i$ times in
   10|       | * the sequence. For instance, $6,2,1,0,0,0,1,0,0,0$ is a magic
   11|       | * sequence since $0$ occurs $6$ times in it, $1$ occurs twice, etc."
   12|       | * Quote taken from the [CSPLib](https://www.csplib.org/Problems/prob019/)
   13|       | * website
   14|       | *
   15|       | * @author [Jxtopher](https://github.com/Jxtopher)
   16|       | */
   17|       |
   18|       |#include <algorithm>  /// for std::count
   19|       |#include <cassert>    /// for assert
   20|       |#include <iostream>   /// for IO operations
   21|       |#include <list>       /// for std::list
   22|       |#include <numeric>    /// for std::accumulate
   23|       |#include <vector>     /// for std::vector
   24|       |
   25|       |/**
   26|       | * @namespace backtracking
   27|       | * @brief Backtracking algorithms
   28|       | */
   29|       |namespace backtracking {
   30|       |/**
   31|       | * @namespace magic_sequence
   32|       | * @brief Functions for the [Magic
   33|       | * sequence](https://www.csplib.org/Problems/prob019/) implementation
   34|       | */
   35|       |namespace magic_sequence {
   36|       |using sequence_t =
   37|       |    std::vector<unsigned int>;  ///< Definition of the sequence type
   38|       |/**
   39|       | * @brief Print the magic sequence
   40|       | * @param s working memory for the sequence
   41|       | */
   42|      8|void print(const sequence_t& s) {
   43|     58|    for (const auto& item : s) std::cout << item << " ";
   44|      8|    std::cout << std::endl;
   45|      8|}
   46|       |
   47|       |/**
   48|       | * @brief Check if the sequence is magic
   49|       | * @param s working memory for the sequence
   50|       | * @returns true if it's a magic sequence
   51|       | * @returns false if it's NOT a magic sequence
   52|       | */
   53|   956k|bool is_magic(const sequence_t& s) {
   54|   967k|    for (unsigned int i = 0; i < s.size(); i++) {
   55|   967k|        if (std::count(s.cbegin(), s.cend(), i) != s[i]) {
   56|   956k|            return false;
   57|   956k|        }
   58|   967k|    }
   59|      9|    return true;
   60|   956k|}
   61|       |
   62|       |/**
   63|       | * @brief Sub-solutions filtering
   64|       | * @param s working memory for the sequence
   65|       | * @param depth current depth in tree
   66|       | * @returns true if the sub-solution is valid
   67|       | * @returns false if the sub-solution is NOT valid
   68|       | */
   69|  9.30M|bool filtering(const sequence_t& s, unsigned int depth) {
   70|  9.30M|    return std::accumulate(s.cbegin(), s.cbegin() + depth,
   71|  9.30M|                           static_cast<unsigned int>(0)) <= s.size();
   72|  9.30M|}
   73|       |
   74|       |/**
   75|       | * @brief Solve the Magic Sequence problem
   76|       | * @param s working memory for the sequence
   77|       | * @param ret list of the valid magic sequences
   78|       | * @param depth current depth in the tree
   79|       | */
   80|  1.82M|void solve(sequence_t* s, std::list<sequence_t>* ret, unsigned int depth = 0) {
   81|  1.82M|    if (depth == s->size()) {
   82|   956k|        if (is_magic(*s)) {
   83|      8|            ret->push_back(*s);
   84|      8|        }
   85|   956k|    } else {
   86|  10.1M|        for (unsigned int i = 0; i < s->size(); i++) {
   87|  9.30M|            (*s)[depth] = i;
   88|  9.30M|            if (filtering(*s, depth + 1)) {
   89|  1.82M|                solve(s, ret, depth + 1);
   90|  1.82M|            }
   91|  9.30M|        }
   92|   873k|    }
   93|  1.82M|}
   94|       |
   95|       |}  // namespace magic_sequence
   96|       |}  // namespace backtracking
   97|       |
   98|       |/**
   99|       | * @brief Self-test implementations
  100|       | * @returns void
  101|       | */
  102|      1|static void test() {
  103|       |    // test a valid magic sequence
  104|      1|    backtracking::magic_sequence::sequence_t s_magic = {6, 2, 1, 0, 0,
  105|      1|                                                        0, 1, 0, 0, 0};
  106|      1|    assert(backtracking::magic_sequence::is_magic(s_magic));
  107|       |
  108|       |    // test a non-valid magic sequence
  109|      0|    backtracking::magic_sequence::sequence_t s_not_magic = {5, 2, 1, 0, 0,
  110|      1|                                                            0, 1, 0, 0, 0};
  111|      1|    assert(!backtracking::magic_sequence::is_magic(s_not_magic));
  112|      1|}
  113|       |
  114|       |/**
  115|       | * @brief Main function
  116|       | * @returns 0 on exit
  117|       | */
  118|      1|int main() {
  119|      1|    test();  // run self-test implementations
  120|       |
  121|       |    // solve magic sequences of size 2 to 11 and print the solutions
  122|     11|    for (unsigned int i = 2; i < 12; i++) {
  123|     10|        std::cout << "Solution for n = " << i << std::endl;
  124|       |        // valid magic sequence list
  125|     10|        std::list<backtracking::magic_sequence::sequence_t> list_of_solutions;
  126|       |        // initialization of a sequence
  127|     10|        backtracking::magic_sequence::sequence_t s1(i, i);
  128|       |        // launch of solving the problem
  129|     10|        backtracking::magic_sequence::solve(&s1, &list_of_solutions);
  130|       |        // print solutions
  131|     10|        for (const auto& item : list_of_solutions) {
  132|      8|            backtracking::magic_sequence::print(item);
  133|      8|        }
  134|     10|    }
  135|      1|    return 0;
  136|      1|}

