    1|       |/**
    2|       | * @file
    3|       | * @brief Implementation of FCFS CPU scheduling algorithm
    4|       | * @details
    5|       | * FCFS is a non-preemptive CPU scheduling algorithm in which whichever process
    6|       | * arrives first, gets executed first. If two or more processes arrive
    7|       | * simultaneously, the process with smaller process ID gets executed first.
    8|       | * @link https://bit.ly/3ABNXOC
    9|       | * @author [Pratyush Vatsa](https://github.com/Pratyush219)
   10|       | */
   11|       |
   12|       |#include <algorithm>      /// for sorting
   13|       |#include <cassert>        /// for assert
   14|       |#include <cstdint>
   15|       |#include <cstdlib>        /// random number generation
   16|       |#include <ctime>          /// for time
   17|       |#include <iomanip>        /// for formatting the output
   18|       |#include <iostream>       /// for IO operations
   19|       |#include <queue>          /// for std::priority_queue
   20|       |#include <unordered_set>  /// for std::unordered_set
   21|       |#include <vector>         /// for std::vector
   22|       |
   23|       |using std::cin;
   24|       |using std::cout;
   25|       |using std::endl;
   26|       |using std::get;
   27|       |using std::left;
   28|       |using std::make_tuple;
   29|       |using std::priority_queue;
   30|       |using std::rand;
   31|       |using std::srand;
   32|       |using std::tuple;
   33|       |using std::unordered_set;
   34|       |using std::vector;
   35|       |/**
   36|       | * @brief Comparator function for sorting a vector
   37|       | * @tparam S Data type of Process ID
   38|       | * @tparam T Data type of Arrival time
   39|       | * @tparam E Data type of Burst time
   40|       | * @param t1 First tuple
   41|       | * @param t2 Second tuple
   42|       | * @returns true if t1 and t2 are in the CORRECT order
   43|       | * @returns false if t1 and t2 are in the INCORRECT order
   44|       | */
   45|       |template <typename S, typename T, typename E>
   46|  5.47M|bool sortcol(tuple<S, T, E>& t1, tuple<S, T, E>& t2) {
   47|  5.47M|    if (get<1>(t1) < get<1>(t2)) {
   48|    892|        return true;
   49|  5.47M|    } else if (get<1>(t1) == get<1>(t2) && get<0>(t1) < get<0>(t2)) {
   50|  4.62M|        return true;
   51|  4.62M|    }
   52|   847k|    return false;
   53|  5.47M|}
   54|       |
   55|       |/**
   56|       | * @class Compare
   57|       | * @brief Comparator class for priority queue
   58|       | * @tparam S Data type of Process ID
   59|       | * @tparam T Data type of Arrival time
   60|       | * @tparam E Data type of Burst time
   61|       | */
   62|       |template <typename S, typename T, typename E>
   63|       |class Compare {
   64|       | public:
   65|       |    /**
   66|       |     * @param t1 First tuple
   67|       |     * @param t2 Second tuple
   68|       |     * @brief A comparator function that checks whether to swap the two tuples
   69|       |     * or not.
   70|       |     * @link Refer to
   71|       |     * https://www.geeksforgeeks.org/comparator-class-in-c-with-examples/ for
   72|       |     * detailed description of comparator
   73|       |     * @returns true if the tuples SHOULD be swapped
   74|       |     * @returns false if the tuples SHOULDN'T be swapped
   75|       |     */
   76|       |    bool operator()(tuple<S, T, E, double, double, double>& t1,
   77|  5.19M|                    tuple<S, T, E, double, double, double>& t2) {
   78|       |        // Compare arrival times
   79|  5.19M|        if (get<1>(t2) < get<1>(t1)) {
   80|     20|            return true;
   81|     20|        }
   82|       |        // If arrival times are same, then compare Process IDs
   83|  5.19M|        else if (get<1>(t2) == get<1>(t1)) {
   84|  5.19M|            return get<0>(t2) < get<0>(t1);
   85|  5.19M|        }
   86|    265|        return false;
   87|  5.19M|    }
   88|       |};
   89|       |
   90|       |/**
   91|       | * @class FCFS
   92|       | * @brief Class which implements the FCFS scheduling algorithm
   93|       | * @tparam S Data type of Process ID
   94|       | * @tparam T Data type of Arrival time
   95|       | * @tparam E Data type of Burst time
   96|       | */
   97|       |template <typename S, typename T, typename E>
   98|       |class FCFS {
   99|       |    /**
  100|       |     * Priority queue of schedules(stored as tuples) of processes.
  101|       |     * In each tuple
  102|       |     * 1st element: Process ID
  103|       |     * 2nd element: Arrival Time
  104|       |     * 3rd element: Burst time
  105|       |     * 4th element: Completion time
  106|       |     * 5th element: Turnaround time
  107|       |     * 6th element: Waiting time
  108|       |     */
  109|       |    priority_queue<tuple<S, T, E, double, double, double>,
  110|       |                   vector<tuple<S, T, E, double, double, double>>,
  111|       |                   Compare<S, T, E>>
  112|       |        schedule;
  113|       |
  114|       |    // Stores final status of all the processes after completing the execution.
  115|       |    vector<tuple<S, T, E, double, double, double>> result;
  116|       |
  117|       |    // Stores process IDs. Used for confirming absence of a process while adding
  118|       |    // it.
  119|       |    unordered_set<S> idList;
  120|       |
  121|       | public:
  122|       |    /**
  123|       |     * @brief Adds the process to the ready queue if it isn't already there
  124|       |     * @param id Process ID
  125|       |     * @param arrival Arrival time of the process
  126|       |     * @param burst Burst time of the process
  127|       |     * @returns void
  128|       |     *
  129|       |     */
  130|   578k|    void addProcess(S id, T arrival, E burst) {
  131|       |        // Add if a process with process ID as id is not found in idList.
  132|   578k|        if (idList.find(id) == idList.end()) {
  133|   578k|            tuple<S, T, E, double, double, double> t =
  134|   578k|                make_tuple(id, arrival, burst, 0, 0, 0);
  135|   578k|            schedule.push(t);
  136|   578k|            idList.insert(id);
  137|   578k|        }
  138|   578k|    }
  139|       |
  140|       |    /**
  141|       |     * @brief Algorithm for scheduling CPU processes according to the First Come
  142|       |     * First Serve(FCFS) scheduling algorithm.
  143|       |     *
  144|       |     * @details FCFS is a non-preemptive algorithm in which the process which
  145|       |     * arrives first gets executed first. If two or more processes arrive
  146|       |     * together then the process with smaller process ID runs first (each
  147|       |     * process has a unique proces ID).
  148|       |     *
  149|       |     * I used a min priority queue of tuples to accomplish this task. The
  150|       |     * processes are ordered by their arrival times. If arrival times of some
  151|       |     * processes are equal, then they are ordered by their process ID.
  152|       |     *
  153|       |     * @returns void
  154|       |     */
  155|  1.00k|    vector<tuple<S, T, E, double, double, double>> scheduleForFcfs() {
  156|       |        // Variable to keep track of time elapsed so far
  157|  1.00k|        double timeElapsed = 0;
  158|       |
  159|   579k|        while (!schedule.empty()) {
  160|   578k|            tuple<S, T, E, double, double, double> cur = schedule.top();
  161|       |
  162|       |            // If the current process arrived at time t2, the last process
  163|       |            // completed its execution at time t1, and t2 > t1.
  164|   578k|            if (get<1>(cur) > timeElapsed) {
  165|  1.00k|                timeElapsed += get<1>(cur) - timeElapsed;
  166|  1.00k|            }
  167|       |
  168|       |            // Add Burst time to time elapsed
  169|   578k|            timeElapsed += get<2>(cur);
  170|       |
  171|       |            // Completion time of the current process will be same as time
  172|       |            // elapsed so far
  173|   578k|            get<3>(cur) = timeElapsed;
  174|       |
  175|       |            // Turnaround time = Completion time - Arrival time
  176|   578k|            get<4>(cur) = get<3>(cur) - get<1>(cur);
  177|       |
  178|       |            // Waiting time = Turnaround time - Burst time
  179|   578k|            get<5>(cur) = get<4>(cur) - get<2>(cur);
  180|       |
  181|   578k|            result.push_back(cur);
  182|   578k|            schedule.pop();
  183|   578k|        }
  184|  1.00k|        return result;
  185|  1.00k|    }
  186|       |
  187|       |    /**
  188|       |     * @brief Utility function for printing the status of each process after
  189|       |     * execution
  190|       |     * @returns void
  191|       |     */
  192|       |    void printResult() {
  193|       |        cout << "Status of all the proceses post completion is as follows:"
  194|       |             << endl;
  195|       |
  196|       |        cout << std::setw(17) << left << "Process ID" << std::setw(17) << left
  197|       |             << "Arrival Time" << std::setw(17) << left << "Burst Time"
  198|       |             << std::setw(17) << left << "Completion Time" << std::setw(17)
  199|       |             << left << "Turnaround Time" << std::setw(17) << left
  200|       |             << "Waiting Time" << endl;
  201|       |
  202|       |        for (size_t i{}; i < result.size(); i++) {
  203|       |            cout << std::setprecision(2) << std::fixed << std::setw(17) << left
  204|       |                 << get<0>(result[i]) << std::setw(17) << left
  205|       |                 << get<1>(result[i]) << std::setw(17) << left
  206|       |                 << get<2>(result[i]) << std::setw(17) << left
  207|       |                 << get<3>(result[i]) << std::setw(17) << left
  208|       |                 << get<4>(result[i]) << std::setw(17) << left
  209|       |                 << get<5>(result[i]) << endl;
  210|       |        }
  211|       |    }
  212|       |};
  213|       |
  214|       |/**
  215|       | * @brief Function to be used for testing purposes. This function guarantees the
  216|       | * correct solution for FCFS scheduling algorithm.
  217|       | * @param input the input data
  218|       | * @details Sorts the input vector according to arrival time. Processes whose
  219|       | * arrival times are same get sorted according to process ID For each process,
  220|       | * completion time, turnaround time and completion time are calculated, inserted
  221|       | * in a tuple, which is added to the vector result.
  222|       | * @returns A vector of tuples consisting of process ID, arrival time, burst
  223|       | * time, completion time, turnaround time and waiting time for each process.
  224|       | */
  225|       |template <typename S, typename T, typename E>
  226|       |vector<tuple<S, T, E, double, double, double>> get_final_status(
  227|  1.00k|    vector<tuple<uint32_t, uint32_t, uint32_t>> input) {
  228|  1.00k|    sort(input.begin(), input.end(), sortcol<S, T, E>);
  229|  1.00k|    vector<tuple<S, T, E, double, double, double>> result(input.size());
  230|  1.00k|    double timeElapsed = 0;
  231|   579k|    for (size_t i{}; i < input.size(); i++) {
  232|   578k|        T arrival = get<1>(input[i]);
  233|   578k|        E burst = get<2>(input[i]);
  234|       |
  235|   578k|        if (arrival > timeElapsed) {
  236|  1.00k|            timeElapsed += arrival - timeElapsed;
  237|  1.00k|        }
  238|   578k|        timeElapsed += burst;
  239|   578k|        double completion = timeElapsed;
  240|   578k|        double turnaround = completion - arrival;
  241|   578k|        double waiting = turnaround - burst;
  242|       |
  243|   578k|        get<0>(result[i]) = get<0>(input[i]);
  244|   578k|        get<1>(result[i]) = arrival;
  245|   578k|        get<2>(result[i]) = burst;
  246|   578k|        get<3>(result[i]) = completion;
  247|   578k|        get<4>(result[i]) = turnaround;
  248|   578k|        get<5>(result[i]) = waiting;
  249|   578k|    }
  250|  1.00k|    return result;
  251|  1.00k|}
  252|       |
  253|       |/**
  254|       | * @brief Self-test implementations
  255|       | * @returns void
  256|       | */
  257|      1|static void test() {
  258|  1.00k|    for (int i{}; i < 1000; i++) {
  259|  1.00k|        srand(time(nullptr));
  260|  1.00k|        uint32_t n = 1 + rand() % 1000;
  261|  1.00k|        FCFS<uint32_t, uint32_t, uint32_t> readyQueue;
  262|  1.00k|        vector<tuple<uint32_t, uint32_t, uint32_t>> input(n);
  263|       |
  264|   579k|        for (uint32_t i{}; i < n; i++) {
  265|   578k|            get<0>(input[i]) = i;
  266|   578k|            srand(time(nullptr));
  267|   578k|            get<1>(input[i]) = 1 + rand() % 10000;
  268|   578k|            srand(time(nullptr));
  269|   578k|            get<2>(input[i]) = 1 + rand() % 10000;
  270|   578k|        }
  271|       |
  272|   579k|        for (uint32_t i{}; i < n; i++) {
  273|   578k|            readyQueue.addProcess(get<0>(input[i]), get<1>(input[i]),
  274|   578k|                                  get<2>(input[i]));
  275|   578k|        }
  276|  1.00k|        vector<tuple<uint32_t, uint32_t, uint32_t, double, double, double>>
  277|  1.00k|            res = get_final_status<uint32_t, uint32_t, uint32_t>(input);
  278|  1.00k|        assert(res == readyQueue.scheduleForFcfs());
  279|       |        // readyQueue.printResult();
  280|  1.00k|    }
  281|      1|    cout << "All the tests have successfully passed!" << endl;
  282|      1|}
  283|       |
  284|       |/**
  285|       | * @brief Entry point of the program
  286|       | * @returns 0 on exit
  287|       | */
  288|      1|int main() {
  289|      1|    test();  // run self-test implementations
  290|      1|    return 0;
  291|      1|}

