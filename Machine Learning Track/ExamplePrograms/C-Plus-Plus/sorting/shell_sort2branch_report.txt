    1|       |/**
    2|       | * \file
    3|       | * \brief [Shell sort](https://en.wikipedia.org/wiki/Shell_sort) algorithm
    4|       | * \author [Krishna Vedala](https://github.com/kvedala)
    5|       | */
    6|       |#include <cassert>
    7|       |#include <cstdlib>
    8|       |#include <ctime>
    9|       |#include <iostream>
   10|       |#include <utility>  // for std::swap
   11|       |#include <vector>
   12|       |
   13|       |/** pretty print array
   14|       | * \param[in] arr array to print
   15|       | * \param[in] LEN length of array to print
   16|       | */
   17|       |template <class T>
   18|      2|void show_data(T *arr, size_t LEN) {
   19|      2|    size_t i;
   20|       |
   21|    402|    for (i = 0; i < LEN; i++) {
   22|    400|        std::cout << arr[i] << ", ";
   23|    400|    }
   24|      2|    std::cout << std::endl;
   25|      2|}
   26|       |
   27|       |/** pretty print array
   28|       | * \param[in] arr array to print
   29|       | * \param[in] N length of array to print
   30|       | */
   31|       |template <typename T, size_t N>
   32|       |void show_data(T (&arr)[N]) {
   33|       |    show_data(arr, N);
   34|       |}
   35|       |
   36|       |/** \namespace sorting
   37|       | * \brief Sorting algorithms
   38|       | */
   39|       |namespace sorting {
   40|       |/**
   41|       | * Optimized algorithm - takes half the time by utilizing
   42|       | * Mar
   43|       | **/
   44|       |template <typename T>
   45|      7|void shell_sort(T *arr, size_t LEN) {
   46|      7|    const unsigned int gaps[] = {701, 301, 132, 57, 23, 10, 4, 1};
   47|      7|    const unsigned int gap_len = 8;
   48|      7|    size_t i, j, g;
   49|       |
   50|     63|    for (g = 0; g < gap_len; g++) {
   51|     56|        unsigned int gap = gaps[g];
   52|   172k|        for (i = gap; i < LEN; i++) {
   53|   172k|            T tmp = arr[i];
   54|       |
   55|   421k|            for (j = i; j >= gap && (arr[j - gap] - tmp) > 0; j -= gap) {
   56|   248k|                arr[j] = arr[j - gap];
   57|   248k|            }
   58|       |
   59|   172k|            arr[j] = tmp;
   60|   172k|        }
   61|     56|    }
   62|      7|}
  ------------------
  | _ZN7sorting10shell_sortIiEEvPT_m:
  |   45|      4|void shell_sort(T *arr, size_t LEN) {
  |   46|      4|    const unsigned int gaps[] = {701, 301, 132, 57, 23, 10, 4, 1};
  |   47|      4|    const unsigned int gap_len = 8;
  |   48|      4|    size_t i, j, g;
  |   49|       |
  |   50|     36|    for (g = 0; g < gap_len; g++) {
  |   51|     32|        unsigned int gap = gaps[g];
  |   52|  86.9k|        for (i = gap; i < LEN; i++) {
  |   53|  86.9k|            T tmp = arr[i];
  |   54|       |
  |   55|   216k|            for (j = i; j >= gap && (arr[j - gap] - tmp) > 0; j -= gap) {
  |   56|   129k|                arr[j] = arr[j - gap];
  |   57|   129k|            }
  |   58|       |
  |   59|  86.9k|            arr[j] = tmp;
  |   60|  86.9k|        }
  |   61|     32|    }
  |   62|      4|}
  ------------------
  | _ZN7sorting10shell_sortIfEEvPT_m:
  |   45|      3|void shell_sort(T *arr, size_t LEN) {
  |   46|      3|    const unsigned int gaps[] = {701, 301, 132, 57, 23, 10, 4, 1};
  |   47|      3|    const unsigned int gap_len = 8;
  |   48|      3|    size_t i, j, g;
  |   49|       |
  |   50|     27|    for (g = 0; g < gap_len; g++) {
  |   51|     24|        unsigned int gap = gaps[g];
  |   52|  85.9k|        for (i = gap; i < LEN; i++) {
  |   53|  85.9k|            T tmp = arr[i];
  |   54|       |
  |   55|   205k|            for (j = i; j >= gap && (arr[j - gap] - tmp) > 0; j -= gap) {
  |   56|   119k|                arr[j] = arr[j - gap];
  |   57|   119k|            }
  |   58|       |
  |   59|  85.9k|            arr[j] = tmp;
  |   60|  85.9k|        }
  |   61|     24|    }
  |   62|      3|}
  ------------------
   63|       |
   64|       |/** function overload - when input array is of a known length array type
   65|       | */
   66|       |template <typename T, size_t N>
   67|       |void shell_sort(T (&arr)[N]) {
   68|       |    shell_sort(arr, N);
   69|       |}
   70|       |
   71|       |/** function overload - when input array is of type std::vector,
   72|       | * simply send the data content and the data length to the above function.
   73|       | */
   74|       |template <typename T>
   75|       |void shell_sort(std::vector<T> *arr) {
   76|       |    shell_sort(arr->data(), arr->size());
   77|       |}
   78|       |
   79|       |}  // namespace sorting
   80|       |
   81|       |using sorting::shell_sort;
   82|       |
   83|       |/**
   84|       | * function to compare sorting using cstdlib's qsort
   85|       | **/
   86|       |template <typename T>
   87|   259k|int compare(const void *a, const void *b) {
   88|   259k|    T arg1 = *static_cast<const T *>(a);
   89|   259k|    T arg2 = *static_cast<const T *>(b);
   90|       |
   91|   259k|    if (arg1 < arg2)
   92|  94.1k|        return -1;
   93|   165k|    if (arg1 > arg2)
   94|   132k|        return 1;
   95|  33.1k|    return 0;
   96|       |
   97|       |    //  return (arg1 > arg2) - (arg1 < arg2); // possible shortcut
   98|       |    //  return arg1 - arg2; // erroneous shortcut (fails if INT_MIN is present)
   99|   165k|}
  ------------------
  | _Z7compareIiEiPKvS1_:
  |   87|   129k|int compare(const void *a, const void *b) {
  |   88|   129k|    T arg1 = *static_cast<const T *>(a);
  |   89|   129k|    T arg2 = *static_cast<const T *>(b);
  |   90|       |
  |   91|   129k|    if (arg1 < arg2)
  |   92|  49.2k|        return -1;
  |   93|  80.4k|    if (arg1 > arg2)
  |   94|  66.1k|        return 1;
  |   95|  14.3k|    return 0;
  |   96|       |
  |   97|       |    //  return (arg1 > arg2) - (arg1 < arg2); // possible shortcut
  |   98|       |    //  return arg1 - arg2; // erroneous shortcut (fails if INT_MIN is present)
  |   99|  80.4k|}
  ------------------
  | _Z7compareIfEiPKvS1_:
  |   87|   129k|int compare(const void *a, const void *b) {
  |   88|   129k|    T arg1 = *static_cast<const T *>(a);
  |   89|   129k|    T arg2 = *static_cast<const T *>(b);
  |   90|       |
  |   91|   129k|    if (arg1 < arg2)
  |   92|  44.9k|        return -1;
  |   93|  84.7k|    if (arg1 > arg2)
  |   94|  65.9k|        return 1;
  |   95|  18.8k|    return 0;
  |   96|       |
  |   97|       |    //  return (arg1 > arg2) - (arg1 < arg2); // possible shortcut
  |   98|       |    //  return arg1 - arg2; // erroneous shortcut (fails if INT_MIN is present)
  |   99|  84.7k|}
  ------------------
  100|       |
  101|       |/**
  102|       | * Test implementation of shell_sort on integer arrays by comparing results
  103|       | * against std::qsort.
  104|       | */
  105|      3|void test_int(const int NUM_DATA) {
  106|       |    // int array = new int[NUM_DATA];
  107|      3|    int *data = new int[NUM_DATA];
  108|      3|    int *data2 = new int[NUM_DATA];
  109|       |    // int array2 = new int[NUM_DATA];
  110|      3|    int range = 1800;
  111|       |
  112|  11.1k|    for (int i = 0; i < NUM_DATA; i++)
  113|  11.1k|        data[i] = data2[i] = (std::rand() % range) - (range >> 1);
  114|       |
  115|       |    /* sort using our implementation */
  116|      3|    std::clock_t start = std::clock();
  117|      3|    shell_sort(data, NUM_DATA);
  118|      3|    std::clock_t end = std::clock();
  119|      3|    double elapsed_time = static_cast<double>(end - start) / CLOCKS_PER_SEC;
  120|      3|    std::cout << "Time spent sorting using shell_sort2: " << elapsed_time
  121|      3|              << "s\n";
  122|       |
  123|       |    /* sort using std::qsort */
  124|      3|    start = std::clock();
  125|      3|    std::qsort(data2, NUM_DATA, sizeof(data2[0]), compare<int>);
  126|      3|    end = std::clock();
  127|       |
  128|      3|    elapsed_time = static_cast<double>(end - start) / CLOCKS_PER_SEC;
  129|      3|    std::cout << "Time spent sorting using std::qsort: " << elapsed_time
  130|      3|              << "s\n";
  131|       |
  132|  11.1k|    for (int i = 0; i < NUM_DATA; i++) {
  133|  11.1k|        assert(data[i] == data2[i]);  // ensure that our sorting results match
  134|       |                                      // the standard results
  135|  11.1k|    }
  136|       |
  137|      3|    delete[] data;
  138|      3|    delete[] data2;
  139|      3|}
  140|       |
  141|       |/**
  142|       | * Test implementation of shell_sort on float arrays by comparing results
  143|       | * against std::qsort.
  144|       | */
  145|      3|void test_f(const int NUM_DATA) {
  146|       |    // int array = new int[NUM_DATA];
  147|      3|    float *data = new float[NUM_DATA];
  148|      3|    float *data2 = new float[NUM_DATA];
  149|       |    // int array2 = new int[NUM_DATA];
  150|      3|    int range = 1000;
  151|       |
  152|  11.1k|    for (int i = 0; i < NUM_DATA; i++) {
  153|  11.1k|        data[i] = data2[i] = ((std::rand() % range) - (range >> 1)) / 100.;
  154|  11.1k|    }
  155|       |
  156|       |    /* sort using our implementation */
  157|      3|    std::clock_t start = std::clock();
  158|      3|    shell_sort(data, NUM_DATA);
  159|      3|    std::clock_t end = std::clock();
  160|      3|    double elapsed_time = static_cast<double>(end - start) / CLOCKS_PER_SEC;
  161|      3|    std::cout << "Time spent sorting using shell_sort2: " << elapsed_time
  162|      3|              << "s\n";
  163|       |
  164|       |    /* sort using std::qsort */
  165|      3|    start = std::clock();
  166|      3|    std::qsort(data2, NUM_DATA, sizeof(data2[0]), compare<float>);
  167|      3|    end = std::clock();
  168|       |
  169|      3|    elapsed_time = static_cast<double>(end - start) / CLOCKS_PER_SEC;
  170|      3|    std::cout << "Time spent sorting using std::qsort: " << elapsed_time
  171|      3|              << "s\n";
  172|       |
  173|  11.1k|    for (int i = 0; i < NUM_DATA; i++) {
  174|  11.1k|        assert(data[i] == data2[i]);  // ensure that our sorting results match
  175|       |                                      // the standard results
  176|  11.1k|    }
  177|       |
  178|      3|    delete[] data;
  179|      3|    delete[] data2;
  180|      3|}
  181|       |
  182|       |/** Main function */
  183|      1|int main(int argc, char *argv[]) {
  184|       |    // initialize random number generator - once per program
  185|      1|    std::srand(std::time(NULL));
  186|       |
  187|      1|    test_int(100);  // test with sorting random array of 100 values
  188|      1|    std::cout << "Test 1 - 100 int values - passed. \n";
  189|      1|    test_int(1000);  // test with sorting random array of 1000 values
  190|      1|    std::cout << "Test 2 - 1000 int values - passed.\n";
  191|      1|    test_int(10000);  // test with sorting random array of 10000 values
  192|      1|    std::cout << "Test 3 - 10000 int values - passed.\n";
  193|       |
  194|      1|    test_f(100);  // test with sorting random array of 100 values
  195|      1|    std::cout << "Test 1 - 100 float values - passed. \n";
  196|      1|    test_f(1000);  // test with sorting random array of 1000 values
  197|      1|    std::cout << "Test 2 - 1000 float values - passed.\n";
  198|      1|    test_f(10000);  // test with sorting random array of 10000 values
  199|      1|    std::cout << "Test 3 - 10000 float values - passed.\n";
  200|       |
  201|      1|    int i, NUM_DATA;
  202|       |
  203|      1|    if (argc == 2)
  204|      0|        NUM_DATA = atoi(argv[1]);
  205|      1|    else
  206|      1|        NUM_DATA = 200;
  207|       |
  208|       |    // int array = new int[NUM_DATA];
  209|      1|    int *data = new int[NUM_DATA];
  210|       |    // int array2 = new int[NUM_DATA];
  211|      1|    int range = 1800;
  212|       |
  213|      1|    std::srand(time(NULL));
  214|    201|    for (i = 0; i < NUM_DATA; i++) {
  215|       |        // allocate random numbers in the given range
  216|    200|        data[i] = (std::rand() % range) - (range >> 1);
  217|    200|    }
  218|       |
  219|      1|    std::cout << "Unsorted original data: " << std::endl;
  220|      1|    show_data(data, NUM_DATA);
  221|      1|    std::clock_t start = std::clock();
  222|      1|    shell_sort(data, NUM_DATA);  // perform sorting
  223|      1|    std::clock_t end = std::clock();
  224|       |
  225|      1|    std::cout << std::endl
  226|      1|              << "Data Sorted using custom implementation: " << std::endl;
  227|      1|    show_data(data, NUM_DATA);
  228|       |
  229|      1|    double elapsed_time = (end - start) * 1.f / CLOCKS_PER_SEC;
  230|      1|    std::cout << "Time spent sorting: " << elapsed_time << "s\n" << std::endl;
  231|       |
  232|      1|    delete[] data;
  233|      1|    return 0;
  234|      1|}

