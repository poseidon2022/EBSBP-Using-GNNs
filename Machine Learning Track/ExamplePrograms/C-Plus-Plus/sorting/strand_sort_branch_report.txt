    1|       |/**
    2|       | * @file strand_sort.cpp
    3|       | * @brief Implementation of [Strand Sort](https://en.wikipedia.org/wiki/Strand_sort) algorithm.
    4|       | *
    5|       | * @details
    6|       | * Strand Sort is a sorting algorithm that works in \f$O(n)\f$ time if list is already sorted and works in \f$O(n^2)\f$ in worst case.
    7|       | * 
    8|       | * It is passed over the array to be sorted once and the ascending (sequential) numbers are taken.
    9|       | * After the first iteration, the sequential sub-array is put on the empty sorted array.
   10|       | * The main sequence is passed over again and a new sub-sequence is created in order.
   11|       | * Now that the sorted array is not empty, the newly extracted substring is merged with the sorted array.
   12|       | * Repeat types 3 and 4 until the sub-sequence and main sequence are empty.
   13|       | * 
   14|       | * @author [Mertcan Davulcu](https://github.com/mertcandav)
   15|       | */
   16|       |#include <iostream>
   17|       |#include <list>
   18|       |
   19|       |/**
   20|       | * @namespace sorting
   21|       | * @brief Sorting algorithms
   22|       | */
   23|       |namespace sorting {
   24|       |    /**
   25|       |    * @namespace strand
   26|       |    * @brief Functions for [Strand Sort](https://en.wikipedia.org/wiki/Strand_sort) algorithm
   27|       |    */
   28|       |    namespace strand {
   29|       |        /**
   30|       |        * @brief Apply sorting
   31|       |        * @tparam element type of list
   32|       |        * @param lst List to be sorted
   33|       |        * @returns Sorted list<T> instance
   34|       |        */
   35|       |        template <typename T>
   36|      1|        std::list<T> strand_sort(std::list<T> lst) {
   37|      1|            if (lst.size() < 2) { // Returns list if empty or contains only one element
   38|      0|                return lst; // Returns list
   39|      0|            }
   40|      1|            std::list<T> result; // Define new "result" named list instance.
   41|      1|            std::list<T> sorted; // Define new "sorted" named list instance.
   42|      5|            while(!lst.empty()) /* if lst is not empty */ {
   43|      4|                sorted.push_back(lst.front()); // Adds the first element of "lst" list to the bottom of the "sorted" list.
   44|      4|                lst.pop_front(); // Remove first element of "lst" list.
   45|     16|                for (auto it = lst.begin(); it != lst.end(); ) { // Return the loop as long as the current iterator is not equal to the last literator of the "lst" list.
   46|     12|                    if (sorted.back() <= *it) { // If the last reference of the "sorted" list is less than or equal to the current iterator reference.
   47|      3|                        sorted.push_back(*it); // Adds the iterator retrieved in the loop under the "sorted" list.
   48|      3|                        it = lst.erase(it); // Deletes the element with the current iterator and assigns the deleted element to the iterator.
   49|      9|                    } else {
   50|      9|                        it++; // Next iterator.
   51|      9|                    }
   52|     12|                }
   53|      4|                result.merge(sorted); // Merge "result" list with "sorted" list.
   54|      4|            }
   55|      1|            return result; // Returns sorted list
   56|      1|        }
   57|       |    }  // namespace strand
   58|       |}  // namespace sorting
   59|       |
   60|       |/**
   61|       | * @brief Function for testing
   62|       | * @return N/A
   63|       | */
   64|      1|static void test() {
   65|      1|    std::list<int> lst = { -333, 525, 1, 0, 94, 52, 33 };
   66|       |
   67|      1|    std::cout << "Before: ";
   68|      7|    for(auto item: lst) {
   69|      7|        std::cout << item << " ";
   70|      7|    }
   71|       |
   72|      1|    lst = sorting::strand::strand_sort(lst); // Sort list.
   73|       |
   74|      1|    std::cout << "\nAfter: ";
   75|      7|    for(auto item: lst) {
   76|      7|        std::cout << item << " ";
   77|      7|    }
   78|      1|}
   79|       |
   80|       |/**
   81|       | * @brief Main function
   82|       | * @returns 0 on exit
   83|       | */
   84|      1|int main() {
   85|      1|    test();
   86|      1|    return 0;
   87|      1|}

