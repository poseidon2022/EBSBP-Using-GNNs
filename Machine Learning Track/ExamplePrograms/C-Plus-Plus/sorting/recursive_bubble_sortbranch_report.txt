    1|       |/**
    2|       | * @file
    3|       | * @author [Aditya Prakash](https://adityaprakash.tech)
    4|       | * @brief This is an implementation of a recursive version of the [Bubble sort
    5|       | algorithm](https://www.geeksforgeeks.org/recursive-bubble-sort/)
    6|       | *
    7|       | * @details
    8|       | * The working principle of the Bubble sort algorithm.
    9|       |
   10|       | * Bubble sort is a simple sorting algorithm used to rearrange a set of
   11|       | ascending or descending order elements.
   12|       | * Bubble sort gets its name from the fact that data "bubbles" to the top of the
   13|       | dataset.
   14|       |
   15|       | * ### Algorithm
   16|       |
   17|       | * What is Swap?
   18|       |
   19|       | * Swapping two numbers means that we interchange their values.
   20|       | * Often, an additional variable is required for this operation.
   21|       | * This is further illustrated in the following:
   22|       |
   23|       | * void swap(int x, int y){
   24|       | *     int z = x;
   25|       | *     x = y;
   26|       | *     y = z;
   27|       | * }
   28|       |
   29|       | * The above process is a typical displacement process.
   30|       | * When we assign a value to x, the old value of x is lost.
   31|       | * That's why we create a temporary variable z to store the initial value of x.
   32|       | * z is further used to assign the initial value of x to y, to complete
   33|       | swapping.
   34|       |
   35|       | * Recursion
   36|       |
   37|       | * While the recursive method does not necessarily have advantages over
   38|       | iterative
   39|       | * versions, but it is useful to enhance the understanding of the algorithm and
   40|       | * recursion itself. In Recursive Bubble sort algorithm, we firstly call the
   41|       | * function on the entire array, and for every subsequent function call, we
   42|       | exclude
   43|       | * the last element. This fixes the last element for that sub-array.Formally,
   44|       | for
   45|       | * `ith` iteration, we consider elements up to n-i, where n is the number of
   46|       | * elements in the array. Exit condition: n==1; i.e. the sub-array contains only
   47|       | * one element.
   48|       |
   49|       | * Complexity
   50|       | * Time complexity: O(n) best case; O(n²) average case; O(n²) worst case
   51|       | * Space complexity: O(n)
   52|       |
   53|       | * We need to traverse the array `n * (n-1)` times. However, if the entire array
   54|       | is
   55|       | * already sorted, then we need to traverse it only once. Hence, O(n) is the
   56|       | best case
   57|       | * complexity
   58|       |*/
   59|       |
   60|       |#include <algorithm>  /// for std::is_sorted
   61|       |#include <array>      /// for std::array
   62|       |#include <cassert>    /// for assert
   63|       |#include <cstdint>
   64|       |#include <iostream>   /// for IO operations
   65|       |#include <vector>     /// for std::vector
   66|       |
   67|       |/**
   68|       | * @namespace sorting
   69|       | * @brief Sorting algorithms
   70|       | */
   71|       |namespace sorting {
   72|       |
   73|       |/**
   74|       | * @brief This is an implementation of the recursive_bubble_sort. A vector is
   75|       | * passed to the function which is then dereferenced, so that the changes are
   76|       | * reflected in the original vector. It also accepts a second parameter of
   77|       | * type `int` and name `n`, which is the size of the array.
   78|       | *
   79|       | * @tparam T type of data variables in the array
   80|       | * @param nums our array of elements.
   81|       | * @param n size of the array
   82|       | */
   83|       |template <typename T>
   84|     12|void recursive_bubble_sort(std::vector<T> *nums, uint64_t n) {
   85|     12|    if (n == 1) {  //!< base case; when size of the array is 1
   86|      2|        return;
   87|      2|    }
   88|       |
   89|     40|    for (uint64_t i = 0; i < n - 1; i++) {  //!< iterating over the entire array
   90|       |        //!< if a larger number appears before the smaller one, swap them.
   91|     30|        if ((*nums)[i] > (*nums)[i + 1]) {
   92|     11|            std::swap((*nums)[i], (*nums)[i + 1]);
   93|     11|        }
   94|     30|    }
   95|       |
   96|       |    //!< calling the function after we have fixed the last element
   97|     10|    recursive_bubble_sort(nums, n - 1);
   98|     10|}
  ------------------
  | _ZN7sorting21recursive_bubble_sortIlEEvPSt6vectorIT_SaIS2_EEm:
  |   84|      6|void recursive_bubble_sort(std::vector<T> *nums, uint64_t n) {
  |   85|      6|    if (n == 1) {  //!< base case; when size of the array is 1
  |   86|      1|        return;
  |   87|      1|    }
  |   88|       |
  |   89|     20|    for (uint64_t i = 0; i < n - 1; i++) {  //!< iterating over the entire array
  |   90|       |        //!< if a larger number appears before the smaller one, swap them.
  |   91|     15|        if ((*nums)[i] > (*nums)[i + 1]) {
  |   92|      6|            std::swap((*nums)[i], (*nums)[i + 1]);
  |   93|      6|        }
  |   94|     15|    }
  |   95|       |
  |   96|       |    //!< calling the function after we have fixed the last element
  |   97|      5|    recursive_bubble_sort(nums, n - 1);
  |   98|      5|}
  ------------------
  | _ZN7sorting21recursive_bubble_sortIdEEvPSt6vectorIT_SaIS2_EEm:
  |   84|      6|void recursive_bubble_sort(std::vector<T> *nums, uint64_t n) {
  |   85|      6|    if (n == 1) {  //!< base case; when size of the array is 1
  |   86|      1|        return;
  |   87|      1|    }
  |   88|       |
  |   89|     20|    for (uint64_t i = 0; i < n - 1; i++) {  //!< iterating over the entire array
  |   90|       |        //!< if a larger number appears before the smaller one, swap them.
  |   91|     15|        if ((*nums)[i] > (*nums)[i + 1]) {
  |   92|      5|            std::swap((*nums)[i], (*nums)[i + 1]);
  |   93|      5|        }
  |   94|     15|    }
  |   95|       |
  |   96|       |    //!< calling the function after we have fixed the last element
  |   97|      5|    recursive_bubble_sort(nums, n - 1);
  |   98|      5|}
  ------------------
   99|       |}  // namespace sorting
  100|       |
  101|       |/**
  102|       | * @brief Self-test implementations
  103|       | * @returns void
  104|       | */
  105|      1|static void test() {
  106|       |    // 1st example. Creating an array of type `int`.
  107|      1|    std::cout << "1st test using `int`\n";
  108|      1|    const uint64_t size = 6;
  109|      1|    std::vector<int64_t> arr;
  110|       |    // populating the array
  111|      1|    arr.push_back(22);
  112|      1|    arr.push_back(46);
  113|      1|    arr.push_back(94);
  114|      1|    arr.push_back(12);
  115|      1|    arr.push_back(37);
  116|      1|    arr.push_back(63);
  117|       |    // array populating ends
  118|       |
  119|      1|    sorting::recursive_bubble_sort(&arr, size);
  120|      1|    assert(std::is_sorted(std::begin(arr), std::end(arr)));
  121|      0|    std::cout << " 1st test passed!\n";
  122|       |    // printing the array
  123|      7|    for (uint64_t i = 0; i < size; i++) {
  124|      6|        std::cout << arr[i] << ", ";
  125|      6|    }
  126|      1|    std::cout << std::endl;
  127|       |
  128|       |    // 2nd example. Creating an array of type `double`.
  129|      1|    std::cout << "2nd test using doubles\n";
  130|      1|    std::vector<double> double_arr;
  131|       |
  132|       |    // populating the array
  133|      1|    double_arr.push_back(20.4);
  134|      1|    double_arr.push_back(62.7);
  135|      1|    double_arr.push_back(12.2);
  136|      1|    double_arr.push_back(43.6);
  137|      1|    double_arr.push_back(74.1);
  138|      1|    double_arr.push_back(57.9);
  139|       |    // array populating ends
  140|       |
  141|      1|    sorting::recursive_bubble_sort(&double_arr, size);
  142|      1|    assert(std::is_sorted(std::begin(double_arr), std::end(double_arr)));
  143|      0|    std::cout << " 2nd test passed!\n";
  144|       |    // printing the array
  145|      7|    for (uint64_t i = 0; i < size; i++) {
  146|      6|        std::cout << double_arr[i] << ", ";
  147|      6|    }
  148|      1|    std::cout << std::endl;
  149|      1|}
  150|       |
  151|       |/**
  152|       | * @brief Main function
  153|       | * @returns 0 on exit
  154|       | */
  155|      1|int main() {
  156|      1|    test();  // run self-test implementations
  157|      1|    return 0;
  158|      1|}

