    1|       |/**
    2|       | * @file
    3|       | * @author [@sinkyoungdeok](https://github.com/sinkyoungdeok)
    4|       | * @author [Krishna Vedala](https://github.com/kvedala)
    5|       | * @brief Algorithm that combines insertion sort and merge sort. [Wiki
    6|       | * link](https://en.wikipedia.org/wiki/Merge-insertion_sort)
    7|       | *
    8|       | * @see Individual algorithms: insertion_sort.cpp and merge_sort.cpp
    9|       | */
   10|       |#include <algorithm>
   11|       |#include <array>
   12|       |#include <cassert>
   13|       |#include <ctime>
   14|       |#include <iostream>
   15|       |#include <memory>
   16|       |
   17|       |/** \namespace sorting
   18|       | * \brief Sorting algorithms
   19|       | */
   20|       |namespace sorting {
   21|       |/** \namespace merge_insertion
   22|       | * \brief Combined Intersion-Merge sorting algorithm
   23|       | */
   24|       |namespace merge_insertion {
   25|       |
   26|       |/**
   27|       | * @brief Insertion merge algorithm
   28|       | * @see insertion_sort.cpp
   29|       | *
   30|       | * @tparam T array data type
   31|       | * @tparam N length of array
   32|       | * @param A pointer to array to sort
   33|       | * @param start start index of sorting window
   34|       | * @param end end index of sorting window
   35|       | */
   36|       |template <typename T, size_t N>
   37|      1|static void InsertionSort(std::array<T, N> *A, size_t start, size_t end) {
   38|      1|    size_t i = 0, j = 0;
   39|      1|    T *ptr = A->data();
   40|       |
   41|     31|    for (i = start; i < end; i++) {
   42|     30|        T temp = ptr[i];
   43|     30|        j = i;
   44|    218|        while (j > start && temp < ptr[j - 1]) {
   45|    188|            ptr[j] = ptr[j - 1];
   46|    188|            j--;
   47|    188|        }
   48|       |        //   for (j = i; j > start && temp < ptr[j - 1]; --j) {
   49|       |        //       ptr[j] = ptr[j - 1];
   50|       |        //   }
   51|       |
   52|     30|        ptr[j] = temp;
   53|     30|    }
   54|      1|}
   55|       |
   56|       |/**
   57|       | * @brief Perform merge of data in a window
   58|       | *
   59|       | * @tparam T array data type
   60|       | * @tparam N length of array
   61|       | * @param A pointer to array to sort
   62|       | * @param min start index of window
   63|       | * @param max end index of window
   64|       | * @param mid mid-point of window
   65|       | */
   66|       |template <typename T, size_t N>
   67|       |static void merge(std::array<T, N> *array, size_t min, size_t max, size_t mid) {
   68|       |    size_t firstIndex = min;
   69|       |    size_t secondIndex = mid + 1;
   70|       |
   71|       |    auto ptr = array->data();
   72|       |    std::array<T, N + 1> tempArray{0};
   73|       |
   74|       |    // While there are elements in the left or right runs
   75|       |    for (size_t index = min; index <= max; index++) {
   76|       |        // If left run head exists and is <= existing right run head.
   77|       |        if (firstIndex <= mid &&
   78|       |            (secondIndex > max || ptr[firstIndex] <= ptr[secondIndex])) {
   79|       |            tempArray[index] = ptr[firstIndex];
   80|       |            firstIndex++;
   81|       |        } else {
   82|       |            tempArray[index] = ptr[secondIndex];
   83|       |            secondIndex++;
   84|       |        }
   85|       |    }
   86|       |
   87|       |    // transfer to the initial array
   88|       |    memcpy(ptr + min, tempArray.data() + min, (max - min) * sizeof(T));
   89|       |    //  for (int index = min; index <= max; index++) ptr[index] =
   90|       |    //  tempArray[index];
   91|       |}
   92|       |
   93|       |/**
   94|       | * @brief Final combined algorithm.
   95|       | * Algorithm utilizes ::sorting::merge_insertion::InsertionSort if window length
   96|       | * is less than threshold, else performs merge sort recursively using
   97|       | * ::sorting::merge_insertion::mergeSort
   98|       | *
   99|       | * @tparam T array data type
  100|       | * @tparam N length of array
  101|       | * @param A pointer to array to sort
  102|       | * @param min start index of sort window
  103|       | * @param max end index of sort window
  104|       | * @param threshold window length threshold
  105|       | */
  106|       |template <typename T, size_t N>
  107|       |void mergeSort(std::array<T, N> *array, size_t min, size_t max,
  108|       |               size_t threshold) {
  109|       |    // prerequisite
  110|       |    if ((max - min) <= threshold) {
  111|       |        InsertionSort(array, min, max);
  112|       |    } else {
  113|       |        // get the middle point
  114|       |        size_t mid = (max + min) >> 1;
  115|       |
  116|       |        // apply merge sort to both parts of this
  117|       |        mergeSort(array, min, mid, threshold);
  118|       |        mergeSort(array, mid, max, threshold);
  119|       |
  120|       |        // and finally merge all that sorted stuff
  121|       |        merge(array, min, max, mid);
  122|       |    }
  123|       |}
  124|       |
  125|       |}  // namespace merge_insertion
  126|       |}  // namespace sorting
  127|       |
  128|       |/**
  129|       | * @brief Function to test code using random arrays
  130|       | * @returns none
  131|       | */
  132|      1|static void test() {
  133|      1|    constexpr size_t size = 30;
  134|      1|    std::array<int, size> array{0};
  135|       |    // input
  136|     31|    for (int i = 0; i < size; i++) {
  137|     30|        array[i] = std::rand() % 100 - 50;
  138|     30|        std::cout << array[i] << " ";
  139|     30|    }
  140|      1|    std::cout << std::endl;
  141|       |
  142|      1|    sorting::merge_insertion::InsertionSort(&array, 0, size);
  143|       |    //  sorting::merge_insertion::mergeSort(&array, 0, size, 10);
  144|       |
  145|       |    // output
  146|     31|    for (int i = 0; i < size; ++i) {
  147|     30|        std::cout << array[i] << " ";
  148|     30|    }
  149|      1|    std::cout << std::endl;
  150|       |
  151|      1|    assert(std::is_sorted(std::begin(array), std::end(array)));
  152|      0|    std::cout << "Test passed\n";
  153|      1|}
  154|       |
  155|       |/**
  156|       | * @brief Main function
  157|       | * @return 0 on exit
  158|       | */
  159|      1|int main() {
  160|      1|    std::srand(std::time(nullptr));
  161|      1|    test();
  162|      1|    return 0;
  163|      1|}

