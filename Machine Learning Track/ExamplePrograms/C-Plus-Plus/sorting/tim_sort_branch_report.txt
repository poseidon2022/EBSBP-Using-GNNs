    1|       |// C++ program to perform TimSort.
    2|       |#include <algorithm>
    3|       |#include <cassert>
    4|       |#include <iostream>
    5|       |#include <numeric>
    6|       |
    7|       |const int RUN = 32;
    8|       |
    9|       |// this function sorts array from left index to to right index which is of size
   10|       |// atmost RUN
   11|      4|void insertionSort(int arr[], int left, int right) {
   12|     70|    for (int i = left + 1; i <= right; i++) {
   13|     66|        const int temp = arr[i];
   14|     66|        int j = i - 1;
   15|  1.06k|        while (j >= left && arr[j] > temp) {
   16|    995|            arr[j + 1] = arr[j];
   17|    995|            j--;
   18|    995|        }
   19|     66|        arr[j + 1] = temp;
   20|     66|    }
   21|      4|}
   22|       |
   23|       |// merge function merges the sorted runs
   24|      3|void merge(int arr[], int l, int m, int r) {
   25|       |    // original array is broken in two parts, left and right array
   26|      3|    const int len1 = m - l + 1, len2 = r - m;
   27|      3|    int *left = new int[len1], *right = new int[len2];
   28|    100|    for (int i = 0; i < len1; i++) left[i] = arr[l + i];
   29|     36|    for (int i = 0; i < len2; i++) right[i] = arr[m + 1 + i];
   30|       |
   31|      3|    int i = 0;
   32|      3|    int j = 0;
   33|      3|    int k = l;
   34|       |
   35|       |    // after comparing, we merge those two array in larger sub array
   36|     36|    while (i < len1 && j < len2) {
   37|     33|        if (left[i] <= right[j]) {
   38|      0|            arr[k] = left[i];
   39|      0|            i++;
   40|     33|        } else {
   41|     33|            arr[k] = right[j];
   42|     33|            j++;
   43|     33|        }
   44|     33|        k++;
   45|     33|    }
   46|       |
   47|       |    // copy remaining elements of left, if any
   48|    100|    while (i < len1) {
   49|     97|        arr[k] = left[i];
   50|     97|        k++;
   51|     97|        i++;
   52|     97|    }
   53|       |
   54|       |    // copy remaining element of right, if any
   55|      3|    while (j < len2) {
   56|      0|        arr[k] = right[j];
   57|      0|        k++;
   58|      0|        j++;
   59|      0|    }
   60|      3|    delete[] left;
   61|      3|    delete[] right;
   62|      3|}
   63|       |
   64|       |// iterative Timsort function to sort the array[0...n-1] (similar to merge sort)
   65|      2|void timSort(int arr[], int n) {
   66|       |    // Sort individual subarrays of size RUN
   67|      6|    for (int i = 0; i < n; i += RUN)
   68|      4|        insertionSort(arr, i, std::min((i + 31), (n - 1)));
   69|       |
   70|       |    // start merging from size RUN (or 32). It will merge to form size 64, then
   71|       |    // 128, 256 and so on ....
   72|      4|    for (int size = RUN; size < n; size = 2 * size) {
   73|       |        // pick starting point of left sub array. We are going to merge
   74|       |        // arr[left..left+size-1] and arr[left+size, left+2*size-1] After every
   75|       |        // merge, we increase left by 2*size
   76|      5|        for (int left = 0; left < n; left += 2 * size) {
   77|       |            // find ending point of left sub array
   78|       |            // mid+1 is starting point of right sub array
   79|      3|            const int mid = std::min((left + size - 1), (n - 1));
   80|      3|            const int right = std::min((left + 2 * size - 1), (n - 1));
   81|       |
   82|       |            // merge sub array arr[left.....mid] & arr[mid+1....right]
   83|      3|            merge(arr, left, mid, right);
   84|      3|        }
   85|      2|    }
   86|      2|}
   87|       |
   88|       |// utility function to print the Array
   89|      2|void printArray(int arr[], int n) {
   90|     12|    for (int i = 0; i < n; i++) printf("%d  ", arr[i]);
   91|      2|    std::cout << std::endl;
   92|      2|}
   93|       |
   94|       |/**
   95|       | * @brief self-test implementation
   96|       | * @returns void
   97|       | */
   98|      1|void tests() {
   99|       |    // Case: array of length 65
  100|      1|    constexpr int N = 65;
  101|      1|    int arr[N];
  102|       |
  103|      1|    std::iota(arr, arr + N, 0);
  104|      1|    std::reverse(arr, arr + N);
  105|      1|    assert(!std::is_sorted(arr, arr + N));
  106|       |
  107|      0|    timSort(arr, N);
  108|      1|    assert(std::is_sorted(arr, arr + N));
  109|      1|}
  110|       |
  111|       |// Driver program to test above function
  112|      1|int main() {
  113|      1|    tests();  // run self test implementations
  114|       |
  115|      1|    int arr[] = {5, 21, 7, 23, 19};
  116|      1|    const int n = sizeof(arr) / sizeof(arr[0]);
  117|      1|    printf("Given Array is\n");
  118|      1|    printArray(arr, n);
  119|       |
  120|      1|    timSort(arr, n);
  121|       |
  122|      1|    printf("After Sorting Array is\n");
  123|      1|    printArray(arr, n);
  124|      1|    return 0;
  125|      1|}

