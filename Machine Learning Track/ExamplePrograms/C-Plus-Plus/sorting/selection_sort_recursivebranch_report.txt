    1|       |/**
    2|       | * @file
    3|       | * @brief Implementation of the [Selection
    4|       | * sort](https://en.wikipedia.org/wiki/Selection_sort)
    5|       | * implementation using recursion
    6|       | * @details
    7|       | * The selection sort algorithm divides the input list into two parts: a sorted
    8|       | * sublist of items which is built up from left to right at the front (left) of
    9|       | * the list, and a sublist of the remaining unsorted items that occupy the rest
   10|       | * of the list. Initially, the sorted sublist is empty, and the unsorted sublist
   11|       | * is the entire input list. The algorithm proceeds by finding the smallest (or
   12|       | * largest, depending on the sorting order) element in the unsorted sublist,
   13|       | * exchanging (swapping) it with the leftmost unsorted element (putting it in
   14|       | * sorted order), and moving the sublist boundaries one element to the right.
   15|       | *
   16|       | * ### Implementation
   17|       | * FindMinIndex
   18|       | * This function finds the minimum element of the array(list) recursively by
   19|       | * simply comparing the minimum element of array reduced size by 1 and compares
   20|       | * it to the last element of the array to find the minimum of the whole array.
   21|       | *
   22|       | * SelectionSortRecursive
   23|       | * Just like selection sort, it divides the list into two parts (i.e.: sorted
   24|       | * and unsorted) and finds the minimum of the unsorted array. By calling the
   25|       | * `FindMinIndex` function, it swaps the minimum element with the first element
   26|       | * of the list, and then solves recursively for the remaining unsorted list.
   27|       | * @author [Tushar Khanduri](https://github.com/Tushar-K24)
   28|       | */
   29|       |
   30|       |#include <algorithm>  /// for std::is_sorted
   31|       |#include <cassert>  /// for assert
   32|       |#include <cstdint>
   33|       |#include <iostream>  /// for std::swap and io operations
   34|       |#include <vector>    /// for std::vector
   35|       |
   36|       |/**
   37|       | * @namespace sorting
   38|       | * @brief Sorting algorithms
   39|       | */
   40|       |namespace sorting {
   41|       |/**
   42|       | * @namespace selection_sort_recursive
   43|       | * @brief Functions for the [Selection
   44|       | * sort](https://en.wikipedia.org/wiki/Selection_sort)
   45|       | * implementation using recursion
   46|       | */
   47|       |namespace selection_sort_recursive {
   48|       |/**
   49|       | * @brief The main function finds the index of the minimum element
   50|       | * @tparam T type of array
   51|       | * @param in_arr array whose minimum element is to be returned
   52|       | * @param current_position position/index from where the in_arr starts
   53|       | * @returns index of the minimum element
   54|       | */
   55|       |template <typename T>
   56|       |uint64_t findMinIndex(const std::vector<T> &in_arr,
   57|    129|                      uint64_t current_position = 0) {
   58|    129|    if (current_position + 1 == in_arr.size()) {
   59|     29|        return current_position;
   60|     29|    }
   61|    100|    uint64_t answer = findMinIndex(in_arr, current_position + 1);
   62|    100|    if (in_arr[current_position] < in_arr[answer]) {
   63|     14|        answer = current_position;
   64|     14|    }
   65|    100|    return answer;
   66|    129|}
   67|       |
   68|       |/**
   69|       | * @brief The main function implements Selection sort
   70|       | * @tparam T type of array
   71|       | * @param in_arr array to be sorted,
   72|       | * @param current_position position/index from where the in_arr starts
   73|       | * @returns void
   74|       | */
   75|       |template <typename T>
   76|       |void selectionSortRecursive(std::vector<T> &in_arr,
   77|     33|                            uint64_t current_position = 0) {
   78|     33|    if (current_position == in_arr.size()) {
   79|      4|        return;
   80|      4|    }
   81|     29|    uint64_t min_element_idx =
   82|     29|        selection_sort_recursive::findMinIndex(in_arr, current_position);
   83|     29|    if (min_element_idx != current_position) {
   84|     21|        std::swap(in_arr[min_element_idx], in_arr[current_position]);
   85|     21|    }
   86|     29|    selectionSortRecursive(in_arr, current_position + 1);
   87|     29|}
   88|       |}  // namespace selection_sort_recursive
   89|       |}  // namespace sorting
   90|       |
   91|       |/**
   92|       | * @brief Self-test implementations
   93|       | * @returns void
   94|       | */
   95|      1|static void test() {
   96|       |    // 1st test
   97|       |    // [1, 0, 2, 1] return [0, 1, 1, 2]
   98|      1|    std::vector<uint64_t> array1 = {0, 1, 1, 2};
   99|      1|    std::cout << "1st test... ";
  100|      1|    sorting::selection_sort_recursive::selectionSortRecursive(array1);
  101|      1|    assert(std::is_sorted(std::begin(array1), std::end(array1)));
  102|      0|    std::cout << "passed" << std::endl;
  103|       |    // 2nd test
  104|       |    // [1, 0, 0, 1, 1, 0, 2, 1] return [0, 0, 0, 1, 1, 1, 1, 2]
  105|      1|    std::vector<uint64_t> array2 = {1, 0, 0, 1, 1, 0, 2, 1};
  106|      1|    std::cout << "2nd test... ";
  107|      1|    sorting::selection_sort_recursive::selectionSortRecursive(array2);
  108|      1|    assert(std::is_sorted(std::begin(array2), std::end(array2)));
  109|      0|    std::cout << "passed" << std::endl;
  110|       |    // 3rd test
  111|       |    // [1, 1, 0, 0, 1, 2, 2, 0, 2, 1] return [0, 0, 0, 1, 1, 1, 1, 2, 2, 2]
  112|      1|    std::vector<uint64_t> array3 = {1, 1, 0, 0, 1, 2, 2, 0, 2, 1};
  113|      1|    std::cout << "3rd test... ";
  114|      1|    sorting::selection_sort_recursive::selectionSortRecursive(array3);
  115|      1|    assert(std::is_sorted(std::begin(array3), std::end(array3)));
  116|      0|    std::cout << "passed" << std::endl;
  117|       |    // 4th test
  118|       |    // [2, 2, 2, 0, 0, 1, 1] return [0, 0, 1, 1, 2, 2, 2]
  119|      1|    std::vector<uint64_t> array4 = {2, 2, 2, 0, 0, 1, 1};
  120|      1|    std::cout << "4th test... ";
  121|      1|    sorting::selection_sort_recursive::selectionSortRecursive(array4);
  122|      1|    assert(std::is_sorted(std::begin(array4), std::end(array4)));
  123|      0|    std::cout << "passed" << std::endl;
  124|      1|}
  125|       |
  126|       |/**
  127|       | * @brief Main function
  128|       | * @returns 0 on exit
  129|       | */
  130|      1|int main() {
  131|      1|    test();  // run self-test implementations
  132|      1|    return 0;
  133|      1|}

