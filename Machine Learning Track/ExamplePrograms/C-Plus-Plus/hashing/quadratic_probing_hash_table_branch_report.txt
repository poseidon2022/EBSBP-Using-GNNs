    1|       |/**
    2|       | * @file
    3|       | * @author [achance6](https://github.com/achance6)
    4|       | * @author [Krishna Vedala](https://github.com/kvedala)
    5|       | * @brief Storage mechanism using [quadratic probing
    6|       | * hash](https://en.wikipedia.org/wiki/Quadratic_probing) keys.
    7|       | * @note The implementation can be optimized by using OOP style.
    8|       | */
    9|       |#include <cmath>
   10|       |#include <iostream>
   11|       |#include <vector>
   12|       |
   13|       |/**
   14|       | * @addtogroup open_addressing Open Addressing
   15|       | * @{
   16|       | * @namespace quadratic_probing
   17|       | * @brief An implementation of hash table using [quadratic
   18|       | * probing](https://en.wikipedia.org/wiki/Quadratic_probing) algorithm.
   19|       | */
   20|       |namespace quadratic_probing {
   21|       |// fwd declarations
   22|       |using Entry = struct Entry;
   23|       |bool putProber(const Entry& entry, int key);
   24|       |bool searchingProber(const Entry& entry, int key);
   25|       |void add(int key);
   26|       |
   27|       |// globals
   28|       |int notPresent;
   29|       |std::vector<Entry> table;
   30|       |int totalSize;
   31|       |int tomb = -1;
   32|       |int size;
   33|       |bool rehashing;
   34|       |
   35|       |/** Node that holds key
   36|       | */
   37|       |struct Entry {
   38|      0|    explicit Entry(int key = notPresent) : key(key) {}  ///< constructor
   39|       |    int key;                                            ///< key value
   40|       |};
   41|       |
   42|       |/** Hash a key
   43|       | * @param key key value to hash
   44|       | * @returns hash of the key
   45|       | */
   46|      0|size_t hashFxn(int key) {
   47|      0|    std::hash<int> hash;
   48|      0|    return hash(key);
   49|      0|}
   50|       |
   51|       |/** Performs quadratic probing to resolve collisions
   52|       | * @param key key value to search/probe
   53|       | * @param searching `true` if only searching, `false1 if assigning
   54|       | * @returns value of `notPresent`.
   55|       | */
   56|      0|int quadraticProbe(int key, bool searching) {
   57|      0|    int hash = static_cast<int>(hashFxn(key));
   58|      0|    int i = 0;
   59|      0|    Entry entry;
   60|      0|    do {
   61|      0|        size_t index =
   62|      0|            (hash + static_cast<size_t>(std::round(std::pow(i, 2)))) %
   63|      0|            totalSize;
   64|      0|        entry = table[index];
   65|      0|        if (searching) {
   66|      0|            if (entry.key == notPresent) {
   67|      0|                return notPresent;
   68|      0|            }
   69|      0|            if (searchingProber(entry, key)) {
   70|      0|                std::cout << "Found key!" << std::endl;
   71|      0|                return index;
   72|      0|            }
   73|      0|            std::cout << "Found tombstone or equal hash, checking next"
   74|      0|                      << std::endl;
   75|      0|            i++;
   76|      0|        } else {
   77|      0|            if (putProber(entry, key)) {
   78|      0|                if (!rehashing) {
   79|      0|                    std::cout << "Spot found!" << std::endl;
   80|      0|                }
   81|      0|                return index;
   82|      0|            }
   83|      0|            if (!rehashing) {
   84|      0|                std::cout << "Spot taken, looking at next (next index = "
   85|      0|                          << (hash + static_cast<size_t>(
   86|      0|                                         std::round(std::pow(i + 1, 2)))) %
   87|      0|                                 totalSize
   88|      0|                          << std::endl;
   89|      0|            }
   90|      0|            i++;
   91|      0|        }
   92|      0|        if (i == totalSize * 100) {
   93|      0|            std::cout << "Quadratic probe failed (infinite loop)" << std::endl;
   94|      0|            return notPresent;
   95|      0|        }
   96|      0|    } while (entry.key != notPresent);
   97|      0|    return notPresent;
   98|      0|}
   99|       |
  100|       |/** Finds empty spot
  101|       | * @param entry Instance of table entry
  102|       | * @param key key value to search/probe
  103|       | * @returns `true` if key is present
  104|       | * @returns `false` if key is absent
  105|       | */
  106|      0|bool putProber(const Entry& entry, int key) {
  107|      0|    if (entry.key == notPresent || entry.key == tomb) {
  108|      0|        return true;
  109|      0|    }
  110|      0|    return false;
  111|      0|}
  112|       |
  113|       |/** Looks for a matching key
  114|       | * @param entry Instance of table entry
  115|       | * @param key key value to search/probe
  116|       | * @returns `true` if key matches the entry
  117|       | * @returns `false` if key does not match the entry
  118|       | */
  119|      0|bool searchingProber(const Entry& entry, int key) {
  120|      0|    if (entry.key == key) {
  121|      0|        return true;
  122|      0|    }
  123|      0|    return false;
  124|      0|}
  125|       |
  126|       |/** Get the entry instance corresponding to a key
  127|       | * @param key key value to search/probe
  128|       | * @returns if present, the entry instance
  129|       | * @returns if not present, a new instance
  130|       | */
  131|      0|Entry find(int key) {
  132|      0|    int index = quadraticProbe(key, true);
  133|      0|    if (index == notPresent) {
  134|      0|        return Entry();
  135|      0|    }
  136|      0|    return table[index];
  137|      0|}
  138|       |
  139|       |/** Displays the table
  140|       | * @returns None
  141|       | */
  142|      0|void display() {
  143|      0|    for (int i = 0; i < totalSize; i++) {
  144|      0|        if (table[i].key == notPresent) {
  145|      0|            std::cout << " Empty ";
  146|      0|        } else if (table[i].key == tomb) {
  147|      0|            std::cout << " Tomb ";
  148|      0|        } else {
  149|      0|            std::cout << " ";
  150|      0|            std::cout << table[i].key;
  151|      0|            std::cout << " ";
  152|      0|        }
  153|      0|    }
  154|      0|    std::cout << std::endl;
  155|      0|}
  156|       |
  157|       |/** Rehashes the table into a bigger table
  158|       | * @returns none
  159|       | */
  160|      0|void rehash() {
  161|       |    // Necessary so wall of add info isn't printed all at once
  162|      0|    rehashing = true;
  163|      0|    int oldSize = totalSize;
  164|      0|    std::vector<Entry> oldTable(table);
  165|       |    // Really this should use the next prime number greater than totalSize * 2
  166|      0|    totalSize *= 2;
  167|      0|    table = std::vector<Entry>(totalSize);
  168|      0|    for (int i = 0; i < oldSize; i++) {
  169|      0|        if (oldTable[i].key != -1 && oldTable[i].key != notPresent) {
  170|      0|            size--;  // Size stays the same (add increments size)
  171|      0|            add(oldTable[i].key);
  172|      0|        }
  173|      0|    }
  174|       |    // delete[] oldTable;
  175|      0|    rehashing = false;
  176|      0|    std::cout << "Table was rehashed, new size is: " << totalSize << std::endl;
  177|      0|}
  178|       |
  179|       |/** Checks for load factor here
  180|       | * @param key  key value to hash and add to table
  181|       | */
  182|      0|void add(int key) {
  183|      0|    int index = quadraticProbe(key, false);
  184|      0|    table[index].key = key;
  185|       |    // Load factor greater than 0.5 causes resizing
  186|      0|    if (++size / static_cast<double>(totalSize) >= 0.5) {
  187|      0|        rehash();
  188|      0|    }
  189|      0|}
  190|       |
  191|       |/** Removes key. Leaves tombstone upon removal.
  192|       | * @param key  key value to hash and remove from table
  193|       | */
  194|      0|void remove(int key) {
  195|      0|    int index = quadraticProbe(key, true);
  196|      0|    if (index == notPresent) {
  197|      0|        std::cout << "key not found" << std::endl;
  198|      0|    }
  199|      0|    table[index].key = tomb;
  200|      0|    std::cout << "Removal successful, leaving tombstone" << std::endl;
  201|      0|    size--;
  202|      0|}
  203|       |
  204|       |/** Information about the adding process
  205|       | * @param key  key value to hash and add to table
  206|       | */
  207|      0|void addInfo(int key) {
  208|      0|    std::cout << "Initial table: ";
  209|      0|    display();
  210|      0|    std::cout << std::endl;
  211|      0|    std::cout << "hash of " << key << " is " << hashFxn(key) << " % "
  212|      0|              << totalSize << " == " << hashFxn(key) % totalSize;
  213|      0|    std::cout << std::endl;
  214|      0|    add(key);
  215|      0|    std::cout << "New table: ";
  216|      0|    display();
  217|      0|}
  218|       |
  219|       |/** Information about removal process
  220|       | * @param key  key value to hash and remove from table
  221|       | */
  222|      0|void removalInfo(int key) {
  223|      0|    std::cout << "Initial table: ";
  224|      0|    display();
  225|      0|    std::cout << std::endl;
  226|      0|    std::cout << "hash of " << key << " is " << hashFxn(key) << " % "
  227|      0|              << totalSize << " == " << hashFxn(key) % totalSize;
  228|      0|    std::cout << std::endl;
  229|      0|    remove(key);
  230|      0|    std::cout << "New table: ";
  231|      0|    display();
  232|      0|}
  233|       |
  234|       |}  // namespace quadratic_probing
  235|       |/**
  236|       | * @}
  237|       | */
  238|       |
  239|       |using quadratic_probing::Entry;
  240|       |using quadratic_probing::table;
  241|       |using quadratic_probing::totalSize;
  242|       |
  243|       |/** Main function
  244|       | * @returns None
  245|       | */
  246|      1|int main() {
  247|      1|    int cmd = 0, hash = 0, key = 0;
  248|      1|    std::cout << "Enter the initial size of Hash Table. = ";
  249|      1|    std::cin >> totalSize;
  250|      1|    table = std::vector<Entry>(totalSize);
  251|      1|    bool loop = true;
  252|      2|    while (loop) {
  253|      1|        std::cout << std::endl;
  254|      1|        std::cout << "PLEASE CHOOSE -" << std::endl;
  255|      1|        std::cout << "1. Add key. (Numeric only)" << std::endl;
  256|      1|        std::cout << "2. Remove key." << std::endl;
  257|      1|        std::cout << "3. Find key." << std::endl;
  258|      1|        std::cout << "4. Generate Hash. (Numeric only)" << std::endl;
  259|      1|        std::cout << "5. Display Hash table." << std::endl;
  260|      1|        std::cout << "6. Exit." << std::endl;
  261|      1|        std::cin >> cmd;
  262|      1|        switch (cmd) {
  263|      0|            case 1:
  264|      0|                std::cout << "Enter key to add = ";
  265|      0|                std::cin >> key;
  266|      0|                quadratic_probing::addInfo(key);
  267|      0|                break;
  268|      0|            case 2:
  269|      0|                std::cout << "Enter key to remove = ";
  270|      0|                std::cin >> key;
  271|      0|                quadratic_probing::removalInfo(key);
  272|      0|                break;
  273|      0|            case 3: {
  274|      0|                std::cout << "Enter key to search = ";
  275|      0|                std::cin >> key;
  276|      0|                quadratic_probing::Entry entry =
  277|      0|                    quadratic_probing::table[quadratic_probing::quadraticProbe(
  278|      0|                        key, true)];
  279|      0|                if (entry.key == quadratic_probing::notPresent) {
  280|      0|                    std::cout << "Key not present";
  281|      0|                }
  282|      0|                break;
  283|      0|            }
  284|      0|            case 4:
  285|      0|                std::cout << "Enter element to generate hash = ";
  286|      0|                std::cin >> key;
  287|      0|                std::cout << "Hash of " << key
  288|      0|                          << " is = " << quadratic_probing::hashFxn(key);
  289|      0|                break;
  290|      0|            case 5:
  291|      0|                quadratic_probing::display();
  292|      0|                break;
  293|      1|            default:
  294|      1|                loop = false;
  295|      1|                break;
  296|       |                // delete[] table;
  297|      1|        }
  298|      1|        std::cout << std::endl;
  299|      1|    }
  300|      1|    return 0;
  301|      1|}

