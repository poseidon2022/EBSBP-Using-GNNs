    1|       |/**
    2|       | * @file
    3|       | * @brief Iterative implementation of
    4|       | * [Factorial](https://en.wikipedia.org/wiki/Factorial)
    5|       | *
    6|       | * @author [Renjian-buchai](https://github.com/Renjian-buchai)
    7|       | *
    8|       | * @details Calculates factorial iteratively.
    9|       | * \f[n! = n\times(n-1)\times(n-2)\times(n-3)\times\ldots\times3\times2\times1
   10|       | *       = n\times(n-1)!\f]
   11|       | * for example:
   12|       | * \f$4! = 4\times3! = 4\times3\times2\times1 = 24\f$
   13|       | *
   14|       | * @example
   15|       | *
   16|       | * 5! = 5 * 4 * 3 * 2 * 1
   17|       | *
   18|       | * Recursive implementation of factorial pseudocode:
   19|       | *
   20|       | * function factorial(n):
   21|       | *     if n == 1:
   22|       | *         return 1
   23|       | *     else:
   24|       | *         return factorial(n-1)
   25|       | *
   26|       | */
   27|       |
   28|       |#include <cassert>    /// for assert
   29|       |#include <cstdint>    /// for integral types
   30|       |#include <exception>  /// for std::invalid_argument
   31|       |#include <iostream>   /// for std::cout
   32|       |
   33|       |/**
   34|       | * @namespace
   35|       | * @brief Mathematical algorithms
   36|       | */
   37|       |namespace math {
   38|       |
   39|       |/**
   40|       | * @brief Calculates the factorial iteratively.
   41|       | * @param n Nth factorial.
   42|       | * @return Factorial.
   43|       | * @note 0! = 1.
   44|       | * @warning Maximum=20 because there are no 128-bit integers in C++. 21!
   45|       | * returns 1.419e+19, which is not 21! but (21! % UINT64_MAX).
   46|       | */
   47|      6|uint64_t iterativeFactorial(uint8_t n) {
   48|      6|    if (n > 20) {
   49|      1|        throw std::invalid_argument("Maximum n value is 20");
   50|      1|    }
   51|       |
   52|       |    // 1 because it is the identity number of multiplication.
   53|      5|    uint64_t accumulator = 1;
   54|       |
   55|     37|    while (n > 1) {
   56|     32|        accumulator *= n;
   57|     32|        --n;
   58|     32|    }
   59|       |
   60|      5|    return accumulator;
   61|      6|}
   62|       |
   63|       |}  // namespace math
   64|       |
   65|       |/**
   66|       | * @brief Self-test implementations to test iterativeFactorial function.
   67|       | * @note There is 1 special case: 0! = 1.
   68|       | */
   69|      1|static void test() {
   70|       |    // Special case test
   71|      1|    std::cout << "Exception case test \n"
   72|      1|                 "Input: 0 \n"
   73|      1|                 "Expected output: 1 \n\n";
   74|      1|    assert(math::iterativeFactorial(0) == 1);
   75|       |
   76|       |    // Base case
   77|      0|    std::cout << "Base case test \n"
   78|      1|                 "Input: 1 \n"
   79|      1|                 "Expected output: 1 \n\n";
   80|      1|    assert(math::iterativeFactorial(1) == 1);
   81|       |
   82|       |    // Small case
   83|      0|    std::cout << "Small number case test \n"
   84|      1|                 "Input: 5 \n"
   85|      1|                 "Expected output: 120 \n\n";
   86|      1|    assert(math::iterativeFactorial(5) == 120);
   87|       |
   88|       |    // Medium case
   89|      0|    std::cout << "Medium number case test \n"
   90|      1|                 "Input: 10 \n"
   91|      1|                 "Expected output: 3628800 \n\n";
   92|      1|    assert(math::iterativeFactorial(10) == 3628800);
   93|       |
   94|       |    // Maximum case
   95|      0|    std::cout << "Maximum case test \n"
   96|      1|                 "Input: 20 \n"
   97|      1|                 "Expected output: 2432902008176640000\n\n";
   98|      1|    assert(math::iterativeFactorial(20) == 2432902008176640000);
   99|       |
  100|       |    // Exception test
  101|      0|    std::cout << "Exception test \n"
  102|      1|                 "Input: 21 \n"
  103|      1|                 "Expected output: Exception thrown \n";
  104|       |
  105|      1|    bool wasExceptionThrown = false;
  106|      1|    try {
  107|      1|        math::iterativeFactorial(21);
  108|      1|    } catch (const std::invalid_argument&) {
  109|      1|        wasExceptionThrown = true;
  110|      1|    }
  111|      1|    assert(wasExceptionThrown);
  112|       |
  113|      0|    std::cout << "All tests have passed successfully.\n";
  114|      1|}
  115|       |
  116|       |/**
  117|       | * @brief Main function
  118|       | * @returns 0 on exit
  119|       | */
  120|      1|int main() {
  121|      1|    test();  // Run self-test implementation
  122|      1|    return 0;
  123|      1|}

