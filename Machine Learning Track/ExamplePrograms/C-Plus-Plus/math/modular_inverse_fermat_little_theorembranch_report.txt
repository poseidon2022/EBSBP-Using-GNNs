    1|       |/**
    2|       | * @file
    3|       | * @brief C++ Program to find the modular inverse using [Fermat's Little
    4|       | * Theorem](https://en.wikipedia.org/wiki/Fermat%27s_little_theorem)
    5|       | *
    6|       | * Fermat's Little Theorem state that \f[ϕ(m) = m-1\f]
    7|       | * where \f$m\f$ is a prime number.
    8|       | * \f{eqnarray*}{
    9|       | *  a \cdot x &≡& 1 \;\text{mod}\; m\\
   10|       | *  x &≡& a^{-1} \;\text{mod}\; m
   11|       | * \f}
   12|       | * Using Euler's theorem we can modify the equation.
   13|       | *\f[
   14|       | * a^{ϕ(m)} ≡ 1 \;\text{mod}\; m
   15|       | * \f]
   16|       | * (Where '^' denotes the exponent operator)
   17|       | *
   18|       | * Here 'ϕ' is Euler's Totient Function. For modular inverse existence 'a' and
   19|       | * 'm' must be relatively primes numbers. To apply Fermat's Little Theorem is
   20|       | * necessary that 'm' must be a prime number. Generally in many competitive
   21|       | * programming competitions 'm' is either 1000000007 (1e9+7) or 998244353.
   22|       | *
   23|       | * We considered m as large prime (1e9+7).
   24|       | * \f$a^{ϕ(m)} ≡ 1 \;\text{mod}\; m\f$ (Using Euler's Theorem)
   25|       | * \f$ϕ(m) = m-1\f$ using Fermat's Little Theorem.
   26|       | * \f$a^{m-1} ≡ 1 \;\text{mod}\; m\f$
   27|       | * Now multiplying both side by \f$a^{-1}\f$.
   28|       | * \f{eqnarray*}{
   29|       | * a^{m-1} \cdot a^{-1} &≡& a^{-1} \;\text{mod}\; m\\
   30|       | * a^{m-2} &≡&  a^{-1} \;\text{mod}\; m
   31|       | * \f}
   32|       | *
   33|       | * We will find the exponent using binary exponentiation such that the
   34|       | * algorithm works in \f$O(\log n)\f$ time.
   35|       | *
   36|       | * Examples: -
   37|       | * * a = 3 and m = 7
   38|       | * * \f$a^{-1} \;\text{mod}\; m\f$ is equivalent to
   39|       | * \f$a^{m-2} \;\text{mod}\; m\f$
   40|       | * * \f$3^5 \;\text{mod}\; 7 = 243 \;\text{mod}\; 7 = 5\f$
   41|       | * <br/>Hence, \f$3^{-1} \;\text{mod}\; 7 = 5\f$
   42|       | * or \f$3 \times 5  \;\text{mod}\; 7 = 1 \;\text{mod}\; 7\f$
   43|       | * (as \f$a\times a^{-1} = 1\f$)
   44|       | */
   45|       |
   46|       |#include <cassert>  /// for assert
   47|       |#include <cstdint>  /// for std::int64_t
   48|       |#include <iostream> /// for IO implementations
   49|       |
   50|       |/**
   51|       | * @namespace math
   52|       | * @brief Maths algorithms.
   53|       | */
   54|       |namespace math {
   55|       |/**
   56|       | * @namespace modular_inverse_fermat
   57|       | * @brief Calculate modular inverse using Fermat's Little Theorem.
   58|       | */
   59|       |namespace modular_inverse_fermat {
   60|       |/**
   61|       | * @brief Calculate exponent with modulo using binary exponentiation in \f$O(\log b)\f$ time.
   62|       | * @param a The base
   63|       | * @param b The exponent
   64|       | * @param m The modulo
   65|       | * @return The result of \f$a^{b} % m\f$
   66|       | */
   67|      5|std::int64_t binExpo(std::int64_t a, std::int64_t b, std::int64_t m) {
   68|      5|  a %= m;
   69|      5|  std::int64_t res = 1;
   70|     94|  while (b > 0) {
   71|     89|    if (b % 2 != 0) {
   72|     60|      res = res * a % m;
   73|     60|    }
   74|     89|    a = a * a % m;
   75|       |    // Dividing b by 2 is similar to right shift by 1 bit
   76|     89|    b >>= 1;
   77|     89|  }
   78|      5|  return res;
   79|      5|}
   80|       |/**
   81|       | * @brief Check if an integer is a prime number in \f$O(\sqrt{m})\f$ time.
   82|       | * @param m An intger to check for primality
   83|       | * @return true if the number is prime
   84|       | * @return false if the number is not prime
   85|       | */
   86|      8|bool isPrime(std::int64_t m) {
   87|      8|  if (m <= 1) {
   88|      1|    return false;
   89|      1|  } 
   90|  63.7k|  for (std::int64_t i = 2; i * i <= m; i++) {
   91|  63.7k|    if (m % i == 0) {
   92|      1|      return false;
   93|      1|    }
   94|  63.7k|  }
   95|      6|  return true;
   96|      7|}
   97|       |/**
   98|       | * @brief calculates the modular inverse.
   99|       | * @param a Integer value for the base
  100|       | * @param m Integer value for modulo
  101|       | * @return The result that is the modular inverse of a modulo m
  102|       | */
  103|      8|std::int64_t modular_inverse(std::int64_t a, std::int64_t m) {
  104|     19|  while (a < 0) {
  105|     11|    a += m;
  106|     11|  }
  107|       |
  108|       |  // Check for invalid cases
  109|      8|  if (!isPrime(m) || a == 0) {
  110|      3|    return -1; // Invalid input
  111|      3|  }
  112|       |
  113|      5|  return binExpo(a, m - 2, m);  // Fermat's Little Theorem
  114|      8|}
  115|       |} // namespace modular_inverse_fermat
  116|       |} // namespace math
  117|       |
  118|       |/**
  119|       | * @brief Self-test implementation
  120|       | * @return void
  121|       | */
  122|      1|static void test() {
  123|      1|  assert(math::modular_inverse_fermat::modular_inverse(0, 97) == -1);
  124|      0|  assert(math::modular_inverse_fermat::modular_inverse(15, -2) == -1);
  125|      0|  assert(math::modular_inverse_fermat::modular_inverse(3, 10) == -1);
  126|      0|  assert(math::modular_inverse_fermat::modular_inverse(3, 7) == 5);
  127|      0|  assert(math::modular_inverse_fermat::modular_inverse(1, 101) == 1);
  128|      0|  assert(math::modular_inverse_fermat::modular_inverse(-1337, 285179) == 165519);
  129|      0|  assert(math::modular_inverse_fermat::modular_inverse(123456789, 998244353) == 25170271);
  130|      0|  assert(math::modular_inverse_fermat::modular_inverse(-9876543210, 1000000007) == 784794281);
  131|      1|}
  132|       |
  133|       |/**
  134|       | * @brief Main function
  135|       | * @return 0 on exit
  136|       | */
  137|      1|int main() {
  138|      1|  test();  // run self-test implementation
  139|      1|  return 0;
  140|      1|}

