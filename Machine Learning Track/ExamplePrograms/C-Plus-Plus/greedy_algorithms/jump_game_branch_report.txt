    1|       |/**
    2|       | * @file
    3|       | * @brief [Jumping Game](https://leetcode.com/problems/jump-game/)
    4|       | * algorithm implementation
    5|       | * @details
    6|       | *
    7|       | * Given an array of non-negative integers, you are initially positioned at the
    8|       | * first index of the array. Each element in the array represents your maximum
    9|       | * jump length at that position. Determine if you are able to reach the last
   10|       | * index. This solution takes in input as a vector and output as a boolean to
   11|       | * check if you can reach the last position. We name the indices good and bad
   12|       | * based on whether we can reach the destination if we start at that position.
   13|       | * We initialize the last index as lastPos.
   14|       | * Here, we start from the end of the array and check if we can ever reach the
   15|       | * first index. We check if the sum of the index and the maximum jump count
   16|       | * given is greater than or equal to the lastPos. If yes, then that is the last
   17|       | * position you can reach starting from the back. After the end of the loop, if
   18|       | * we reach the lastPos as 0, then the destination can be reached from the start
   19|       | * position.
   20|       | *
   21|       | * @author [Rakshaa Viswanathan](https://github.com/rakshaa2000)
   22|       | * @author [David Leal](https://github.com/Panquesito7)
   23|       | */
   24|       |
   25|       |#include <cassert>   /// for assert
   26|       |#include <iostream>  /// for std::cout
   27|       |#include <vector>    /// for std::vector
   28|       |
   29|       |/**
   30|       | * @namespace
   31|       | * @brief Greedy Algorithms
   32|       | */
   33|       |namespace greedy_algorithms {
   34|       |/**
   35|       | * @brief Checks whether the given element (default is `1`) can jump to the last
   36|       | * index.
   37|       | * @param nums array of numbers containing the maximum jump (in steps) from that
   38|       | * index
   39|       | * @returns true  if the index can be reached
   40|       | * @returns false if the index can NOT be reached
   41|       | */
   42|      5|bool can_jump(const std::vector<int> &nums) {
   43|      5|    size_t lastPos = nums.size() - 1;
   44|     30|    for (size_t i = lastPos; i != static_cast<size_t>(-1); i--) {
   45|     25|        if (i + nums[i] >= lastPos) {
   46|     17|            lastPos = i;
   47|     17|        }
   48|     25|    }
   49|      5|    return lastPos == 0;
   50|      5|}
   51|       |}  // namespace greedy_algorithms
   52|       |
   53|       |/**
   54|       | * @brief Function to test the above algorithm
   55|       | * @returns void
   56|       | */
   57|      1|static void test() {
   58|      1|    assert(greedy_algorithms::can_jump(std::vector<int>({4, 3, 1, 0, 5})));
   59|      0|    assert(!greedy_algorithms::can_jump(std::vector<int>({3, 2, 1, 0, 4})));
   60|      0|    assert(greedy_algorithms::can_jump(std::vector<int>({5, 9, 4, 7, 15, 3})));
   61|      0|    assert(!greedy_algorithms::can_jump(std::vector<int>({1, 0, 5, 8, 12})));
   62|      0|    assert(greedy_algorithms::can_jump(std::vector<int>({2, 1, 4, 7})));
   63|       |
   64|      0|    std::cout << "All tests have successfully passed!\n";
   65|      1|}
   66|       |
   67|       |/**
   68|       | * @brief Main function
   69|       | * @returns 0 on exit
   70|       | */
   71|      1|int main() {
   72|      1|    test();  // run self-test implementations
   73|      1|    return 0;
   74|      1|}

