    1|       |/**
    2|       | * @file
    3|       | * @brief [Dijkstra](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm) algorithm
    4|       | * implementation
    5|       | * @details
    6|       | * _Quote from Wikipedia._
    7|       | * 
    8|       | * **Dijkstra's algorithm** is an algorithm for finding the
    9|       | * shortest paths between nodes in a weighted graph, which may represent, for
   10|       | * example, road networks. It was conceived by computer scientist Edsger W.
   11|       | * Dijkstra in 1956 and published three years later.
   12|       | *
   13|       | * @author [David Leal](https://github.com/Panquesito7)
   14|       | * @author [Arpan Jain](https://github.com/arpanjain97)
   15|       | */
   16|       |
   17|       |#include <cassert>   /// for assert
   18|       |#include <climits>   /// for INT_MAX
   19|       |#include <iostream>  /// for IO operations
   20|       |#include <vector>    /// for std::vector
   21|       |
   22|       |/**
   23|       | * @namespace
   24|       | * @brief Greedy Algorithms
   25|       | */
   26|       |namespace greedy_algorithms {
   27|       |/**
   28|       | * @namespace
   29|       | * @brief Functions for the [Dijkstra](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm) algorithm implementation
   30|       | */
   31|       |namespace dijkstra {
   32|       |/**
   33|       | * @brief Wrapper class for storing a graph
   34|       | */
   35|       |class Graph {
   36|       | public:
   37|       |    int vertexNum = 0;
   38|       |    std::vector<std::vector<int>> edges{};
   39|       |
   40|       |    /**
   41|       |     * @brief Constructs a graph
   42|       |     * @param V number of vertices of the graph
   43|       |     */
   44|      1|    explicit Graph(const int V) {
   45|       |        // Initialize the array edges
   46|      1|        this->edges = std::vector<std::vector<int>>(V, std::vector<int>(V, 0));
   47|      9|        for (int i = 0; i < V; i++) {
   48|      8|            edges[i] = std::vector<int>(V, 0);
   49|      8|        }
   50|       |
   51|       |        // Fills the array with zeros
   52|      9|        for (int i = 0; i < V; i++) {
   53|     72|            for (int j = 0; j < V; j++) {
   54|     64|                edges[i][j] = 0;
   55|     64|            }
   56|      8|        }
   57|       |
   58|      1|        this->vertexNum = V;
   59|      1|    }
   60|       |
   61|       |    /**
   62|       |     * @brief Adds an edge to the graph
   63|       |     * @param src the graph the edge should be added to
   64|       |     * @param dst the position where the edge should be added to
   65|       |     * @param weight the weight of the edge that should be added
   66|       |     * @returns void
   67|       |     */
   68|     13|    void add_edge(int src, int dst, int weight) {
   69|     13|        this->edges[src][dst] = weight;
   70|     13|    }
   71|       |};
   72|       |
   73|       |/**
   74|       | * @brief Utility function that finds
   75|       | * the vertex with the minimum distance in `mdist`.
   76|       | *
   77|       | * @param mdist array of distances to each vertex
   78|       | * @param vset array indicating inclusion in the shortest path tree
   79|       | * @param V the number of vertices in the graph
   80|       | * @returns index of the vertex with the minimum distance
   81|       | */
   82|      0|int minimum_distance(std::vector<int> mdist, std::vector<bool> vset, int V) {
   83|      0|    int minVal = INT_MAX, minInd = 0;
   84|      0|    for (int i = 0; i < V; i++) {
   85|      0|        if (!vset[i] && (mdist[i] < minVal)) {
   86|      0|            minVal = mdist[i];
   87|      0|            minInd = i;
   88|      0|        }
   89|      0|    }
   90|       |
   91|      0|    return minInd;
   92|      0|}
   93|       |
   94|       |/**
   95|       | * @brief Utility function to print the distances to vertices.
   96|       | *
   97|       | * This function prints the distances to each vertex in a tabular format. If the
   98|       | * distance is equal to INT_MAX, it is displayed as "INF".
   99|       | *
  100|       | * @param dist An array representing the distances to each vertex.
  101|       | * @param V The number of vertices in the graph.
  102|       | * @return void
  103|       | */
  104|      0|void print(std::vector<int> dist, int V) {
  105|      0|    std::cout << "\nVertex  Distance\n";
  106|      0|    for (int i = 0; i < V; i++) {
  107|      0|        if (dist[i] < INT_MAX) {
  108|      0|            std::cout << i << "\t" << dist[i] << "\n";
  109|      0|        }
  110|      0|        else {
  111|      0|            std::cout << i << "\tINF" << "\n";
  112|      0|        }
  113|      0|    }
  114|      0|}
  115|       |
  116|       |/**
  117|       | * @brief The main function that finds the shortest path from a given source
  118|       | * to all other vertices using Dijkstra's Algorithm.
  119|       | * @note This doesn't work on negative weights.
  120|       | * @param graph the graph to be processed
  121|       | * @param src the source of the given vertex
  122|       | * @returns void
  123|       | */
  124|      0|void dijkstra(Graph graph, int src) {
  125|      0|    int V = graph.vertexNum;
  126|      0|    std::vector<int> mdist{};  // Stores updated distances to the vertex
  127|      0|    std::vector<bool> vset{};  // `vset[i]` is true if the vertex `i` is included in the shortest path tree
  128|       |
  129|       |    // Initialize `mdist and `vset`. Set the distance of the source as zero
  130|      0|    for (int i = 0; i < V; i++) {
  131|      0|        mdist[i] = INT_MAX;
  132|      0|        vset[i] = false;
  133|      0|    }
  134|       |
  135|      0|    mdist[src] = 0;
  136|       |
  137|       |    // iterate to find the shortest path
  138|      0|    for (int count = 0; count < V - 1; count++) {
  139|      0|        int u = minimum_distance(mdist, vset, V);
  140|       |
  141|      0|        vset[u] = true;
  142|       |
  143|      0|        for (int v = 0; v < V; v++) {
  144|      0|            if (!vset[v] && graph.edges[u][v] &&
  145|      0|                mdist[u] + graph.edges[u][v] < mdist[v]) {
  146|      0|                mdist[v] = mdist[u] + graph.edges[u][v];
  147|      0|            }
  148|      0|        }
  149|      0|    }
  150|       |
  151|      0|    print(mdist, V);
  152|      0|}
  153|       |}  // namespace dijkstra
  154|       |}  // namespace greedy_algorithms
  155|       |
  156|       |/**
  157|       | * @brief Self-test implementations
  158|       | * @returns void
  159|       | */
  160|      1|static void tests() {
  161|      1|    greedy_algorithms::dijkstra::Graph graph(8);
  162|       |
  163|       |    // 1st test.
  164|      1|    graph.add_edge(6, 2, 4);
  165|      1|    graph.add_edge(2, 6, 4);
  166|       |
  167|      1|    assert(graph.edges[6][2] == 4);
  168|       |
  169|       |    // 2nd test.
  170|      0|    graph.add_edge(0, 1, 1);
  171|      1|    graph.add_edge(1, 0, 1);
  172|       |
  173|      1|    assert(graph.edges[0][1] == 1);
  174|       |
  175|       |    // 3rd test.
  176|      0|    graph.add_edge(0, 2, 7);
  177|      1|    graph.add_edge(2, 0, 7);
  178|      1|    graph.add_edge(1, 2, 1);
  179|      1|    graph.add_edge(2, 1, 1);
  180|       |
  181|      1|    assert(graph.edges[0][2] == 7);
  182|       |
  183|       |    // 4th test.
  184|      0|    graph.add_edge(1, 3, 3);
  185|      1|    graph.add_edge(3, 1, 3);
  186|      1|    graph.add_edge(1, 4, 2);
  187|      1|    graph.add_edge(4, 1, 2);
  188|      1|    graph.add_edge(2, 3, 2);
  189|       |
  190|      1|    assert(graph.edges[1][3] == 3);
  191|       |
  192|      0|    std::cout << "All tests have successfully passed!\n";
  193|      1|}
  194|       |
  195|       |/**
  196|       | * @brief Main function
  197|       | * @returns 0 on exit
  198|       | */
  199|      1|int main() {
  200|      1|    tests();  // run self-test implementations
  201|      1|    return 0;
  202|      1|}

