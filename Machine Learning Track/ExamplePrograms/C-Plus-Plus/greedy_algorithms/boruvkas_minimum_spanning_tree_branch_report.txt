    1|       |﻿/**
    2|       | * @author [Jason Nardoni](https://github.com/JNardoni)
    3|       | * @file
    4|       | *
    5|       | * @brief
    6|       | * [Borůvkas Algorithm](https://en.wikipedia.org/wiki/Borůvka's_algorithm) to
    7|       | *find the Minimum Spanning Tree
    8|       | *
    9|       | *
   10|       | * @details
   11|       | * Boruvka's algorithm is a greepy algorithm to find the MST by starting with
   12|       | *small trees, and combining them to build bigger ones.
   13|       | *	1. Creates a group for every vertex.
   14|       | *	2. looks through each edge of every vertex for the smallest weight. Keeps
   15|       | *track of the smallest edge for each of the current groups.
   16|       | *  3. Combine each group with the group it shares its smallest edge, adding the
   17|       | *smallest edge to the MST.
   18|       | *  4. Repeat step 2-3 until all vertices are combined into a single group.
   19|       | *
   20|       | * It assumes that the graph is connected. Non-connected edges can be
   21|       | *represented using 0 or INT_MAX
   22|       | *
   23|       | */
   24|       |
   25|       |#include <cassert>   /// for assert
   26|       |#include <climits>   /// for INT_MAX
   27|       |#include <iostream>  /// for IO operations
   28|       |#include <vector>    /// for std::vector
   29|       |
   30|       |/**
   31|       | * @namespace greedy_algorithms
   32|       | * @brief Greedy Algorithms
   33|       | */
   34|       |namespace greedy_algorithms {
   35|       |/**
   36|       | * @namespace boruvkas_minimum_spanning_tree
   37|       | * @brief Functions for the [Borůvkas
   38|       | * Algorithm](https://en.wikipedia.org/wiki/Borůvka's_algorithm) implementation
   39|       | */
   40|       |namespace boruvkas_minimum_spanning_tree {
   41|       |/**
   42|       | * @brief Recursively returns the vertex's parent at the root of the tree
   43|       | * @param parent the array that will be checked
   44|       | * @param v vertex to find parent of
   45|       | * @returns the parent of the vertex
   46|       | */
   47|     60|int findParent(std::vector<std::pair<int, int>> parent, const int v) {
   48|     60|    if (parent[v].first != v) {
   49|     14|        parent[v].first = findParent(parent, parent[v].first);
   50|     14|    }
   51|       |
   52|     60|    return parent[v].first;
   53|     60|}
   54|       |
   55|       |/**
   56|       | * @brief the implementation of boruvka's algorithm
   57|       | * @param adj a graph adjancency matrix stored as 2d vectors.
   58|       | * @returns the MST as 2d vectors
   59|       | */
   60|      2|std::vector<std::vector<int>> boruvkas(std::vector<std::vector<int>> adj) {
   61|      2|    size_t size = adj.size();
   62|      2|    size_t total_groups = size;
   63|       |
   64|      2|    if (size <= 1) {
   65|      0|        return adj;
   66|      0|    }
   67|       |
   68|       |    // Stores the current Minimum Spanning Tree. As groups are combined, they
   69|       |    // are added to the MST
   70|      2|    std::vector<std::vector<int>> MST(size, std::vector<int>(size, INT_MAX));
   71|     12|    for (int i = 0; i < size; i++) {
   72|     10|        MST[i][i] = 0;
   73|     10|    }
   74|       |
   75|       |    // Step 1: Create a group for each vertex
   76|       |
   77|       |    // Stores the parent of the vertex and its current depth, both initialized
   78|       |    // to 0
   79|      2|    std::vector<std::pair<int, int>> parent(size, std::make_pair(0, 0));
   80|       |
   81|     12|    for (int i = 0; i < size; i++) {
   82|     10|        parent[i].first =
   83|     10|            i;  // Sets parent of each vertex to itself, depth remains 0
   84|     10|    }
   85|       |
   86|       |    // Repeat until all are in a single group
   87|      5|    while (total_groups > 1) {
   88|      3|        std::vector<std::pair<int, int>> smallest_edge(
   89|      3|            size, std::make_pair(-1, -1));  // Pairing: start node, end node
   90|       |
   91|       |        // Step 2: Look throught each vertex for its smallest edge, only using
   92|       |        // the right half of the adj matrix
   93|     18|        for (int i = 0; i < size; i++) {
   94|     45|            for (int j = i + 1; j < size; j++) {
   95|     30|                if (adj[i][j] == INT_MAX || adj[i][j] == 0) {  // No connection
   96|     13|                    continue;
   97|     13|                }
   98|       |
   99|       |                // Finds the parents of the start and end points to make sure
  100|       |                // they arent in the same group
  101|     17|                int parentA = findParent(parent, i);
  102|     17|                int parentB = findParent(parent, j);
  103|       |
  104|     17|                if (parentA != parentB) {
  105|       |                    // Grabs the start and end points for the first groups
  106|       |                    // current smallest edge
  107|     13|                    int start = smallest_edge[parentA].first;
  108|     13|                    int end = smallest_edge[parentA].second;
  109|       |
  110|       |                    // If there is no current smallest edge, or the new edge is
  111|       |                    // smaller, records the new smallest
  112|     13|                    if (start == -1 || adj[i][j] < adj[start][end]) {
  113|      5|                        smallest_edge[parentA].first = i;
  114|      5|                        smallest_edge[parentA].second = j;
  115|      5|                    }
  116|       |
  117|       |                    // Does the same for the second group
  118|     13|                    start = smallest_edge[parentB].first;
  119|     13|                    end = smallest_edge[parentB].second;
  120|       |
  121|     13|                    if (start == -1 || adj[j][i] < adj[start][end]) {
  122|     10|                        smallest_edge[parentB].first = j;
  123|     10|                        smallest_edge[parentB].second = i;
  124|     10|                    }
  125|     13|                }
  126|     17|            }
  127|     15|        }
  128|       |
  129|       |        // Step 3: Combine the groups based off their smallest edge
  130|       |
  131|     18|        for (int i = 0; i < size; i++) {
  132|       |            // Makes sure the smallest edge exists
  133|     15|            if (smallest_edge[i].first != -1) {
  134|       |                // Start and end points for the groups smallest edge
  135|     12|                int start = smallest_edge[i].first;
  136|     12|                int end = smallest_edge[i].second;
  137|       |
  138|       |                // Parents of the two groups - A is always itself
  139|     12|                int parentA = i;
  140|     12|                int parentB = findParent(parent, end);
  141|       |
  142|       |                // Makes sure the two nodes dont share the same parent. Would
  143|       |                // happen if the two groups have been
  144|       |                // merged previously through a common shortest edge
  145|     12|                if (parentA == parentB) {
  146|      4|                    continue;
  147|      4|                }
  148|       |
  149|       |                // Tries to balance the trees as much as possible as they are
  150|       |                // merged. The parent of the shallower
  151|       |                // tree will be pointed to the parent of the deeper tree.
  152|      8|                if (parent[parentA].second < parent[parentB].second) {
  153|      0|                    parent[parentB].first = parentA;  // New parent
  154|      0|                    parent[parentB].second++;         // Increase depth
  155|      8|                } else {
  156|      8|                    parent[parentA].first = parentB;
  157|      8|                    parent[parentA].second++;
  158|      8|                }
  159|       |                // Add the connection to the MST, using both halves of the adj
  160|       |                // matrix
  161|      8|                MST[start][end] = adj[start][end];
  162|      8|                MST[end][start] = adj[end][start];
  163|      8|                total_groups--;  // one fewer group
  164|      8|            }
  165|     15|        }
  166|      3|    }
  167|      2|    return MST;
  168|      2|}
  169|       |
  170|       |/**
  171|       | * @brief counts the sum of edges in the given tree
  172|       | * @param adj 2D vector adjacency matrix
  173|       | * @returns the int size of the tree
  174|       | */
  175|      2|int test_findGraphSum(std::vector<std::vector<int>> adj) {
  176|      2|    size_t size = adj.size();
  177|      2|    int sum = 0;
  178|       |
  179|       |    // Moves through one side of the adj matrix, counting the sums of each edge
  180|     12|    for (int i = 0; i < size; i++) {
  181|     30|        for (int j = i + 1; j < size; j++) {
  182|     20|            if (adj[i][j] < INT_MAX) {
  183|      8|                sum += adj[i][j];
  184|      8|            }
  185|     20|        }
  186|     10|    }
  187|      2|    return sum;
  188|      2|}
  189|       |}  // namespace boruvkas_minimum_spanning_tree
  190|       |}  // namespace greedy_algorithms
  191|       |
  192|       |/**
  193|       | * @brief Self-test implementations
  194|       | * @returns void
  195|       | */
  196|      1|static void tests() {
  197|      1|    std::cout << "Starting tests...\n\n";
  198|      1|    std::vector<std::vector<int>> graph = {
  199|      1|        {0, 5, INT_MAX, 3, INT_MAX}, {5, 0, 2, INT_MAX, 5},
  200|      1|        {INT_MAX, 2, 0, INT_MAX, 3}, {3, INT_MAX, INT_MAX, 0, INT_MAX},
  201|      1|        {INT_MAX, 5, 3, INT_MAX, 0},
  202|      1|    };
  203|      1|    std::vector<std::vector<int>> MST =
  204|      1|        greedy_algorithms::boruvkas_minimum_spanning_tree::boruvkas(graph);
  205|      1|    assert(greedy_algorithms::boruvkas_minimum_spanning_tree::test_findGraphSum(
  206|      1|               MST) == 13);
  207|      0|    std::cout << "1st test passed!" << std::endl;
  208|       |
  209|      1|    graph = {{0, 2, 0, 6, 0},
  210|      1|             {2, 0, 3, 8, 5},
  211|      1|             {0, 3, 0, 0, 7},
  212|      1|             {6, 8, 0, 0, 9},
  213|      1|             {0, 5, 7, 9, 0}};
  214|      1|    MST = greedy_algorithms::boruvkas_minimum_spanning_tree::boruvkas(graph);
  215|      1|    assert(greedy_algorithms::boruvkas_minimum_spanning_tree::test_findGraphSum(
  216|      1|               MST) == 16);
  217|      0|    std::cout << "2nd test passed!" << std::endl;
  218|      1|}
  219|       |
  220|       |/**
  221|       | * @brief Main function
  222|       | * @returns 0 on exit
  223|       | */
  224|      1|int main() {
  225|      1|    tests();  // run self-test implementations
  226|      1|    return 0;
  227|      1|}

